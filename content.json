{"meta":{"title":"人生如戏，全靠颜值","subtitle":"人生如戏，全靠颜值","description":null,"author":"chen guoji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"关于","slug":"about","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-21T08:43:05.374Z","comments":true,"path":"2019/03/21/about/","link":"","permalink":"http://yoursite.com/2019/03/21/about/","excerpt":"","text":"关于博主博主是一名Java码农。虽然还未走上人生巅峰，但是一直保持着一个码农的自我修养。用一句话概括博主：每天瞎逼忙，还没赚到钱。但是博主有一颗分享技术的心，我会尽量用通俗易懂的方式，分享个人的知识。 博客的宗旨就是分享知识，分享技术，不一定高深，但一定是博主用心写作而成的。所有人都是从0开始起步，在学习过程中，会遇到各种困难，这个时候如果可以借鉴别人的经验，会让我们省力不少，希望我的博客也能帮助到你。","categories":[{"name":"关于","slug":"关于","permalink":"http://yoursite.com/categories/关于/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://yoursite.com/tags/博客说明/"}],"keywords":[{"name":"关于","slug":"关于","permalink":"http://yoursite.com/categories/关于/"}]},{"title":"Java转型大数据开发教程，都在这儿！","slug":"hd","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-21T08:51:52.744Z","comments":true,"path":"2019/03/21/hd/","link":"","permalink":"http://yoursite.com/2019/03/21/hd/","excerpt":"","text":"很多老读者都知道，对于技术方面，栈长我一直提倡的是精一门，再横向发展，多学一点总不是坏事。 什么意思呢？就是我们当前工作用到的那一门技术一定要学好、学精、学深，然后可以拓展其他相关的技术栈。 如此多的技术，怎么学得过来呢？ 我觉得以你自己的岗位为主，其他为辅，关于自己工作相关的技术，花更多的时间和精力，研究得更深入，其他领域的可以了解和关注，等到需要用到或者感兴趣的时候，在深入学习即可。 那作为 Java 开发，除了 Java 还可以学什么？ 大数据可能是一个不错的方向。 一、转型大数据需要哪些技能？技术层面来说，如果你初步掌握Java编程，转型大数据都是非常轻松的具有天然的优势。 Java编程是大数据开发的基础，Java编程是必备技能； 大数据使用的Hadoop(在分布式服务器集群上存储海量数据并运行分布式分析应用的一种方法)需要Java基础， 所以有很多搞Java的都在往这hadoop大数据方向转。 二、大数据开发高薪必备资源 Oracle高级技术总监多年精心创作一套完整课程体系【大数据学习必看】，全面助力大数据开发零基础+入门+提升+项目=高薪！","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"java、大数据","slug":"java、大数据","permalink":"http://yoursite.com/tags/java、大数据/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Java面试中最高频的那20%知识点！","slug":"mianshi","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-21T08:50:47.427Z","comments":true,"path":"2019/03/21/mianshi/","link":"","permalink":"http://yoursite.com/2019/03/21/mianshi/","excerpt":"","text":"Java目前已经不仅仅是一门开发语言，而是一整套生态体系。 作为一个Java程序员，既是幸运的，也是不幸的。幸运的是我们有很多轮子可以拿过来用，不幸的是我们有太多的轮子需要学习。 但是，无论是日常工作还是面试问题，也都符合二八原则。即掌握20%的知识，就能解决80%的问题。 那么，Java程序员必须掌握的20%知识点都有哪些呢？ 个人认为包括以下内容： Java基础知识，如集合类、IO、泛型、等。 JVM底层知识，如类加载机制、GC、JVM内存结构等。 Java并发编程知识，如Java内存模型、并发包、线程池、netty等。 开发框架知识，如Spring、mybatis、docker、springboot、springmavc等。 分布式相关知识，如CAP理论、分布式锁、分布式事务、Zookeeper等。 其他基础知识，编程语言、网络方面、数据库、数据结构和算法。 中间件相关知识，如Redis、rabbitMQ、Dubbo等。 服务器相关知识，如tomcat、jetty、jboss等。 栈长认为，以上这些知识，就是最高频的面试问题，以及工作中需要用到的知识。当然，一个程序员想要掌握以上所有知识，可能需要花费很长时间。这个过程注定是漫长且孤独的。 https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"Web 实时推送技术的总结","slug":"qd","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-21T08:48:19.751Z","comments":true,"path":"2019/03/21/qd/","link":"","permalink":"http://yoursite.com/2019/03/21/qd/","excerpt":"","text":"前言随着 Web 的发展，用户对于 Web 的实时推送要求也越来越高 ，比如，工业运行监控、Web 在线通讯、即时报价系统、在线游戏等，都需要将后台发生的变化主动地、实时地传送到浏览器端，而不需要用户手动地刷新页面。本文对过去和现在流行的 Web 实时推送技术进行了比较与总结。 本文完整的源代码请猛戳Github博客(https://github.com/ljianshu/Blog)，纸上得来终觉浅，建议大家动手敲敲代码。 一、双向通信HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。在WebSocket协议之前，有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和iframe流（streaming）。 1.轮询（polling）轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且每次发送请求都会有Http的Header，会很耗流量，也会消耗CPU的利用率。 优点：实现简单，无需做过多的更改缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担 123456789101112131415161718192021222324252627// 1.html &lt;div id=&quot;clock&quot;&gt;&lt;/div&gt; &lt;script&gt; let clockDiv = document.getElementById(&apos;clock&apos;); setInterval(function()&#123; let xhr = new XMLHttpRequest; xhr.open(&apos;GET&apos;,&apos;/clock&apos;,true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); clockDiv.innerHTML = xhr.responseText; &#125; &#125; xhr.send(); &#125;,1000); &lt;/script&gt; //轮询 服务端let express = require(&apos;express&apos;);let app = express();app.use(express.static(__dirname));app.get(&apos;/clock&apos;,function(req,res)&#123; res.end(new Date().toLocaleString());&#125;);app.listen(8080); 启动本地服务，打开http://localhost:8080/1.html,查看结果。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"html、web","slug":"html、web","permalink":"http://yoursite.com/tags/html、web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"MyBatis动态SQL","slug":"MyBatis动态SQL","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-21T09:02:07.179Z","comments":true,"path":"2019/03/21/MyBatis动态SQL/","link":"","permalink":"http://yoursite.com/2019/03/21/MyBatis动态SQL/","excerpt":"温馨提示：文中代码看不全可左右滑动MyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。 MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：","text":"温馨提示：文中代码看不全可左右滑动MyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。 MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签： 一、 数据准备 为了后面的演示， 创建了一个 Maven 项目 mybatis-dynamic, 创建了对应的数据库和表 DROP TABLE IF EXISTS student; CREATE TABLE student ( student_id int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT ‘编号’, name varchar(20) DEFAULT NULL COMMENT ‘姓名’, phone varchar(20) DEFAULT NULL COMMENT ‘电话’, email varchar(50) DEFAULT NULL COMMENT ‘邮箱’, sex tinyint(4) DEFAULT NULL COMMENT ‘性别’, locked tinyint(4) DEFAULT NULL COMMENT ‘状态(0:正常,1:锁定)’, gmt_created datetime DEFAULT CURRENT_TIMESTAMP COMMENT ‘存入数据库的时间’, gmt_modified datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘修改的时间’, delete int(11) DEFAULT NULL, PRIMARY KEY (student_id)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=’学生表’; 二、 if 标签 if 标签是我们最常使用的。 在查询、删除、更新的时候很可能会使用到。 必须结合 test 属性联合使用。 2.1 在 WHERE 条件中使用 if 标签 这是常见的一种现象， 我们在进行按条件查询的时候， 可能会有多种情况。 2.1.1 查询条件 根据输入的学生信息进行条件检索 当只输入用户名时， 使用用户名进行模糊检索；当只输入性别时， 使用性别进行完全匹配当用户名和性别都存在时， 用这两个条件进行查询匹配查询2.1.2 动态 SQL 接口函数 /** 根据输入的学生信息进行条件检索 当只输入用户名时， 使用用户名进行模糊检索； 当只输入邮箱时， 使用性别进行完全匹配 当用户名和性别都存在时， 用这两个条件进行查询匹配的用 @param student @return*/ List selectByStudentSelective(Student student); 对应的动态 SQL select from student where 1=1 and name like concat(‘%’, #{name}, ‘%’) and sex=#{sex} 在此 SQL 语句中， where 1=1 是多条件拼接时的小技巧， 后面的条件查询就可以都用 and 了。 同时， 我们添加了 if 标签来处理动态 SQL and name like concat(‘%’, #{name}, ‘%’) and sex=#{sex} 此 if 标签的 test 属性值是一个符合 OGNL 的表达式， 表达式可以是 true 或 false。 如果表达式返回的是数值， 则0为 false, 非 0 为 true; 2.1.3 测试 @Test public void selectByStudent() { SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student search = new Student(); search.setName(&quot;明&quot;); System.out.println(&quot;只有名字时的查询&quot;); List&lt;Student&gt; studentsByName = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsByName.size(); i++) { System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE)); } search.setName(null); search.setSex((byte) 1); System.out.println(&quot;只有性别时的查询&quot;); List&lt;Student&gt; studentsBySex = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsBySex.size(); i++) { System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE)); } System.out.println(&quot;姓名和性别同时存在的查询&quot;); search.setName(&quot;明&quot;); List&lt;Student&gt; studentsByNameAndSex = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsByNameAndSex.size(); i++) { System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE)); } sqlSession.commit(); sqlSession.close(); 只有名字时的查询， 发送的语句和结果 查询的条件只发送了 where 1=1 and name like concat(‘%’, ?, ‘%’) 只有性别时的查询， 发送的语句和结果 查询的条件只发送了 where 1=1 and sex=? 姓名和性别同时存在的查询， 发送的语句和结果 查询条件 where 1=1 and name like concat(‘%’, ?, ‘%’) and sex=? 2.2 在 UPDATE 更新列中使用 if 标签 有时候我们不希望更新所有的字段， 只更新有变化的字段。 2.2.1 更新条件 只更新有变化的字段， 空值不更新。 2.2.1 动态 SQL 接口方法 /** * 更新非空属性 */ int updateByPrimaryKeySelective(Student record); 对应的 SQL update student name = #{name,jdbcType=VARCHAR}, phone = #{phone,jdbcType=VARCHAR}, email = #{email,jdbcType=VARCHAR}, sex = #{sex,jdbcType=TINYINT}, locked = #{locked,jdbcType=TINYINT}, gmt_created = #{gmtCreated,jdbcType=TIMESTAMP}, gmt_modified = #{gmtModified,jdbcType=TIMESTAMP}, where student_id = #{studentId,jdbcType=INTEGER}2.2.3 测试 @Test public void updateByStudentSelective() { SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(); student.setStudentId(1); student.setName(&quot;明明&quot;); student.setPhone(&quot;13838438888&quot;); System.out.println(studentMapper.updateByPrimaryKeySelective(student)); sqlSession.commit(); sqlSession.close();2.3 在 INSERT 动态插入中使用 if 标签 我们插入数据库中的一条记录， 不是每一个字段都有值的， 而是动态变化的。 在这时候使用 if 标签， 可帮我们解决这个问题。 2.3.1 插入条件 只有非空属性才插入。 2.3.2 动态SQL 接口方法 /** * 非空字段才进行插入 */ int insertSelective(Student record); 对应的SQL insert into student student_id, name, phone, email, sex, locked, gmt_created, gmt_modified, #{studentId,jdbcType=INTEGER}, &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; #{name,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt; #{phone,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; #{email,jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; #{sex,jdbcType=TINYINT}, &lt;/if&gt; &lt;if test=&quot;locked != null&quot;&gt; #{locked,jdbcType=TINYINT}, &lt;/if&gt; &lt;if test=&quot;gmtCreated != null&quot;&gt; #{gmtCreated,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;if test=&quot;gmtModified != null&quot;&gt; #{gmtModified,jdbcType=TIMESTAMP}, &lt;/if&gt; &lt;/trim&gt; 这个 SQL 大家应该很熟悉， 毕竟是自动生成的。 2.3.3 测试 @Test public void insertByStudentSelective() { SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(); student.setName(&quot;小飞机&quot;); student.setPhone(&quot;13838438899&quot;); student.setEmail(&quot;xiaofeiji@qq.com&quot;); student.setLocked((byte) 0); System.out.println(studentMapper.insertSelective(student)); sqlSession.commit(); sqlSession.close(); } SQL 中， 只有非空的字段才进行了插入。 七、代码 使用示例： https://github.com/homejim/mybatis-examples 转载来源:作者：阿进的写字台cnblogs.com/homejim/p/9909657.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"github+hexo搭建博客","slug":"hexo搭建","date":"2019-03-19T08:39:50.000Z","updated":"2019-03-21T08:42:08.342Z","comments":true,"path":"2019/03/19/hexo搭建/","link":"","permalink":"http://yoursite.com/2019/03/19/hexo搭建/","excerpt":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等；","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"网站建设","slug":"网站建设","permalink":"http://yoursite.com/tags/网站建设/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-18T08:53:40.331Z","updated":"2019-03-18T08:53:40.332Z","comments":true,"path":"2019/03/18/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}