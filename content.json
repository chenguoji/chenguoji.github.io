{"meta":{"title":"陈国际博客","subtitle":"人生如戏，全靠颜值","description":"努力做有价值的技术文章","author":"chen guoji","url":"http://chenguoji.com"},"pages":[{"title":"categories","date":"2019-04-01T09:15:10.000Z","updated":"2019-04-02T07:24:35.247Z","comments":true,"path":"categories/index.html","permalink":"http://chenguoji.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-04-01T09:16:14.000Z","updated":"2019-04-02T07:23:47.709Z","comments":true,"path":"friends/index.html","permalink":"http://chenguoji.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-01T09:15:36.000Z","updated":"2019-04-02T07:24:21.969Z","comments":true,"path":"tags/index.html","permalink":"http://chenguoji.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-01T02:10:14.000Z","updated":"2019-04-02T07:25:56.525Z","comments":true,"path":"about/index.html","permalink":"http://chenguoji.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"【漫画】996对程序员的伤害，一看你就懂","slug":"【漫画】996对程序员的伤害，一看你就懂","date":"2019-04-26T05:41:34.000Z","updated":"2019-04-26T05:23:05.460Z","comments":true,"path":"2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/","link":"","permalink":"http://chenguoji.com/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/","excerpt":"","text":"我在一家互联网大厂上班，我很骄傲，有一天，上司递给我一张协议我知道公司的难处，想到自己还背着房贷，只能接受上司很赏识我，委派了重要项目给我不过因为家住的远，9点下班，加上1个半小时车程，回到家都接近晚上11点了以前下班，我会跟女朋友吃饭，玩一会游戏，然后才是睡觉现在直接睡觉以前星期六，我会和朋友爬山，或陪女友逛街现在周六没了，周日只想补觉1年过去，我少陪了女朋友264次晚饭（22*12）。 因为一起做的事情越来越少，我们之间好像慢慢少了一些默契。 朋友再没邀过我爬山了，因为每次我都回“加班中”。 PS4也早就挂闲鱼卖掉了，当然是女朋友卖的，我哪有时间。 我感觉自己像从没出过公司有一次做梦，我梦到自己变成哥斯拉，喷火把公司和老板烧了半夜梦醒，去完夜尿却赶紧打开电脑，看看老板有无回复邮件渐渐地，我胖了，看着自己2年前的照片，咦？原来我也瘦过有一天，我发现隔壁同事在哭，急忙安慰，问起原因，才知道他错过了母亲的葬礼。还好还好，我只是错过几次好友的婚礼。 我还年轻，身体壮的很，但奇怪的是最近小小感冒都会发烧，吃根辣条也能得肠胃炎。应该是天气原因，我安慰自己 我是父母逢人便夸的骄傲但这个骄傲，已经好几年没陪父母一起看电视了是不是，应该请个假回家看看父母？还是…等过了这段时间吧 女朋友想要小孩，说好可爱！小孩？我会有时间..照顾他么？还是… 女朋友说好久没去旅游了，我说等过了这段时间，她半天不说话，我回头一看，她在擦眼泪我们都是那种很乖的人，很少对人说不，很能忍，什么事都咬碎牙齿往肚子里吞，很少情绪外露，但今天.. 有人这样解释什么是生活，拿一台照相机，把每个开心的瞬间拍下来，贴到墙上，就组成了生活但最近这一年，好像没什么值得贴的应该是照相机也拿去闲鱼卖了 那么，我还在生活么，也许我只是活着这样的日子还要多久？可能用不了多久，也可能要一辈子我不想这样，我要找回我的生活照相机 … 996，想说爱你不容易！ 来源：挖数链接：https://mp.weixin.qq.com/s/50Z6wEs6lNUHCerLmV-vYQ","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"大公司的面试官是如何挑人的？","slug":"大公司的面试官是如何挑人的？","date":"2019-04-24T05:41:34.000Z","updated":"2019-04-24T09:05:15.713Z","comments":true,"path":"2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/","link":"","permalink":"http://chenguoji.com/2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/","excerpt":"","text":"又到一年一度的跳槽求职高峰季，很多人问我，你们公司还需要人么，你们用的技术栈是哪些，有哪些是你们比较关注技术重点？ 没错，作为负责技术面试的我，面对数十甚至上百封简历，肯定要做一轮筛选。究竟哪些技术点或方向在我筛选或面试时，留下深刻印象呢？ 我觉得优秀的，有潜质的程序员可以从下面几点体现。 1、性能调优几乎每个JAVA后端开发程序员，都会在面试时碰到诸如如何性能调优的问题，如何回答好这个问题，不仅仅是对JVM，内存模型等的理解，更重要的是碰到性能问题时，排查问题的方法论和思路。 典型的一个场景是：在压力测试时，发现FullGC频率很高，如何解决？ 此类问题一般从以下几点入手： 1. 观察GC日志，判断是否有内存泄漏，或者存在的内部不合理点。此处要求能熟悉各种linux命令，可以快速查看和定位。 2. 调整JVM 参数，如新生代，年老代大小，S0和S1大小比例，不同垃圾回收器的采用。并结合业务特点做进一步分析。这里不但要求扎实的JVM内存模型和理论，还要求对JVM的各种参数设置耳熟能详，并能实践操作。 3. Dump内存，做进一步的对象分析。 4. 压测脚本的编写，性能问题解决前可以发现问题，并能在问题解决后真实的验证。 此类优化不仅仅是照本宣科式的回答，面试官一定会喜欢问实际中操作的场景，和解决问题的思路。因为性能问题的原因是多种多样的，但是解决问题的思路和方法论是可以明确的。 2、网络框架的理解和使用大家一定都听过或使用过网络异步框架Netty，甚至使用netty框架开发过一些应用和功能。 但是大部分人仅限于对Netty的使用，甚至仅仅知道其他一些开源框架使用了Netty，但是在资深面试官眼里，Netty有很多值得学习和借鉴的地方，使用过Netty并且能对Netty的一些原理有一定的了解且能学以致用的Java程序员格外受欢迎。 一般来说，要求较高的面试官和技术经理喜欢从Netty的设计模式角度深入的考察技术人员对网络开发和相关理论的理解如： 1. Netty的Reactor模型如何设计，反应在应用里的模型是如何。 2. Netty的pipeline 责任链如何使用，业务场景中是否有类似的实践经验。 3. 项目中有无使用Netty，并利用Netty进行私有化协议设计。 同学们不仅要求能使用Netty，通过阅读其源码，理解其中的精髓，并能应用在自己的实践项目中，这个才是亮点和加分项。 3、开源服务化RPC框架的理解和使用互联网经过十几年的发展，早已经从单体应用发展为服务化应用，大厂里系统和服务尤其如此。 拿经典的dubbo 服务化框架举例，当前市面上有很多dubbo相关的文章和介绍，这里撇开不谈，从技术负责人的角度来，我会更关心下面有关几个dubbo相关的问题。 1. 技术选型：为什么选择dubbo，而不选择其他如spring cloud框架?我认为可以从如下考虑： A）业务的特点以及可预见的后续的发展。作为高级技术人员，必须需要对业务的的发展做预计和规划。 B）可用性要求，是否需要达到4个99（99.99%），需要支撑的峰值QPS，是否有业务的集中爆发点，如电商大促 C）团队的成熟度，一个成熟的团队可以很好的hold住复杂的开源框架，甚至做定制化开发。 D）技术选型这个话题虽然宽泛，但是最能体现更能体现技术人员的综合能力，尤其是结合业务特点后对技术深度和广度的驾驭能力。 2. Dubbo底层走的是什么协议，如何处理异步转同步？大部分的Java开发都会直接使用dubbo，而不会去关心其底层一些技术细节，但是一些细节，如dubbo如何对对象进行序列化，用了哪些序列化方式，这些在分布式项目中对提高应用的处理速度，减少网络开销，都很大帮助。 同时RPC框架里如何将异步转同步，也是需要技术人员非常关注的一面，里面相关的设计模式，多线程程高并发场景都是很多业务系统里真实需要和借鉴的。 3. Dubbo在高并发高可用等实践场景需要认真考虑的其他问题使用了dubbo后，很多人觉得万事大吉，其实并不是这样，下面几点还需要关心，并且这些就是体现你价值的地方 A) dubbo依赖了zooKeeper，但是万一ZooKeeper宕机了怎么办 B) 如果ZooKeeper假死，客户端对服务端的调用是否会全部下线，如果是该如何避免 C) 如何监控duubo的调用，并做到优雅的客户端无感发布 4、自身多年的面试体会1.项目中尽量多思考，迎难而上，如碰到复杂的性能，内存泄露等问题的问题，往往是提升自己的机会，千万要仔细研究解决，可以参考其他解决类似问题的文章和实践经验，对技术深度的提升是很大的，关键时候可以让你的面试官突然觉得面耳目一新。 2.重视解决问题的思路和方法，很多时候技术人员可以快速设计一个系统或解决一个问题，但是在资深工程师或面试官眼里可能并不是最优方案。如何解决？ 很多技术人员的项目和技术相对单一，长久以往，容易造成技术思路和视野的狭窄，接触不到行业最新思路和动态或者当前疑难问题的最佳解决方案。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"软件工程师生存指南：面试准备、工作经验和实用工具","slug":"软件工程师生存指南：面试准备、工作经验和实用工具","date":"2019-04-23T05:41:34.000Z","updated":"2019-04-23T06:03:15.618Z","comments":true,"path":"2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/","link":"","permalink":"http://chenguoji.com/2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/","excerpt":"","text":"编者按：软件工程师是令人羡慕的职业。但是如何才能拿到这份工作？又如何才能做好这份工作呢？拥有相关经验的 Valeri Alexiev 提供了相关建议和工具。其中包括了如何准备面试、如何以软件工程师的身份工作以及如何持续改进方面的经验之谈。 我刚开始工作的头几年是紧张学习的时间。 我得面对现实，成为软件工程师需要有很多技能，这些我之前都不知道。回顾过去，显然学会那些东西是很好的。 所以我就根据自己及其他人的经验写了这篇指南来帮助入行的新人。 本文将覆盖以下内容： 如何尽力做好面试 如何在软件工程师的角色中生存（及发展） 考虑持续改进时可以参考的资源 面试当你开始软件工程职业生涯时，你得面对一个无可争议的事实。面试很恶心。 参与其中的每个人都觉得很恶心。既被人面试过又面试过别人的我可以证明，面试是一项极其耗时、极其有压力的工作，并且面试其实并不是将来工作表现一个的好的指示器。但不管怎样，这都是一个必要之恶，你和你的简历最好还是做好准备为妥。 做好战斗准备如果你考虑做软件过程，确保了解一些最常见的编程面试问题，比如“FizzBuzz”： 写一个程序打印从 1 到 100 的数字。但是如果数字是 3 的倍数的话则打印“Fizz”，如果数字是 5 的倍数则打印“Buzz”。如果同时是 3 和 5 的倍数则打印“FizzBuzz”。 来自 Coding Horror 听起来很简单，是吧？ 好吧，但其实绝大部分面试者都没能通过这一简单的测试，且不说更复杂的变种了。 我个人曾经见过很多角逐资深岗位的候选人在拥有完全互联网访问的情况下没能通过这一测试。所以如果你的简历上面列有编程语言的话，确保你知道如何用它来编写实现 FizzBuzz 程序。否则的话，你只不过是在浪费所有人的时间，包括你自己的。 当然，为了在面试过后生存，你需要知道的不仅仅只有 FizzBuzz。你还需要确保你知道： 基础的数据结构和算法：比如链表、数组、树以及排序。要知道所选择语言的常见解决办法，比如字符串是否恒定，内存是如何管理的。类似类与对象，以及继承等面向对象编程的概念。在职业生涯开始时，你需要就这些问题做好准备，因为你并没有经历去证明自己能做好这份工作。在准备面试的时候有两个资源我会经常推荐： 《Cracking the Coding Interview（破解面试代码）》，这是一本非常好的书，里面介绍了很多的编码问题和解决方案，同时还总结了解决这些问题需要了解的东西。 CodeWars ，这个网站收集了大量的编程问题，你可以运用各种语言在浏览器里面去解决这些问题。最有用的部分是看看别的用户是如何解决同样问题的。这样你就可以看到解决相同问题的不同办法，并且学到你所选语言的新工具。 赋予自身额外优势为了让自己取得那点额外优势，有几件事情你可以去做。 首先，学会如何沟通你的经验。你应该进行一次电梯演讲来将你的简历总结成连贯的、打动人的个人介绍。 此外，要了解自己的简历！听起来很蠢是吧，但我就见过很多面试者连解释清楚自己简历上的特定事项都很困难。你应该能够回答任何有关你列上简历的经历方面的问题，并且解释清楚这一经历如何让你成为本工作更好的候选人。 接着，要在 GitHub（或者其他的公共代码库）上面有一些编码的例子。 眼见为实，面试官能够看到你的代码将创造奇迹。此外，这还证明了你对版本控制系统有了解。 你的代码例子不需要太复杂，但是一定要整洁，能够显示出好的编码实践。这是你展示自己在没有编码面试所带来的时间压力情况下代码写得如何的机会。 一旦你做完了上面的事情后，就得考虑参与一个开源项目了。参加开源项目能表明你能够在已有代码库基础上工作并且可以与其他程序员一些协作。 这是你在无需实际进入一个行业环境的情况下最接近在行业环境下编程的方式了。这也是目前为止最难最耗时的一项任务，所以等到你把前面我提到的比较容易取得的果实都摘完之后再干这件事。 面试你的面试官在找工作的匆忙与压力之下，很多候选人都忘了面试是一个双向的过程。在公司努力寻找这份工作的合适人选时，你也应该设法弄清楚这家公司适不适合你。 确保你也要提出以下一些问题，哪怕对方是以电子邮件的形式回复你。要意识到公司经常把不遵循最佳实践说成是一项技能，所以要体会其言外之意。 以下是一些你可以去提问的例子： “对我来说典型的工作日会是什么样的？”知道特定岗位预期的样子很重要，因为软件工程工作差别相当大。比方说你的工作既可能是维护服务器，也可能是直接跟客户沟通。 危险信号：“我不大肯定。” → 意味着面试你的那个人不在你的团队，或者他们对为什么要招你并没有明确的想法。 “你们是如何测试软件的？”理想情况下，验证代码质量应该是单元测试、人工测试以及自动化测试的结合。 危险信号：“我们都写不出 bug，哈哈。” → 那些人正是会写出 bug 的人。 “你们使用什么样的版本控制系统？”版本控制系统对于协作极其有用，在职业环境下没有理由不使用。 危险信号 #1：“额，版本控制系统？” → 快跑，跑得越远越好。 永远记得使用版本控制。 危险信号 #2：“&lt;插入不知名的或者定制的 VCS&gt;” → 这表明他们很有可能没有跟上时代并且很久没有升级自己的基础设施了。 “你们进行同行评审吗？”同行评审，或者让别人看看你的代码再把它放进代码库，这是识别愚蠢错误的极好办法，同时也是开始你的职业生涯时一个关键的培训机会。 危险信号：“我们相互信任！”→很有可能那些资深开发者对自己的代码非常警惕不想给人看也不擅长接受反馈。 “你们的继续教育计划是什么样的？”作为一名软件工程师意味着当新技术出现、成熟并以令人眼花缭乱的速度走向过时的时候要不断学习。因此，很多公司都有培训预算用来买大学和在线课程、会议或者内部交流。 危险信号：“你是说在闲暇时间读读网上的东西？” →这家公司要么资金紧张，要么把开发者视为可替代的，而不是长期投资。 “你们采用的软件开发流程是什么？”无论实际的细节是什么，流程对于软件工程都至关重要。至于哪些东西对于优化流程做出了贡献可能大家会有不同的看法，但仅就项目的工作方式达成一致就能将混乱最小化并且确保每个人都能达成共识。 危险信号：“我们的流程受到了自由风格的爵士的影响。” → 很有可能整个部门都处在救火模式，总是不断地从紧急跳到另一个紧急状态而缺乏任何明确的目标。 “你们是如何处理技术债务的？”技术债务是过时技术以及代码库中临时应急的解决方案的累积。处理好技术债务对于代码的长期健康很重要，这件事情应该持续地做。 危险信号：“我们只关注新功能。” → 他们的代码库一团糟或者很快就会一团糟。 “你们的公司文化是什么样的？”公司文化也许是个非常含糊的概念，但即便像开放办公室还是小隔间这样的小事情都会显著改变你与同事的日常互动。这方面没有普遍性的危险信号，但是要确保他们的答案是你可以按照每周 40+ 小时的节奏持续相处数年的东西。 以软件工程师的身份工作在这个阶段，如果你面试过程中表现不错并且喜欢面试官回答你问题的方式，你被录用的可能性就很高了。 祝贺，你正式成为一名工程师了！ 那现在又该如何呢？好吧，现在是时候重新学习大量编码和工作方面的东西了。既然我们是程序员，我们就从讨论代码开始。 好的行业代码好的行业代码有以下属性，依序是： 1.可读性，因为代码用来读和维护的频次要高于写。代码的意图必须清晰，让其他开发者在多年后依然理解。 2.防御性，就是要遵循防御性编码的最佳实践。防御性编码本身就是一个课题，不过其要义是：你必须确保自己所写的类和方法的不恰当使用不会导致你的代码搞得软件都崩溃。 3.优化，位列清单的最后未知，因为大多数时候你并不需要真正去担心这个。这并不意味着你应该编写糟糕代码，在存在线性解决方案的情况下以O(n³)的效率去做某个东西。但开发者通常渴望尝试并且会在不需要的情况下过度优化，却牺牲了代码的可读性和防御性。你永远都应该能够证明牺牲了这些属性的特定优化是值得的。 现在你了解了如何去编写良好的行业代码了。 编码的工作你不会干太多的说出来也许有点令人吃惊，但是大多数时候你都不用写新代码，而是相反，要做： 调试 读已有代码 开会或者写电子邮件 研究该怎么做以便不用写代码 因此编码以外的技能对你的职业一样关键。 调试和阅读代码调试远不仅仅是用打印语句。一切使用广泛的语言和技术栈都有各种强大的工具。学会使用它们，因为这些会让调试轻而易举，节省你无数的时间。 理解代码库。大多数技术栈都有某种代码图谱生成工具来帮助你理解代码库的结构。企业级的 IDE 通常都内置了那种功能。你还可以利用 ReSharper、grep 或者 Sourcegraph 之类的工具来探索代码。 理解产品。你会对居然有这么多开发者在试图“修复”软件前不知道软件应该是怎么工作的感到惊讶。先看看文档再说吧。 组织你的思路既然你的大量时间都是用在沟通、研究和多任务上，你需要一些工具来帮助一切井然有序。 TODO 清单/任务工具：你的公司应该已经有了某种任务管理软件了，但你自己也有类似的个人系统是有帮助的。使用便利贴或者像 Trello 或者 Todoist 之类的软件。 笔记：开会一定要记笔记，要致力于改进现有文档并且建立个人的知识库。使用 Evernote、OneNote 或者笔记本。使用这些工具似乎有用力过度之嫌，但日后在回顾这一耗掉了你 3 天时间才想清楚的晦涩的开发过程时你会感谢自己的。不做丰富笔记的好的软件开发者我一个都没见过。 图表/可视化：人是视觉动物，创建流程图和架构可帮助你和其他人理解复杂的话题。在跟非技术人员沟通时图解尤其有用。可使用 Lucidchart、 Visio 或者白板。 知道何时使用库简短回答：随时都要。 详细回答：99% 的时间内你都不应该重新发明轮子。在大多数的软件工程岗位，实现特定类型的东西都属于纯粹浪费时间。这并不意味着你不应该知道所使用的算法和数据结构是怎么工作的，因为这可以帮助你决定用什么以及什么时候用。 为了成为一名高效的软件工程师，你需要理解自己可以任意支配使用的那些库。大多数流行语言的标准库都是极其有用的，其规模比你想象的要大。此外，代码库也许也会利用了额外的特殊库。阅读其文档，知道什么使用去使用它们。 你还应该不要害怕去建议额外的库，如果它们将节省时间的话。然而，你需要确保自己选择了一个好的库供行业使用。好的库的标准是： 开源，这样你就可以验证自身代码的质量，并有可能修补对应用非常关键的 bug。 按照 MIT 和 BSD 等方式进行的授权，这样你的公司使用起来就不会遇到任何问题。要小心 GPL，因为它会让你不小心就将整个代码库都开源出去。 成熟，比方说出来已经有一段时间了，并且功能集非常丰富。 维护性强，新版本推出很密集。 别的公司或者项目也使用，这个可以充当品质认证确保有行业支持，能持续维护下去。 持续改进为了替自己创建新的职业机会，除了学习会让你更擅长日常工作的技能以外，你还需要持续改进自身技能并且学习新技能。 其实学习的机会有很多，而且其中很多都是你可以负担得起的： 在线课程：向领域内最好的教授学习的机会，而且方式灵活，不容错过。现有技能的补充性教程可以去可以看看 Coursera、 Udacity 以及 edX 等。 在线硕士学位：在线硕士学位是最近在顶级大学流行起来的一个趋势，这种方式可以灵活地继续你的正规教育。相比之下，这种继续教育方式费用没那么昂贵，修完整个学位大多数在 1 万美元左右。乔治亚理工大学、UT 以及加州大学圣地亚哥分校等大学均提供此类学位。我个人推荐乔治亚理工大学的在线硕士虚伪，我去年刚从这里毕业。 博客：博客是开发者社区的重要组成部分。诸如 Coding Horror、Joel on Software 等博客或者甚至更加诙谐的网站如 The Daily WTF 等都可以为你提供信息，了解到作为软件工程师该干什么不该干什么。浏览 Medium、r/programming, HackerNews 等新闻流也能让你找到好博客和好文章。 会议：最后但并非最不重要的一个，会议时令人赞叹的学习机会，你绝对应该利用公司的培训预算去参加会议。以下是不完全的好会议清单：GOTO（通用）， Strange Loop（通用）， PyCon （Pytho），CPPCon （C++），DEF CON （安全），Fluent （Web 开发）。上述所有的会议在 YouTube 上都有视频，所以你哪怕不出席也能学到东西！ 希望这篇文章能够用相关知识把你武装起来，让你了解到作为软件工程师的职业生涯伊始应该期待什么，并且提供合适的工具给你在开启这段令人兴奋的旅程中助你一臂之力！ 英文：Valeri Alexiev 译文：36kr36kr.com/p/5160742.html","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Tomcat相关面试题","slug":"Tomcat相关面试题","date":"2019-04-22T05:41:34.000Z","updated":"2019-04-22T08:34:44.922Z","comments":true,"path":"2019/04/22/tomcat-xiang-guan-mian-shi-ti/","link":"","permalink":"http://chenguoji.com/2019/04/22/tomcat-xiang-guan-mian-shi-ti/","excerpt":"","text":"Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，这次整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以再往Tomcat处理请求的这个过程去说的！掌握注Tomcat这些技能了，面试官一定会佩服你的！ 学了本节之后你应该明白的是： Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点； Tomcat执行的整体架构，请求是如何被一步步处理的； Engine、Host、Context、Wrapper相关的概念关系； Container是如何处理请求的； Tomcat用到的相关设计模式； 一、Tomcat顶层架构俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！ 先上一张Tomcat的顶层结构图（图A），如下： Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。 Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下： 1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; 2、Container用于封装和管理Servlet，以及具体处理Request请求； 一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）： 多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。 另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0） 详细的配置文件文件内容可以到Tomcat官网查看： http://tomcat.apache.org/tomcat-8.0-doc/index.html 上边的配置文件，还可以通过下边的一张结构图更清楚的理解： Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。 二、Tomcat顶层架构小结：（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；（2） Server掌管着整个Tomcat的生死大权；（4）Service 是对外提供服务的；（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；（6）Container用于封装和管理Servlet，以及具体处理request请求； 知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。 三、Connector和Container的微妙关系由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！ Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！ Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！ 四、Connector架构分析Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。 因此，我们可以把Connector分为四个方面进行理解： （1）Connector如何接受请求的？ （2）如何将请求封装成Request和Response的？ （3）封装完之后的Request和Response如何交给Container进行处理的？ （4）Container处理完之后如何交给Connector并返回给客户端的？ 首先看一下Connector的结构图（图B），如下所示： Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。 其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。 （1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。 （2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。 （3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。 至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？ 五、Container架构分析Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）： 4个子容器的作用分别是： （1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine； （2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点； （3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件； （4）Wrapper：每一Wrapper封装着一个Servlet； 下面找一个Tomcat的文件目录对照一下，如下图所示： Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。 我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。 看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！ 六、Container如何处理请求的Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意） Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。 https://img-blog.csdn.net/20180108212100441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点： （1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的； （2）在上层容器的管道的BaseValve中会调用下层容器的管道。 我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。 Pipeline的处理流程图如下（图D）： （1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）； （2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。 （3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！ （4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。 七、总结至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！ 原文：https://blog.csdn.net/u010870518/article/details/79006434","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://chenguoji.com/tags/Tomcat/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"数据库-操作符记录","slug":"SQL UNION 操作符","date":"2019-04-19T05:41:34.000Z","updated":"2019-04-22T08:26:33.569Z","comments":true,"path":"2019/04/19/sql-union-cao-zuo-fu/","link":"","permalink":"http://chenguoji.com/2019/04/19/sql-union-cao-zuo-fu/","excerpt":"","text":"SQL UNION 操作符UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。SQL UNION ALL 语法SELECT column_name(s) FROM table_name1UNION ALLSELECT column_name(s) FROM table_name2 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SQL JOIN 操作符下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。 JOIN: 如果表中有至少一个匹配，则返回行LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行FULL JOIN: 只要其中一个表中存在匹配，就返回行 注释：INNER JOIN 与 JOIN 是相同的。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"让你如何在一分钟内搞定面试官？","slug":"让你如何在一分钟内搞定面试官？","date":"2019-04-18T06:14:59.000Z","updated":"2019-04-18T07:13:10.379Z","comments":true,"path":"2019/04/18/rang-ni-ru-he-zai-yi-fen-zhong-nei-gao-ding-mian-shi-guan/","link":"","permalink":"http://chenguoji.com/2019/04/18/rang-ni-ru-he-zai-yi-fen-zhong-nei-gao-ding-mian-shi-guan/","excerpt":"","text":"“请做个自我介绍。”有的人，可以口若悬河、妙语连珠讲3分钟，有的人，可能磕磕巴巴，讲了30秒，前者一定能胜过后者，然则未必， 今天就来聊一聊，面试的经典问题——自我介绍。 为什么要做自我介绍通常说来，大大小小的面试，尤其是针对基础岗位，都会被问到这个问题，甚至有些面试技术还有些生硬的面试官， 屁股还没坐稳，就把这个问题抛给应聘人员了，那么作为求职者，要首先明白，面试官为什么要让你做自我介绍？ 简单说来，包括以下几个原因： 1、面试官的技巧还不是很娴熟，使用面试的惯常流程； 2、通过自我介绍，判断求职者的基本素质（比如口头语言表达能力、逻辑能力等）； 3、通过自我介绍，找到简历上缺失的或者不一致的细节，后续追问； 4、通过自我介绍，建立对应聘者的立体、整体的初步印象和概念。 简言之，自我介绍的意义和价值就在于，通过简短的口头语言陈述，让面试官初步了解你是一个什么样的面试候选人。 如何做好自我介绍1、先说核心内容：前面已经介绍了这一问题的考察点，那么接下来就对症下药，做一个高质量的自我介绍，给整场面试开一个好头。自我介绍过程就是人岗匹配度的核查与确认，这样描述有点抽象，举个例子来说： 应聘职位：招聘助理 应聘人员：有一定HR初级经验 假设自我介绍-1：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，招聘任务重的时候，也协助做一些招聘工作，比如面试的约谈，面试过程的记录以及相关数据的汇总等等”； 假设自我介绍-2：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，没怎么做过招聘，招聘任务重的时候，会给招聘小组的同事们帮帮忙……” 对比上面的两个自我介绍，也就不难看出质量的优劣，在做介绍的过程中，首要原则，多介绍以往工作经验中跟当前应聘岗位有交集的地方，而且尽可能描述到细节，切勿顾左右而言他。 有的人可能会说了，我正在寻求转行，没有相关经验怎么办？ 只要记住以下几点： 如果这家公司在看过你简历的情况下依然通知你面试，那么也就代表以往的工作经验并非是该岗位的必要要素。 此处还要多说一句，如果你是打算转行，收到心仪的职位时，先不要过于激动，而是要在面试电话中先冷静地跟通知你的人确认一下你要面试的职位，不排除当下有些公司会挂着羊头卖狗肉，打着文职的旗号招销售，专门诱骗小姑娘们，所以此类公司，要更加慎重，可以用该公司的名称到网络上去搜索一下他们家的招聘信息，如果铺天盖地都是销售岗位的招聘，那么，可能就只是个幌子而已了。其实非专业技术型的岗位，尤其是偏基础性质的职位，企业不会特别看重以往经验的对口与否，衡量工作的胜任能力，一方面是技能，一方面是态度， 技能培养如果可以在企业内部培训的基础上快速实现，往往更加看重你的个人态度层面，所以不必过分纠结经验问题。再举个例子来说： 应聘职位：销售支持 应聘人员：有一定的话务客服经验 自我介绍：“……在之前的工作中，我从事的是话务客服的工作，虽然跟贵公司招聘的销售支持职务有差别，但我详细阅读了贵公司的岗位介绍，销售支持的工作需要良好的服务意识，细心的工作态度以及对产品知识的了解，从事过客服工作，我的服务意识以及细心程度都没有问题，专业知识相信经过公司的培训之后，自己也能熟练掌握……” 也就是说，如果你是转行，应聘不需要专业的技能和知识的岗位，尽可能寻找以往工作中的软性能力与当前应聘职位之间的关系，多表现自己良好的职业素质层面的东西即可。 2、再说说辅助内容：上述内容针对的是自我介绍的核心内容，但自我介绍的内容不仅仅是这些，还需要有一些其他的内容作为辅助，才显得更加自然和饱满，简言之，一篇完成的自我介绍要涵盖以下内容： 自我基本情况； 以往工作经验与应聘岗位链接； 个人的职业发展设想； 对应聘企业的个人认同感； 至于个人的兴趣爱好之类的，可以简单带过即可。 上述的五个简单部分，2、3、4为主，前后两部分为辅助，再加上一些简单的寒暄的话语即可。 3、还有几个误区，需要大家绕开：自我介绍不是检查背诵能力，切勿千篇一律。有的人准备一套说辞，背的滚瓜烂熟，见谁都是这一套，这样是不稳妥的，要把自己的情况跟企业的职位做链接，这样方才更加吸引面试官； 做自我介绍的时候卡壳了，怎么办？不要紧张的手足无措，可以坦然地笑笑，跟面试官说，不好意思，我有点紧张，然后继续就好了； 做自我介绍的时候，两眼直勾勾看桌子或者天花板，没有跟面试官的眼神接触。如果有好几个面试官，不要盯着一个人，都扫几眼； 做自我介绍的时候，不要做小动作，落落大方，不要抖腿，掰手指头等等； 注意跟简历内容相一致，不要出现信息不对称。简单粗暴的给个模板 不给模板的干货都是伪干货，上面七七八八说了这么多，给个范本仅供参考： “面试官您好，非常荣幸参与贵公司**职位的应聘，下面我简单介绍一下我的个人情况，基本信息之类的简历上都有，就不再重复。 首先介绍一下之前的工作经验……（挑一些跟应聘岗位有链接的内容说，如果有工作荣誉，前往不要漏掉）…… 之所以离开上一家公司是出于……考虑（离职理由要争当，尽可能从职业发展的角度出发）…… 通过渠道关注到贵公司岗位的招聘信息，该职位跟我未来的职业发展相对契合，而且贵公司的业务（或者企业实力、行业口碑、企业文化等）对我都非常有吸引力，非常渴望能够进入贵公司发展…… 我个人的基本情况是（受教育情况、婚育、住所、家庭简单情况），闲暇之余，我一般会做些**事情（有意义的）…… 或许在所有的求职者当中，我不是最优秀的，但如果贵公司能够给我这个工作机会，我有信心，也有决心做好这份工作，以上是我的个人基本情况，希望今天自己面试有好的表现，未来有幸与诸位面试官共事，也预祝各位度过美好的一天。” 最后再做个总结：自我介绍是整个面试的开始，首因效应之下，第一印象还是很重要滴，在做介绍的过程中， 尽可能多去说有些跟岗位工作有关的过往经验，不要生搬硬套，注意灵活应对， 可以事先有针对性做一个草稿，但针对框架内容要了熟于心，针对企业岗位有的放矢，落落大方，注意条理。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java面试","slug":"java面试","permalink":"http://chenguoji.com/tags/java面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Java开发者必须要具备的专业技能","slug":"Java开发者必须要具备的专业技能","date":"2019-04-17T08:09:23.000Z","updated":"2019-04-17T08:30:04.539Z","comments":true,"path":"2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/","link":"","permalink":"http://chenguoji.com/2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/","excerpt":"","text":"想要成为合格的Java程序员或工程师到底需要具备哪些专业技能，面试者在面试之前到底需要准备哪些东西呢？ 本文陈列的这些内容既可以作为个人简历中的内容，也可以作为面试的时候跟面试官聊的东西，你可以把这些内容写到你的简历中，当然更需要的是你在面试的时候向面试官展示这些专业技能。 相信此文对正在寻觅Java程序员（Java工程师）职位的freshman以及希望成为中高级Java开发者的junior都会有所帮助。 专业技能 1.熟练的使用Java语言进行面向对象程序设计，有良好的编程习惯，熟悉常用的Java API，包括集合框架、多线程（并发编程）、I/O（NIO）、Socket、JDBC、XML、反射等。 2.熟悉基于JSP和Servlet的Java Web开发，对Servlet和JSP的工作原理和生命周期有深入了解，熟练的使用JSTL和EL编写无脚本动态页面，有使用监听器、过滤器等Web组件以及MVC架构模式进行Java Web项目开发的经验。 3.对Spring的IoC容器和AOP原理有深入了解，熟练的运用Spring框架管理各种Web组件及其依赖关系，熟练的使用Spring进行事务、日志、安全性等的管理，有使用Spring MVC作为表示层技术以及使用Spring提供的持久化支持进行Web项目开发的经验，熟悉Spring对其他框架的整合。 4.熟练的使用Hibernate、MyBatis等ORM框架，熟悉Hibernate和MyBatis的核心API，对Hibernate的关联映射、继承映射、组件映射、缓存机制、事务管理以及性能调优等有深入的理解。 5.熟练的使用HTML、CSS和JavaScript进行Web前端开发，熟悉jQuery和Bootstrap，对Ajax技术在Web项目中的应用有深入理解，有使用前端MVC框架（AngularJS）和JavaScript模板引擎（HandleBars）进行项目开发的经验。 6.熟悉常用的关系型数据库产品（MySQL、Oracle），熟练的使用SQL和PL/SQL进行数据库编程。 7.熟悉面向对象的设计原则，对GoF设计模式和企业应用架构模式有深入的了解和实际开发的相关经验，熟练的使用UML进行面向对象的分析和设计，有TDD（测试驱动开发）和DDD（领域驱动设计）的经验。 8.熟悉Apache、NginX、Tomcat、WildFly、Weblogic等Web服务器和应用服务器的使用，熟悉多种服务器整合、集群和负载均衡的配置。 9熟练的使用产品原型工具Axure，熟练的使用设计建模工具PowerDesigner和Enterprise Architect，熟练的使用Java开发环境Eclipse和IntelliJ，熟练的使用前端开发环境WebStorm，熟练的使用软件版本控制工具SVN和Git，熟练的使用项目构建和管理工具Maven和Gradle。 说明：上面罗列的这些东西并不是每一项你都要烂熟于心，根据企业招聘的具体要求可以做相应的有针对性的准备。 我个人觉得前6项应该是最低要求，是作为一个Java开发者必须要具备的专业技能。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"基于springboot开发的java web网页版电子商城网站","slug":"基于springboot开发的java web网页版电子商城网站","date":"2019-04-16T08:01:31.000Z","updated":"2019-04-16T11:26:54.674Z","comments":true,"path":"2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/","link":"","permalink":"http://chenguoji.com/2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/","excerpt":"","text":"项目描述 基于spring boot与mybatis整合的java web网页版电子商城网站，采用maven构建，数据库用的是mysql 运行环境 jdk8+tomcat7+mysql+eclipse+maven 项目技术(必填) 后台使用：springboot+mybatis 前台使用：html+css+jquery+freemarker+layui+ 运行安装包文件 百度网盘：https://pan.baidu.com/s/1ZHGSul-JysWJ0xh7zeDzIg 密码: a354 项目截图(必填) 运行截图(必填) 1、登录页面 2、项目首页 3、商品详情 4、后台管理模块 5、商品管理模块 注意事项 系统是由maven构建的，必须要把所有jar包下载才能成功运行 如需项目代码请联系博主或者加Q群","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/tags/毕业设计/"}],"keywords":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}]},{"title":"Java中的锁[原理、锁优化、CAS、AQS]","slug":"Java中的锁-原理、锁优化、CAS、AQS","date":"2019-04-10T01:38:52.000Z","updated":"2019-04-10T07:22:13.208Z","comments":true,"path":"2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/","link":"","permalink":"http://chenguoji.com/2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/","excerpt":"","text":"1、为什么要用锁？锁-是为了解决并发操作引起的脏读、数据不一致的问题。 2、锁实现的基本原理2.1、volatileJava编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 Java语言提供了volatile，在某些情况下比锁要更加方便。 volatile在多处理器开发中保证了共享变量的“ 可见性”。 可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。 2.2、synchronizedsynchronized通过锁机制实现同步。 先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 2.2.1 synchronized实现原理synchronized是基于Monitor来实现同步的。 Monitor从两个方面来支持线程之间的同步： 互斥执行 协作 1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。3、Class和Object都关联了一个Monitor。 Monitor 的工作机理 .线程进入同步方法中。.为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）.拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。.其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。.同步方法执行完毕了，线程退出临界区，并释放监视锁。 参考文档：https://www.ibm.com/developerworks/cn/java/j-lo-synchronized 2.2.2 synchronized具体实现1、同步代码块采用monitorenter、monitorexit指令显式的实现。 2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。 通过实例来看看具体实现： public class SynchronizedTest { public synchronized void method1(){ System.out.println(&quot;Hello World!&quot;); } public void method2(){ synchronized (this){ System.out.println(&quot;Hello World!&quot;); } } } javap编译后的字节码如下： monitorenter 每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下： .如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。 .如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。 .如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。 monitorexit 只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1， 当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。 2.2.3 锁存放的位置锁标记存放在Java对象头的Mark Word中。Java对象头长度32位JVM Mark Word 结构32位JVM Mark Word 状态变化64位JVM Mark Word 结构 2.2.4 synchronized的锁优化JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 偏向锁： 无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。 轻量级锁： 轻量级锁所适应的场景是线程交替执行同步块的情况。 锁粗化（Lock Coarsening）： 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除（Lock Elimination）： 锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。 适应性自旋（Adaptive Spinning）： 自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 2.2.5 锁的优缺点对比 2.3、CASCAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。 1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。 2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。优点： 竞争不大的时候系统开销小。 缺点： 循环时间长开销大。 ABA问题。 只能保证一个共享变量的原子操作。 3、Java中的锁实现3.1、队列同步器（AQS）队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。 3.1.1、它使用了一个int成员变量表示同步状态。 3.1.2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。 未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示： 首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示： 3.1.3、独占式/共享式锁获取独占式：有且只有一个线程能获取到锁，如：ReentrantLock。&lt;/pre&gt; 共享式：可以多个线程同时获取到锁，如：CountDownLatch 独占式 每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。 独占式锁获取流程： 共享式： 共享式与独占式的区别： 共享锁获取流程： 4、锁的使用用例4.1、ConcurrentHashMap的实现原理及使用 ConcurrentHashMap类图 ConcurrentHashMap数据结构 结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 来源：https://www.jianshu.com/p/e674ee68fd3f","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"高级程序员VS普通程序员，差距到底在哪？","slug":"高级程序员VS普通程序员，差距到底在哪？","date":"2019-04-03T09:02:45.000Z","updated":"2019-04-03T09:07:23.040Z","comments":true,"path":"2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/","link":"","permalink":"http://chenguoji.com/2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/","excerpt":"","text":"踏上了编程之路，也就意味着你选择了一种终身学习的生活方式。每一个程序员都要练就十八般武艺，而掌握数据结构与算法就像修炼了九阳神功。换句话说，掌握了数据结构与算法，你的内功修炼速度就会有质的飞跃。 “初级程序员才比招式，高级程序员只看内功”，数据结构与算法，对于一个程序员来说，至关重要。 无论你是从事业务开发，想要评估代码性能和资源消耗，还是从事架构设计，想要优化设计模式；或者想要快速玩转热门技术，都要先搞定数据结构与算法。因为，任凭新技术如何变化，只要掌握了这些计算机科学的核心“招式”，你就可以见招拆招，始终立于“不败之地”。 那怎样才能真正掌握它呢？是把常用的数据结构与算法背的滚瓜烂熟吗？即便如此，面对现实世界的千变万化，你也不太可能照搬某个算法解决即将遇到的下一个问题。因此，就像学习设计模式、架构模式一样，学习数据结构与算法的关键，在于掌握其中的思想和精髓，学会解决实际问题的方法。 来源：https://mp.weixin.qq.com/s/vL5gEfOfqE3airySe1FlBQ","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"11个简单的Java性能调优技巧","slug":"11个简单的Java性能调优技巧","date":"2019-03-28T02:35:17.000Z","updated":"2019-04-17T08:21:01.975Z","comments":true,"path":"2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/","link":"","permalink":"http://chenguoji.com/2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/","excerpt":"","text":"大多数开发人员理所当然地以为性能优化很复杂，需要大量的经验和知识。好吧，不能说这是完全错误的。优化应用程序以获得最佳性能不是一件容易的事情。但是，这并不意味着如果你不具备这些知识，就不能做任何事情。 这里有11个易于遵循的建议和最佳实践可以帮助你创建一个性能良好的应用程序。 大部分建议是针对Java的。但也有若干建议是与语言无关的，可以应用于所有应用程序和编程语言。在讨论专门针对Java的性能调优技巧之前，让我们先来看看通用技巧。 1.在你知道必要之前不要优化这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。 在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。 那么，你如何证明你需要优化一些东西呢？ 首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。 2.使用分析器查找真正的瓶颈在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？ 你可以用两种方法来解决问题： 查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。 或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。 希望不需要我解释为什么应该始终遵循第二种方法的原因。 很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。老实说，我第一次的猜测不止一次地导致我走错了方向。 3.为整个应用程序创建性能测试套件这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。 这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。 4.首先处理最大的瓶颈在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。Java 程序员必须清楚的 7 个性能指标，这个你也必须会。 速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。 但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。 5.使用StringBuilder以编程方式连接String有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。String 真的是不可变的吗？ 那么，你应该选择哪种方法？ 答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。StringBuffer 和 StringBuilder 的 3 个区别，这个你必须清楚。 你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。 下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。 StringBuilder sb = new StringBuilder(“This is a test”); for (int i=0; i&lt;10; i++) { sb.append(i); sb.append(” “); } log.info(sb.toString()); 正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。 如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。这进一步提高了效率，因为它不需要动态扩展其容量。 6.使用+连接一个语句中的String当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。 在这些情况下，你应该遵循技巧5并使用StringBuilder。 但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。 Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ” + “FROM Author a ” + “WHERE a.id = :id”); 在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。 7.尽可能使用基元避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。 8.试着避免BigInteger和BigDecimal既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。 BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。金融系统中正确的金额计算及存储方式，这个你了解下。 9.首先检查当前日志级别 这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。 这里有两个反面例子。 // don’t do this log.debug(“User [” + userName + “] called method X with [” + i + “]”); // or this log.debug(String.format(“User [%s] called method X with [%d]”, userName, i)); 在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。因此在创建调试消息之前，最好先检查当前的日志级别。 // do this if (log.isDebugEnabled()) { log.debug(“User [” + userName + “] called method X with [” + i + “]”); } 10.使用Apache Commons StringUtils.Replace而不是String.replace一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。 有一个备选答案是Apache Commons Lang的StringUtils.replace方法。正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。 而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。 // replace this test.replace(“test”, “simple test”); // with this StringUtils.replace(test, “test”, “simple test”); 11.缓存昂贵的资源，如数据库连接缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。 一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。 你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。 但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。 所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们。 总结正如你所看到的，有时不需要太多工作就可以提高应用程序的性能。本文中的大部分建议只需要你稍作努力就可以将它们应用于你的代码。 但是，最重要的还是那些与是什么编程语言无关的技巧： 在你知道必要之前不要优化 使用分析器查找真正的瓶颈 首先处理最大的瓶颈 来源：原文：11 Simple Java Performance Tuning Tips译文：http://www.codeceo.com/article/11-simple-java-performance-tips.html","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"面试不懂「微服务架构」原理？不怕被pass了？","slug":"面试不懂「微服务架构」原理？不怕被pass了？","date":"2019-03-26T05:49:37.000Z","updated":"2019-04-17T08:20:51.280Z","comments":true,"path":"2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/","link":"","permalink":"http://chenguoji.com/2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/","excerpt":"","text":"近几年，微服务架构迅速在整个技术社区窜红，被认为是 IT 软件架构的未来方向。 一线互联网公司由于具有大量的业务体量和业务场景，比如阿里、百度、网易，很早就开始入坑微服务架构。 但说起微服务，不少人还是有这样的困惑：“作为一个开发，微服务架构是不是和我关系不大？那不都是架构师的事吗？” 关于这个问题，我来谈谈自己的看法。 微服务是当下最火热的后端架构之一。不管你是一个什么级别的程序员，也不论你在一个什么体量的公司， 服务化都是你迟早会遇到的难题。实践微服务的过程本身也是一个升级打怪的过程，这中间你会遇到基本上所有后端架构的问题。解决了这些问题，你自然也就理解了那些高深的概念，也就成为了一名架构师，成长和能力提升都是这个过程的附属品。 并且，你了解微服务架构之后，能知道领导为什么让你这么做，也更容易站在系统角度思考公司技术的进程，这对于你的大局观构建来说非常有帮助。 再者，微服务这技术在面试的时候总有人提，尤其对于头部互联网企业，微服务架构更是面试考核必备，所以“进大厂必须掌握的50个微服务面试问题”等一些文章备受欢迎。 如何设计高可用高并发的微服务架构 1.微服务架构如何拆分 2.微服务架构应用场合 3.微服务架构与Docker容器化 4.微服务架构如何达到99.999%的高可用 5.微服务架构性能怎么满足千亿次请求调用 6.微服务架构开源框架对比（Spring boot,Spring Cloud,Dubbo等） 来源：https://mp.weixin.qq.com/s/jqR6CxeJidvT9IrRplU98Q","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://chenguoji.com/tags/微服务/"},{"name":"原理","slug":"原理","permalink":"http://chenguoji.com/tags/原理/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"面试官必问的8道volatile关键字命题，你答对了吗？","slug":"面试官必问的8道volatile关键字命题，你答对了吗？","date":"2019-03-25T07:27:28.000Z","updated":"2019-04-26T03:21:04.425Z","comments":true,"path":"2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/","link":"","permalink":"http://chenguoji.com/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/","excerpt":"","text":"在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底， 把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。 下面我们以一次面试过程，来深入了解下volitile关键字吧！ 一、面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序。 二、面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？这个聊起来可就多了，我还是从Java内存模型说起吧。 Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。 简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。 在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存， 方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。 这么说得我自己都有些不清楚了，拿张纸画一下： 在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子： i = i + 1; 假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况： 线程1： load i from 主存 // i = 0 i + 1 // i = 1 线程2： load i from主存 // 因为线程1还没将i的值写回主存，所以i还是0 i + 1 //i = 1 线程1: save i to 主存 线程2： save i to 主存 如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。 下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的， 通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。 三、面试官：那你具体说说这三个特性呢？1 . 原子性(Atomicity)：Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如： i = 2; j = i; i++; i = i + 1； 上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 2 . 可见性(Visibility)：说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。 其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。 3 . 有序性（Ordering）JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段： double pi = 3.14; //A double r = 1; //B double s= pi * r * r;//C 上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码: int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。 这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下happens-before规则： 1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作 2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁 3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读 4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C 5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作 6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生 8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始 第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。 第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。 第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。 第4条规则，就是happens-before的传递性。 后面几条就不再一一赘述了。 四、面试官：volatile关键字如何满足并发编程的三大特性的？那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。 这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。 继续拿上面的一段代码举例： int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。 如果改成下面这样： int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则： 1.程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行) 2.volatile规则：2 happens-before 3 3.传递性规则：1 happens-before 4 从内存语义上来看 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子： public class Test { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } 按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。 假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。 线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。 此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。 有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。 又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。 综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。 六、面试官：说的还可以，那你知道volatile底层的实现机制？如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能： 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 2 . 使得本CPU的Cache写入内存 3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 七、面试官： 你在哪里会使用到volatile，举两个例子呢？1. 状态量标记，就如上面对flag的标记，我重新提一下：int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 2. 单例模式的实现，典型的双重检查锁定（DCL）class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。 八、面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没~ 来源：juejin.im/post/5a2b53b7f265da432a7b821c","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://chenguoji.com/tags/并发/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Redis的各项功能解决了哪些问题？","slug":"Redis的各项功能解决了哪些问题？","date":"2019-03-25T07:21:51.000Z","updated":"2019-04-10T01:35:04.244Z","comments":true,"path":"2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/","link":"","permalink":"http://chenguoji.com/2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/","excerpt":"","text":"Redis介绍官方简介解释到：Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。 同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。 它还内建了复制，lua脚本，LRU，事务等功能，通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。 综上所述，Redis提供了丰富的功能，初次见到可能会感觉眼花缭乱，这些功能都是干嘛用的？都解决了什么问题？什么情况下才会用到相应的功能？那么下面从零开始，一步一步的演进来粗略的解释下。 1、从零开始最初的需求非常简单，我们有一个提供热点新闻列表的api：http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。 随后我们就着手于如何提升一下api消费者感知的性能，很快最简单粗暴的第一个方案就出来了：为API的响应加上基于HTTP的缓存控制 cache-control:max-age=600 ，即让消费者可以缓存这个响应十分钟。 如果api消费者如果有效的利用了响应中的缓存控制信息，则可以有效的改善其感知的性能（10分钟以内）。但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。 2、基于本机内存的缓存为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。 后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。 其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆满了。。。 3、服务端的Redis在API服务器的内存都被缓存塞满的时候，我们发现不得不另想解决方案了。最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，把它的内存配置的大大的。然后我们就盯上了redis。。。 至于如何配置部署redis这里不解释了，redis官方有详细的介绍。随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。 3.1 持久化（Persistence）单台的Redis服务器一个月总有那么几天心情不好，心情不好就罢工了，导致所有的缓存都丢失了（redis的数据是存储在内存的嘛）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。 所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。 3.2 哨兵（Sentinel）和复制（Replication）Redis服务器毫无征兆的罢工是个麻烦事。那么怎办办？答曰：备份一台，你挂了它上。那么如何得知某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。 Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。 3.3 集群（Cluster）单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。 所以我们就需要一种解决方案，可以让我们横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：基于网络应用的架构）。 在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，也就是说redis本身并不关心分布式的事情，而是交由twemproxy和codis来负责。 而redis官方给出的cluster方案则是把分布式的这部分事情做到了每一个redis服务器中，使其不再需要其他的组件就可以独立的完成分布式的要求。我们这里不关心这些方案的优略，我们关注一下这里的分布式到底是要处理那些事情?也就是twemproxy和codis独立处理的处理分布式的这部分逻辑和cluster集成到redis服务的这部分逻辑到底在解决什么问题？ 如我们前面所说的，一个分布式的服务在外界看来就像是一个集中式的服务一样。那么要做到这一点就面临着有一个问题需要解决：既是增加或减少分布式服务中的服务器的数量，对消费这个服务的客户端而言应该是无感的；那么也就意味着客户端不能穿透分布式服务，把自己绑死到某一个台的服务器上去，因为一旦如此，你就再也无法新增服务器，也无法进行故障替换。 解决这个问题有两个路子： 第一个路子最直接，那就是我加一个中间层来隔离这种具体的依赖，即twemproxy采用的方式，让所有的客户端只能通过它来消费redsi服务，通过它来隔离这种依赖（但是你会发现twermproxy会成为一个单点），这种情况下每台redis服务器都是独立的，它们之间彼此不知对方的存在； 第二个路子是让redis服务器知道彼此的存在，通过重定向的机制来引导客户端来完成自己所需要的操作，比如客户端链接到了某一个redis服务器，说我要执行这个操作，redis服务器发现自己无法完成这个操作，那么就把能完成这个操作的服务器的信息给到客户端，让客户端去请求另外的一个服务器，这时候你就会发现每一个redis服务器都需要保持一份完整的分布式服务器信息的一份资料，不然它怎么知道让客户端去找其他的哪个服务器来执行客户端想要的操作呢。 上面这一大段解释了这么多，不知有没有发现不管是第一个路子还是第二个路子，都有一个共同的东西存在，那就是分布式服务中所有服务器以及其能提供的服务的信息。这些信息无论如何也是要存在的，区别在于第一个路子是把这部分信息单独来管理，用这些信息来协调后端的多个独立的redis服务器；第二个路子则是让每一个redis服务器都持有这份信息，彼此知道对方的存在，来达成和第一个路子一样的目的，优点是不再需要一个额外的组件来处理这部分事情。 Redis Cluster的具体实现细节则是采用了Hash槽的概念，即预先分配出来16384个槽：在客户端通过对Key进行CRC16（key）% 16384运算得到对应的槽是哪一个；在redis服务端则是每个服务器负责一部分槽，当有新的服务器加入或者移除的时候，再来迁移这些槽以及其对应的数据，同时每个服务器都持有完整的槽和其对应的服务器的信息，这就使得服务器端可以进行对客户端的请求进行重定向处理。 4、客户端的Redis上面的第三小节主要介绍的是Redis服务端的演进步骤，解释了Redis如何从一个单机的服务，进化为一个高可用的、去中心化的、分布式的存储系统。这一小节则是关注下客户端可以消费的redis服务。 4.1 数据类型redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持： string：最基本的数据类型，二进制安全的字符串，最大512M。 list：按照添加顺序保持顺序的字符串列表。 set：无序的字符串集合，不存在重复的元素。 sorted set：已排序的字符串集合。 hash：key-value对的一种集合。 bitmap：更细化的一种操作，以bit为单位。 hyperloglog：基于概率的数据结构。 这些众多的数据类型，主要是为了支持各种场景的需要，当然每种类型都有不同的时间复杂度。其实这些复杂的数据结构相当于之前我在《解读REST》这个系列博客基于网络应用的架构风格中介绍到的远程数据访问（Remote Data Access = RDA）的具体实现，即通过在服务器上执行一组标准的操作命令，在服务端之间得到想要的缩小后的结果集，从而简化客户端的使用，也可以提高网络性能。比如如果没有list这种数据结构，你就只能把list存成一个string，客户端拿到完整的list，操作后再完整的提交给redis，会产生很大的浪费。 4.2 事务上述数据类型中，每一个数据类型都有独立的命令来进行操作，很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。 4.3 Lua脚本在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于基于网络应用的架构风格中介绍到的远程求值（Remote Evluation = REV）的具体实现。 4.4 管道因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。管道和事务的差异在于管道是为了节省通信的开销，但是并不会保证原子性。 4.5 分布式锁官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下： SET resource_name my_random_value NX PX 30000 if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1]) else return 0 end 总结本篇着重从抽象层面来解释下redis的各项功能以及其存在的目的，而没有关心其具体的细节是什么。从而可以聚焦于其解决的问题，依据抽象层面的概念可以使得我们在特定的场景下选择更合适的方案，而非局限于其技术细节。 来源：作者：blackheartwww.cnblogs.com/linianhui","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://chenguoji.com/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"谈谈final、finally、finalize有什么不同？","slug":"谈谈final、finally、finalize有什么不同？","date":"2019-03-23T02:56:10.000Z","updated":"2019-03-25T07:23:05.941Z","comments":true,"path":"2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/","link":"","permalink":"http://chenguoji.com/2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/","excerpt":"","text":"初级程序猿面试一般会问的问题。 可以按照以下回答： 1. final 可以用来修饰类、方法、变量。分别有不同的意义： final 修饰的 class 代表不可以继承扩展 final 的变量是不可以修改的 final 的方法也是不可以重写的（override） 2. finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 3.finalize 是基础类 java.lang.Object 的一个方法。它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 注意事项：1，不要在 finally 中使用 return 语句。2，finally 总是执行，除非程序或者线程被中断。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"请对比Exception和Error有什么区别？","slug":"请对比Exception和Error有什么区别？","date":"2019-03-23T02:43:42.000Z","updated":"2019-04-17T08:20:45.398Z","comments":true,"path":"2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/","link":"","permalink":"http://chenguoji.com/2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/","excerpt":"","text":"面试一般是这样问：运行时异常与一般异常有什么区别？ 简单点来讲就是：运行时异常可以不处理，一般异常必须处理。 运行时异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 一般异常，JAVA编译器强制要求用户必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。 不同点： 1.从继承来讲，Exception 和 Error都继承自Throwable类。 2.Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。 Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"关于","slug":"about","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-22T02:18:37.994Z","comments":true,"path":"2019/03/21/about/","link":"","permalink":"http://chenguoji.com/2019/03/21/about/","excerpt":"","text":"关于博主博主是一名Java码农。 虽然还未走上人生巅峰，但是一直保持着一个码农的自我修养。 用一句话概括博主：每天瞎逼忙，还没赚到钱。 但是博主有一颗分享技术的心，我会尽量用通俗易懂的方式，分享个人的知识。 博客的宗旨就是分享知识，分享技术，不一定高深，但一定是博主用心写作而成的。 所有人都是从0开始起步，在学习过程中，会遇到各种困难，这个时候如果可以借鉴别人的经验，会让我们省力不少，希望我的博客也能帮助到你。","categories":[{"name":"关于","slug":"关于","permalink":"http://chenguoji.com/categories/关于/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://chenguoji.com/tags/博客说明/"}],"keywords":[{"name":"关于","slug":"关于","permalink":"http://chenguoji.com/categories/关于/"}]},{"title":"Java转型大数据开发技能","slug":"Java转型大数据开发技能","date":"2019-03-21T02:39:50.000Z","updated":"2019-04-17T08:11:39.976Z","comments":true,"path":"2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/","link":"","permalink":"http://chenguoji.com/2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/","excerpt":"","text":"很多做程序猿都知道，对于技术方面，擅长大家一直提倡的是精一门，再横向发展，多学一点总不是坏事。 什么意思呢？ 就是我们当前工作用到的那一门技术一定要学好、学精、学深，然后可以拓展其他相关的技术栈。 如此多的技术，怎么学得过来呢？ 我觉得以你自己的岗位为主，其他为辅，关于自己工作相关的技术，花更多的时间和精力，研究得更深入，其他领域的可以了解和关注，等到需要用到或者感兴趣的时候，在深入学习即可。 那作为 Java 开发，除了 Java 还可以学什么？ 大数据可能是一个不错的方向。 一、转型大数据需要哪些技能？ 技术层面来说，如果你初步掌握Java编程，转型大数据都是非常轻松的具有天然的优势。 Java编程是大数据开发的基础，Java编程是必备技能； 大数据使用的Hadoop(在分布式服务器集群上存储海量数据并运行分布式分析应用的一种方法)需要Java基础， 所以有很多搞Java的都在往这hadoop大数据方向转。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://chenguoji.com/tags/大数据/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"Java面试中最高频的那20%知识点！","slug":"Java面试","date":"2019-03-21T02:39:50.000Z","updated":"2019-04-17T08:21:11.942Z","comments":true,"path":"2019/03/21/java-mian-shi/","link":"","permalink":"http://chenguoji.com/2019/03/21/java-mian-shi/","excerpt":"","text":"Java目前已经不仅仅是一门开发语言，而是一整套生态体系。 作为一个Java程序员，既是幸运的，也是不幸的。幸运的是我们有很多轮子可以拿过来用，不幸的是我们有太多的轮子需要学习。 但是，无论是日常工作还是面试问题，也都符合二八原则。即掌握20%的知识，就能解决80%的问题。 那么，Java程序员必须掌握的20%知识点都有哪些呢？ 个人认为包括以下内容： Java基础知识，如集合类、IO、泛型等。 JVM底层知识，如类加载机制、GC、JVM内存结构等。 Java并发编程知识，如Java内存模型、并发包、线程池、netty等。 开发框架知识，如Spring、mybatis、springboot、springMVC等。 分布式相关知识，如CAP理论、分布式锁、分布式事务、Zookeeper、spring Cloud等。 其他基础知识，编程语言、网络方面、数据库、数据结构和算法。 中间件相关知识，如Redis、rabbitMQ、Dubbo等。 服务器相关知识，如tomcat、jetty、jboss等。 以上这些知识，就是最高频的面试问题，以及工作中需要用到的知识。当然，一个程序员想要掌握以上所有知识，可能需要花费很长时间。这个过程注定是漫长且孤独的。 来源：https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]}]}