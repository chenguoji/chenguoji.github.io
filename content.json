{"meta":{"title":"人生如戏，全靠颜值","subtitle":"人生如戏，全靠颜值","description":null,"author":"chen guoji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"11个简单的Java性能调优技巧","slug":"11个简单的Java性能调优技巧","date":"2019-03-28T02:35:17.000Z","updated":"2019-03-28T02:52:08.792Z","comments":true,"path":"2019/03/28/11个简单的Java性能调优技巧/","link":"","permalink":"http://yoursite.com/2019/03/28/11个简单的Java性能调优技巧/","excerpt":"","text":"大多数开发人员理所当然地以为性能优化很复杂，需要大量的经验和知识。好吧，不能说这是完全错误的。优化应用程序以获得最佳性能不是一件容易的事情。但是，这并不意味着如果你不具备这些知识，就不能做任何事情。 这里有11个易于遵循的建议和最佳实践可以帮助你创建一个性能良好的应用程序。 大部分建议是针对Java的。但也有若干建议是与语言无关的，可以应用于所有应用程序和编程语言。在讨论专门针对Java的性能调优技巧之前，让我们先来看看通用技巧。 1.在你知道必要之前不要优化这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。 在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。 那么，你如何证明你需要优化一些东西呢？ 首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。 2.使用分析器查找真正的瓶颈在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？ 你可以用两种方法来解决问题： 查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。 或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。 希望不需要我解释为什么应该始终遵循第二种方法的原因。 很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。老实说，我第一次的猜测不止一次地导致我走错了方向。 3.为整个应用程序创建性能测试套件这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。 这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。 4.首先处理最大的瓶颈在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。Java 程序员必须清楚的 7 个性能指标，这个你也必须会。 速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。 但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。 5.使用StringBuilder以编程方式连接String有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。String 真的是不可变的吗？ 那么，你应该选择哪种方法？ 答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。StringBuffer 和 StringBuilder 的 3 个区别，这个你必须清楚。 你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。 下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。 StringBuilder sb = new StringBuilder(“This is a test”); for (int i=0; i&lt;10; i++) { sb.append(i); sb.append(” “); } log.info(sb.toString()); 正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。 如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。这进一步提高了效率，因为它不需要动态扩展其容量。 6.使用+连接一个语句中的String当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。 在这些情况下，你应该遵循技巧5并使用StringBuilder。 但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。 Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ” + “FROM Author a ” + “WHERE a.id = :id”); 在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。 7.尽可能使用基元避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。 8.试着避免BigInteger和BigDecimal既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。 BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。金融系统中正确的金额计算及存储方式，这个你了解下。 9.首先检查当前日志级别 这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。 这里有两个反面例子。 // don’t do this log.debug(“User [” + userName + “] called method X with [” + i + “]”); // or this log.debug(String.format(“User [%s] called method X with [%d]”, userName, i)); 在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。因此在创建调试消息之前，最好先检查当前的日志级别。 // do this if (log.isDebugEnabled()) { log.debug(“User [” + userName + “] called method X with [” + i + “]”); } 10.使用Apache Commons StringUtils.Replace而不是String.replace一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。 有一个备选答案是Apache Commons Lang的StringUtils.replace方法。正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。 而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。 // replace this test.replace(“test”, “simple test”); // with this StringUtils.replace(test, “test”, “simple test”); 11.缓存昂贵的资源，如数据库连接缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。 一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。 你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。 但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。 所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们。 总结正如你所看到的，有时不需要太多工作就可以提高应用程序的性能。本文中的大部分建议只需要你稍作努力就可以将它们应用于你的代码。 但是，最重要的还是那些与是什么编程语言无关的技巧： 在你知道必要之前不要优化 使用分析器查找真正的瓶颈 首先处理最大的瓶颈 来源：原文：11 Simple Java Performance Tuning Tips译文：http://www.codeceo.com/article/11-simple-java-performance-tips.html","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"面试不懂「微服务架构」原理？不怕被pass了？","slug":"面试不懂「微服务架构」原理？不怕被pass了？","date":"2019-03-26T05:49:37.000Z","updated":"2019-03-26T05:53:58.217Z","comments":true,"path":"2019/03/26/面试不懂「微服务架构」原理？不怕被pass了？/","link":"","permalink":"http://yoursite.com/2019/03/26/面试不懂「微服务架构」原理？不怕被pass了？/","excerpt":"","text":"近几年，微服务架构迅速在整个技术社区窜红，被认为是 IT 软件架构的未来方向。 一线互联网公司由于具有大量的业务体量和业务场景，比如阿里、百度、网易，很早就开始入坑微服务架构。 但说起微服务，不少人还是有这样的困惑：“作为一个开发，微服务架构是不是和我关系不大？那不都是架构师的事吗？” 关于这个问题，我来谈谈自己的看法。 微服务是当下最火热的后端架构之一。不管你是一个什么级别的程序员，也不论你在一个什么体量的公司， 服务化都是你迟早会遇到的难题。实践微服务的过程本身也是一个升级打怪的过程，这中间你会遇到基本上所有后端架构的问题。解决了这些问题，你自然也就理解了那些高深的概念，也就成为了一名架构师，成长和能力提升都是这个过程的附属品。 并且，你了解微服务架构之后，能知道领导为什么让你这么做，也更容易站在系统角度思考公司技术的进程，这对于你的大局观构建来说非常有帮助。 再者，微服务这技术在面试的时候总有人提，尤其对于头部互联网企业，微服务架构更是面试考核必备，所以“进大厂必须掌握的50个微服务面试问题”等一些文章备受欢迎。 如何设计高可用高并发的微服务架构 1.微服务架构如何拆分 2.微服务架构应用场合 3.微服务架构与Docker容器化 4.微服务架构如何达到99.999%的高可用 5.微服务架构性能怎么满足千亿次请求调用 6.微服务架构开源框架对比（Spring boot,Spring Cloud,Dubbo等） 来源：https://mp.weixin.qq.com/s/jqR6CxeJidvT9IrRplU98Q","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"微服务、原理","slug":"微服务、原理","permalink":"http://yoursite.com/tags/微服务、原理/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"面试官必问的8道volatile关键字命题，你答对了吗？","slug":"面试官必问的8道volatile关键字命题，你答对了吗？","date":"2019-03-25T07:27:28.000Z","updated":"2019-03-25T07:46:47.317Z","comments":true,"path":"2019/03/25/面试官必问的8道volatile关键字命题，你答对了吗？/","link":"","permalink":"http://yoursite.com/2019/03/25/面试官必问的8道volatile关键字命题，你答对了吗？/","excerpt":"","text":"在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底， 把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。 下面我们以一次面试过程，来深入了解下volitile关键字吧！ 一、面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序。 二、面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？这个聊起来可就多了，我还是从Java内存模型说起吧。 Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。 简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。 在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存， 方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。 这么说得我自己都有些不清楚了，拿张纸画一下： 在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子： i = i + 1; 假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况： 线程1： load i from 主存 // i = 0 i + 1 // i = 1 线程2： load i from主存 // 因为线程1还没将i的值写回主存，所以i还是0 i + 1 //i = 1 线程1: save i to 主存 线程2： save i to 主存 如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。 下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的， 通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。 三、面试官：那你具体说说这三个特性呢？1 . 原子性(Atomicity)：Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如： i = 2; j = i; i++; i = i + 1； 上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 2 . 可见性(Visibility)：说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。 其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。 3 . 有序性（Ordering）JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段： double pi = 3.14; //A double r = 1; //B double s= pi * r * r;//C 上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码: int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。 这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下happens-before规则： 1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作 2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁 3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读 4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C 5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作 6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生 8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始 第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。 第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。 第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。 第4条规则，就是happens-before的传递性。 后面几条就不再一一赘述了。 四、面试官：volatile关键字如何满足并发编程的三大特性的？那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。 这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。 继续拿上面的一段代码举例： int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。 如果改成下面这样： int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则： 1.程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行) 2.volatile规则：2 happens-before 3 3.传递性规则：1 happens-before 4 从内存语义上来看 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子： public class Test { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } 按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。 假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。 线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。 此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。 有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。 又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。 综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。 六、面试官：说的还可以，那你知道volatile底层的实现机制？如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能： 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 2 . 使得本CPU的Cache写入内存 3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 七、面试官： 你在哪里会使用到volatile，举两个例子呢？1. 状态量标记，就如上面对flag的标记，我重新提一下：int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 2. 单例模式的实现，典型的双重检查锁定（DCL）class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。 八、面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没~ 来源：juejin.im/post/5a2b53b7f265da432a7b821c","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"java、并发","slug":"java、并发","permalink":"http://yoursite.com/tags/java、并发/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]},{"title":"'Redis的各项功能解决了哪些问题？'","slug":"Redis的各项功能解决了哪些问题？","date":"2019-03-25T07:21:51.000Z","updated":"2019-03-25T07:43:43.499Z","comments":true,"path":"2019/03/25/Redis的各项功能解决了哪些问题？/","link":"","permalink":"http://yoursite.com/2019/03/25/Redis的各项功能解决了哪些问题？/","excerpt":"","text":"Redis介绍官方简介解释到：Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。 同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。 它还内建了复制，lua脚本，LRU，事务等功能，通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。 综上所述，Redis提供了丰富的功能，初次见到可能会感觉眼花缭乱，这些功能都是干嘛用的？都解决了什么问题？什么情况下才会用到相应的功能？那么下面从零开始，一步一步的演进来粗略的解释下。 1、从零开始最初的需求非常简单，我们有一个提供热点新闻列表的api：http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。 随后我们就着手于如何提升一下api消费者感知的性能，很快最简单粗暴的第一个方案就出来了：为API的响应加上基于HTTP的缓存控制 cache-control:max-age=600 ，即让消费者可以缓存这个响应十分钟。 如果api消费者如果有效的利用了响应中的缓存控制信息，则可以有效的改善其感知的性能（10分钟以内）。但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。 2、基于本机内存的缓存为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。 后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。 其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆满了。。。 3、服务端的Redis在API服务器的内存都被缓存塞满的时候，我们发现不得不另想解决方案了。最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，把它的内存配置的大大的。然后我们就盯上了redis。。。 至于如何配置部署redis这里不解释了，redis官方有详细的介绍。随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。 3.1 持久化（Persistence）单台的Redis服务器一个月总有那么几天心情不好，心情不好就罢工了，导致所有的缓存都丢失了（redis的数据是存储在内存的嘛）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。 所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。 3.2 哨兵（Sentinel）和复制（Replication）Redis服务器毫无征兆的罢工是个麻烦事。那么怎办办？答曰：备份一台，你挂了它上。那么如何得知某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。 Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。 3.3 集群（Cluster）单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。 所以我们就需要一种解决方案，可以让我们横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：基于网络应用的架构）。 在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，也就是说redis本身并不关心分布式的事情，而是交由twemproxy和codis来负责。 而redis官方给出的cluster方案则是把分布式的这部分事情做到了每一个redis服务器中，使其不再需要其他的组件就可以独立的完成分布式的要求。我们这里不关心这些方案的优略，我们关注一下这里的分布式到底是要处理那些事情?也就是twemproxy和codis独立处理的处理分布式的这部分逻辑和cluster集成到redis服务的这部分逻辑到底在解决什么问题？ 如我们前面所说的，一个分布式的服务在外界看来就像是一个集中式的服务一样。那么要做到这一点就面临着有一个问题需要解决：既是增加或减少分布式服务中的服务器的数量，对消费这个服务的客户端而言应该是无感的；那么也就意味着客户端不能穿透分布式服务，把自己绑死到某一个台的服务器上去，因为一旦如此，你就再也无法新增服务器，也无法进行故障替换。 解决这个问题有两个路子： 第一个路子最直接，那就是我加一个中间层来隔离这种具体的依赖，即twemproxy采用的方式，让所有的客户端只能通过它来消费redsi服务，通过它来隔离这种依赖（但是你会发现twermproxy会成为一个单点），这种情况下每台redis服务器都是独立的，它们之间彼此不知对方的存在； 第二个路子是让redis服务器知道彼此的存在，通过重定向的机制来引导客户端来完成自己所需要的操作，比如客户端链接到了某一个redis服务器，说我要执行这个操作，redis服务器发现自己无法完成这个操作，那么就把能完成这个操作的服务器的信息给到客户端，让客户端去请求另外的一个服务器，这时候你就会发现每一个redis服务器都需要保持一份完整的分布式服务器信息的一份资料，不然它怎么知道让客户端去找其他的哪个服务器来执行客户端想要的操作呢。 上面这一大段解释了这么多，不知有没有发现不管是第一个路子还是第二个路子，都有一个共同的东西存在，那就是分布式服务中所有服务器以及其能提供的服务的信息。这些信息无论如何也是要存在的，区别在于第一个路子是把这部分信息单独来管理，用这些信息来协调后端的多个独立的redis服务器；第二个路子则是让每一个redis服务器都持有这份信息，彼此知道对方的存在，来达成和第一个路子一样的目的，优点是不再需要一个额外的组件来处理这部分事情。 Redis Cluster的具体实现细节则是采用了Hash槽的概念，即预先分配出来16384个槽：在客户端通过对Key进行CRC16（key）% 16384运算得到对应的槽是哪一个；在redis服务端则是每个服务器负责一部分槽，当有新的服务器加入或者移除的时候，再来迁移这些槽以及其对应的数据，同时每个服务器都持有完整的槽和其对应的服务器的信息，这就使得服务器端可以进行对客户端的请求进行重定向处理。 4、客户端的Redis上面的第三小节主要介绍的是Redis服务端的演进步骤，解释了Redis如何从一个单机的服务，进化为一个高可用的、去中心化的、分布式的存储系统。这一小节则是关注下客户端可以消费的redis服务。 4.1 数据类型redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持： string：最基本的数据类型，二进制安全的字符串，最大512M。 list：按照添加顺序保持顺序的字符串列表。 set：无序的字符串集合，不存在重复的元素。 sorted set：已排序的字符串集合。 hash：key-value对的一种集合。 bitmap：更细化的一种操作，以bit为单位。 hyperloglog：基于概率的数据结构。 这些众多的数据类型，主要是为了支持各种场景的需要，当然每种类型都有不同的时间复杂度。其实这些复杂的数据结构相当于之前我在《解读REST》这个系列博客基于网络应用的架构风格中介绍到的远程数据访问（Remote Data Access = RDA）的具体实现，即通过在服务器上执行一组标准的操作命令，在服务端之间得到想要的缩小后的结果集，从而简化客户端的使用，也可以提高网络性能。比如如果没有list这种数据结构，你就只能把list存成一个string，客户端拿到完整的list，操作后再完整的提交给redis，会产生很大的浪费。 4.2 事务上述数据类型中，每一个数据类型都有独立的命令来进行操作，很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。 4.3 Lua脚本在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于基于网络应用的架构风格中介绍到的远程求值（Remote Evluation = REV）的具体实现。 4.4 管道因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。管道和事务的差异在于管道是为了节省通信的开销，但是并不会保证原子性。 4.5 分布式锁官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下： SET resource_name my_random_value NX PX 30000 if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1]) else return 0 end 总结本篇着重从抽象层面来解释下redis的各项功能以及其存在的目的，而没有关心其具体的细节是什么。从而可以聚焦于其解决的问题，依据抽象层面的概念可以使得我们在特定的场景下选择更合适的方案，而非局限于其技术细节。 来源：作者：blackheartwww.cnblogs.com/linianhui","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"谈谈final、finally、finalize有什么不同？","slug":"谈谈final、finally、finalize有什么不同？","date":"2019-03-23T02:56:10.000Z","updated":"2019-03-25T07:23:05.941Z","comments":true,"path":"2019/03/23/谈谈final、finally、finalize有什么不同？/","link":"","permalink":"http://yoursite.com/2019/03/23/谈谈final、finally、finalize有什么不同？/","excerpt":"","text":"初级程序猿面试一般会问的问题。 可以按照以下回答： 1. final 可以用来修饰类、方法、变量。分别有不同的意义： final 修饰的 class 代表不可以继承扩展 final 的变量是不可以修改的 final 的方法也是不可以重写的（override） 2. finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 3.finalize 是基础类 java.lang.Object 的一个方法。它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 注意事项：1，不要在 finally 中使用 return 语句。2，finally 总是执行，除非程序或者线程被中断。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"请对比Exception和Error有什么区别？","slug":"请对比Exception和Error有什么区别？","date":"2019-03-23T02:43:42.000Z","updated":"2019-03-25T07:23:17.073Z","comments":true,"path":"2019/03/23/请对比Exception和Error有什么区别？/","link":"","permalink":"http://yoursite.com/2019/03/23/请对比Exception和Error有什么区别？/","excerpt":"","text":"面试一般是这样问：运行时异常与一般异常有什么区别？ 简单点来讲就是：运行时异常可以不处理，一般异常必须处理。 运行时异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 一般异常，JAVA编译器强制要求用户必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。 不同点： 1.从继承来讲，Exception 和 Error都继承自Throwable类。 2.Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。 Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"JS面试之数组","slug":"JS面试之数组","date":"2019-03-23T02:39:50.000Z","updated":"2019-03-23T02:32:35.089Z","comments":true,"path":"2019/03/23/JS面试之数组/","link":"","permalink":"http://yoursite.com/2019/03/23/JS面试之数组/","excerpt":"","text":"前言本文主要从应用来讲JS数组api的一些骚操作，如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等。 上面这些应用场景你可以用一行代码实现吗？ 1.扁平化n维数组1.终极篇12345 [1,[2,3]].flat(2) //[1,2,3][1,[2,3,[4,5]].flat(3) //[1,2,3,4,5][1,[2,3,[4,5[...]].flat(Infinity) //[1,2,3,4...n] Array.flat(n)是ES10扁平数组的api， n表示维度， n值为 Infinity时维度为无限大 2.开始篇 实质是利用递归和数组合并方法 concat实现扁平。 来源：作者：火狼https://segmentfault.com/a/1190000018549643","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"关于","slug":"about","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-22T02:18:37.994Z","comments":true,"path":"2019/03/21/about/","link":"","permalink":"http://yoursite.com/2019/03/21/about/","excerpt":"","text":"关于博主博主是一名Java码农。 虽然还未走上人生巅峰，但是一直保持着一个码农的自我修养。 用一句话概括博主：每天瞎逼忙，还没赚到钱。 但是博主有一颗分享技术的心，我会尽量用通俗易懂的方式，分享个人的知识。 博客的宗旨就是分享知识，分享技术，不一定高深，但一定是博主用心写作而成的。 所有人都是从0开始起步，在学习过程中，会遇到各种困难，这个时候如果可以借鉴别人的经验，会让我们省力不少，希望我的博客也能帮助到你。","categories":[{"name":"关于","slug":"关于","permalink":"http://yoursite.com/categories/关于/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://yoursite.com/tags/博客说明/"}],"keywords":[{"name":"关于","slug":"关于","permalink":"http://yoursite.com/categories/关于/"}]},{"title":"MyBatis动态SQL","slug":"MyBatis动态SQL","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-23T02:33:02.067Z","comments":true,"path":"2019/03/21/MyBatis动态SQL/","link":"","permalink":"http://yoursite.com/2019/03/21/MyBatis动态SQL/","excerpt":"MyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。 MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：","text":"MyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。 MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签： 一、 数据准备为了后面的演示， 创建了一个 Maven 项目 mybatis-dynamic, 创建了对应的数据库和表 12345678910111213141516DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `student_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;编号&apos;, `name` varchar(20) DEFAULT NULL COMMENT &apos;姓名&apos;, `phone` varchar(20) DEFAULT NULL COMMENT &apos;电话&apos;, `email` varchar(50) DEFAULT NULL COMMENT &apos;邮箱&apos;, `sex` tinyint(4) DEFAULT NULL COMMENT &apos;性别&apos;, `locked` tinyint(4) DEFAULT NULL COMMENT &apos;状态(0:正常,1:锁定)&apos;, `gmt_created` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &apos;存入数据库的时间&apos;, `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改的时间&apos;, `delete` int(11) DEFAULT NULL, PRIMARY KEY (`student_id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&apos;学生表&apos;; 二、 if 标签if 标签是我们最常使用的。 在查询、删除、更新的时候很可能会使用到。 必须结合 test 属性联合使用。 2.1 在 WHERE 条件中使用 if 标签这是常见的一种现象， 我们在进行按条件查询的时候， 可能会有多种情况。 2.1.1 查询条件根据输入的学生信息进行条件检索 当只输入用户名时， 使用用户名进行模糊检索；当只输入性别时， 使用性别进行完全匹配当用户名和性别都存在时， 用这两个条件进行查询匹配查询 2.1.2 动态 SQL接口函数1234567891011121314151617181920212223242526 /** * 根据输入的学生信息进行条件检索 * 1. 当只输入用户名时， 使用用户名进行模糊检索； * 2. 当只输入邮箱时， 使用性别进行完全匹配 * 3. 当用户名和性别都存在时， 用这两个条件进行查询匹配的用 * @param student * @return */List&lt;Student&gt; selectByStudentSelective(Student student);对应的动态 SQL &lt;select id=&quot;selectByStudentSelective&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;com.homejim.mybatis.entity.Student&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from student where 1=1 &lt;if test=&quot;name != null and name !=&apos;&apos;&quot;&gt; and name like concat(&apos;%&apos;, #&#123;name&#125;, &apos;%&apos;) &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;/select&gt; 在此 SQL 语句中， where 1=1 是多条件拼接时的小技巧， 后面的条件查询就可以都用 and 了。 同时， 我们添加了 if 标签来处理动态 SQL123456&lt;if test=&quot;name != null and name !=&apos;&apos;&quot;&gt; and name like concat(&apos;%&apos;, #&#123;name&#125;, &apos;%&apos;)&lt;/if&gt;&lt;if test=&quot;sex != null&quot;&gt; and sex=#&#123;sex&#125;&lt;/if&gt; 此 if 标签的 test 属性值是一个符合 OGNL 的表达式， 表达式可以是 true 或 false。 如果表达式返回的是数值， 则0为 false, 非 0 为 true; 2.1.3 测试1234567891011121314151617181920212223242526272829303132@Test public void selectByStudent() &#123; SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student search = new Student(); search.setName(&quot;明&quot;); System.out.println(&quot;只有名字时的查询&quot;); List&lt;Student&gt; studentsByName = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsByName.size(); i++) &#123; System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE)); &#125; search.setName(null); search.setSex((byte) 1); System.out.println(&quot;只有性别时的查询&quot;); List&lt;Student&gt; studentsBySex = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsBySex.size(); i++) &#123; System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE)); &#125; System.out.println(&quot;姓名和性别同时存在的查询&quot;); search.setName(&quot;明&quot;); List&lt;Student&gt; studentsByNameAndSex = studentMapper.selectByStudentSelective(search); for (int i = 0; i &lt; studentsByNameAndSex.size(); i++) &#123; System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE)); &#125; sqlSession.commit(); sqlSession.close(); 只有名字时的查询， 发送的语句和结果 查询的条件只发送了 where 1=1 and name like concat(‘%’, ?, ‘%’) 只有性别时的查询， 发送的语句和结果 查询的条件只发送了 where 1=1 and sex=? 姓名和性别同时存在的查询， 发送的语句和结果 查询条件 where 1=1 and name like concat(‘%’, ?, ‘%’) and sex=? 2.2 在 UPDATE 更新列中使用 if 标签有时候我们不希望更新所有的字段， 只更新有变化的字段。 2.2.1 更新条件只更新有变化的字段， 空值不更新。 2.2.1 动态 SQL接口方法12345678910111213141516171819202122232425262728293031323334 /** * 更新非空属性 */ int updateByPrimaryKeySelective(Student record); 对应的 SQL &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.homejim.mybatis.entity.Student&quot;&gt; update student &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; `name` = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; sex = #&#123;sex,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;locked != null&quot;&gt; locked = #&#123;locked,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;gmtCreated != null&quot;&gt; gmt_created = #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=&quot;gmtModified != null&quot;&gt; gmt_modified = #&#123;gmtModified,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/set&gt; where student_id = #&#123;studentId,jdbcType=INTEGER&#125; 2.2.3 测试123456789101112131415@Testpublic void updateByStudentSelective() &#123; SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(); student.setStudentId(1); student.setName(&quot;明明&quot;); student.setPhone(&quot;13838438888&quot;); System.out.println(studentMapper.updateByPrimaryKeySelective(student)); sqlSession.commit(); sqlSession.close(); 2.3 在 INSERT 动态插入中使用 if 标签我们插入数据库中的一条记录， 不是每一个字段都有值的， 而是动态变化的。 在这时候使用 if 标签， 可帮我们解决这个问题。 2.3.1 插入条件只有非空属性才插入。 2.3.2 动态SQL接口方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 /** * 非空字段才进行插入 */ int insertSelective(Student record); 对应的SQL&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.homejim.mybatis.entity.Student&quot;&gt; insert into student &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;studentId != null&quot;&gt; student_id, &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; `name`, &lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt; phone, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; sex, &lt;/if&gt; &lt;if test=&quot;locked != null&quot;&gt; locked, &lt;/if&gt; &lt;if test=&quot;gmtCreated != null&quot;&gt; gmt_created, &lt;/if&gt; &lt;if test=&quot;gmtModified != null&quot;&gt; gmt_modified, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;studentId != null&quot;&gt; #&#123;studentId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;phone != null&quot;&gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;sex != null&quot;&gt; #&#123;sex,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;locked != null&quot;&gt; #&#123;locked,jdbcType=TINYINT&#125;, &lt;/if&gt; &lt;if test=&quot;gmtCreated != null&quot;&gt; #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=&quot;gmtModified != null&quot;&gt; #&#123;gmtModified,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 这个 SQL 大家应该很熟悉， 毕竟是自动生成的。 2.3.3 测试12345678910111213141516171819@Testpublic void insertByStudentSelective() &#123; SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = new Student(); student.setName(&quot;小飞机&quot;); student.setPhone(&quot;13838438899&quot;); student.setEmail(&quot;xiaofeiji@qq.com&quot;); student.setLocked((byte) 0); System.out.println(studentMapper.insertSelective(student)); sqlSession.commit(); sqlSession.close();&#125; SQL 中， 只有非空的字段才进行了插入。 三、代码使用示例：https://github.com/homejim/mybatis-examples 来源:作者：阿进的写字台cnblogs.com/homejim/p/9909657.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Java转型大数据开发技能","slug":"Java转型大数据开发技能","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-23T02:57:08.875Z","comments":true,"path":"2019/03/21/Java转型大数据开发技能/","link":"","permalink":"http://yoursite.com/2019/03/21/Java转型大数据开发技能/","excerpt":"","text":"很多做程序猿都知道，对于技术方面，擅长大家一直提倡的是精一门，再横向发展，多学一点总不是坏事。 什么意思呢？ 就是我们当前工作用到的那一门技术一定要学好、学精、学深，然后可以拓展其他相关的技术栈。 如此多的技术，怎么学得过来呢？ 我觉得以你自己的岗位为主，其他为辅，关于自己工作相关的技术，花更多的时间和精力，研究得更深入，其他领域的可以了解和关注，等到需要用到或者感兴趣的时候，在深入学习即可。 那作为 Java 开发，除了 Java 还可以学什么？ 大数据可能是一个不错的方向。 一、转型大数据需要哪些技能？ 技术层面来说，如果你初步掌握Java编程，转型大数据都是非常轻松的具有天然的优势。 Java编程是大数据开发的基础，Java编程是必备技能； 大数据使用的Hadoop(在分布式服务器集群上存储海量数据并运行分布式分析应用的一种方法)需要Java基础， 所以有很多搞Java的都在往这hadoop大数据方向转。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}]},{"title":"Java面试中最高频的那20%知识点！","slug":"Java面试","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-23T02:34:45.258Z","comments":true,"path":"2019/03/21/Java面试/","link":"","permalink":"http://yoursite.com/2019/03/21/Java面试/","excerpt":"","text":"Java目前已经不仅仅是一门开发语言，而是一整套生态体系。 作为一个Java程序员，既是幸运的，也是不幸的。幸运的是我们有很多轮子可以拿过来用，不幸的是我们有太多的轮子需要学习。 但是，无论是日常工作还是面试问题，也都符合二八原则。即掌握20%的知识，就能解决80%的问题。 那么，Java程序员必须掌握的20%知识点都有哪些呢？ 个人认为包括以下内容： Java基础知识，如集合类、IO、泛型等。 JVM底层知识，如类加载机制、GC、JVM内存结构等。 Java并发编程知识，如Java内存模型、并发包、线程池、netty等。 开发框架知识，如Spring、mybatis、springboot、springMVC等。 分布式相关知识，如CAP理论、分布式锁、分布式事务、Zookeeper、spring Cloud等。 其他基础知识，编程语言、网络方面、数据库、数据结构和算法。 中间件相关知识，如Redis、rabbitMQ、Dubbo等。 服务器相关知识，如tomcat、jetty、jboss等。 以上这些知识，就是最高频的面试问题，以及工作中需要用到的知识。当然，一个程序员想要掌握以上所有知识，可能需要花费很长时间。这个过程注定是漫长且孤独的。 来源：https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}]}]}