{"meta":{"title":"陈国际博客","subtitle":"人生如戏，全靠颜值","description":"为中华软件之崛起而编程 ,努力做有价值的技术文章","author":"chen guoji","url":"http://chenguoji.com"},"pages":[{"title":"about","date":"2019-04-01T02:10:14.000Z","updated":"2019-04-02T07:25:56.525Z","comments":true,"path":"about/index.html","permalink":"http://chenguoji.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-01T09:15:10.000Z","updated":"2019-04-02T07:24:35.247Z","comments":true,"path":"categories/index.html","permalink":"http://chenguoji.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-04-01T09:16:14.000Z","updated":"2019-04-02T07:23:47.709Z","comments":true,"path":"friends/index.html","permalink":"http://chenguoji.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-01T09:15:36.000Z","updated":"2019-04-02T07:24:21.969Z","comments":true,"path":"tags/index.html","permalink":"http://chenguoji.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"普通二本，毕业三年，北漂之后，我是怎样成为程序猿的","slug":"普通二本，毕业三年，北漂之后，我是怎样成为程序猿的","date":"2019-09-18T02:39:50.000Z","updated":"2019-09-18T09:34:21.294Z","comments":true,"path":"2019/09/18/pu-tong-er-ben-bi-ye-san-nian-bei-piao-zhi-hou-wo-shi-zen-yang-cheng-wei-cheng-xu-yuan-de/","link":"","permalink":"http://chenguoji.com/2019/09/18/pu-tong-er-ben-bi-ye-san-nian-bei-piao-zhi-hou-wo-shi-zen-yang-cheng-wei-cheng-xu-yuan-de/","excerpt":"","text":"写在前面这一次，我想聊聊我是怎么变成一个程序员的。以时间线为主轴，从大学一直讲到北漂结束。 这不是一篇鸡汤文，这是真实的生活，看完以后甚至会觉得很丧，毕竟，生活一直都不是一个水到渠成的童话故事。 如果你想要看到在这个过程中学到了什么专业技能的话，可能要让你失望了，因为全文没有讲任何技术相关的东西。但是如果你有时间看完全篇的话，你会发现，这是我的故事，而里面可能也有你的影子。 这个故事很长，真的很长，从2012年到2019年。如果你读不完，正常，毕竟是人生七年的一个缩影。如果你读完了，谢谢，希望能带给你一点点感动和正能量。 我的热河，就是北京今天是中秋节，在我印象中，这是我第一次和爸爸妈妈一起在家过中秋。 我叫王小白，今年我25岁。 去年中秋节的时候，我还是一个北漂，那一天我站在北京西单的天桥上，看着桥上人来人往，桥下车流涌动，四处洋溢着节日的气息，可惜我无心感受，因为我是一个异乡人。站了很久，我发了一个朋友圈: 2019年4月20日，我离开了北京，带着极度的不舍与不甘。在北京的时候我喜欢上了一首歌叫《热河》。歌词里说: 没有人在热河路谈恋爱，总有人在天亮时伤感 如果年轻时你没来过热河路，那你现在的生活是不是很幸福 纪念碑旁有一家破旧的电影院，往北走五百米就是南京火车西站 每天都有外地人在直线和曲线之间迷路，气喘嘘嘘眼泪模糊奔跑跌倒奔跑 …… 如果年轻时你来过热河路，那你现在是不是已经被他们淹没 没有新的衣服能让你爱恋，总有一种天气让我怀念 醒来或者吃饱又是一年，相遇然后分别就在一天 开始我不知道我为什么听了一遍就爱上了这首歌。后来我知道了:每个人的生命里都曾有过一条”热河”。不论它是叫北京、上海、广州、杭州、深圳、成都…我们都曾离开，回来;或者离开，不再回来。我们都曾跌倒，起来;或者跌倒，不再起来。不论你还在不在你的”热河”，你总是会在午夜梦回的时候，看到你的”热河”的光鲜亮丽、破败不堪、伤痕累累、欣喜若狂、昨日重现、恍若隔世…看到你的青春烙印。我的热河，就是北京。 我的前半个大学—自我放逐，无心学习2012年高考之前最后一次家长会，班主任对我妈妈说:”要最后冲刺了，叫王小白努努力，争取考上本科线。”当然，这话也是我妈妈多年以后告诉我的，她怕当时告诉我，影响了我的情绪。但是高考，是我整个高中生涯考的最好的一次，超过二本线13分。于是我考上了一个非常非常普通的二本大学，那一年，那个学校只有6个本科专业可以选报，于是我把这六个专业都填上了，然后选择了一个“服从调剂”。最后被调剂到最后一个专业—计算机科学与技术。 这个大学叫成都工业学院，我知道你大概率没用听过这个学校，但是​我不想​写成某某大学。因为我真心的感谢并喜欢这个学校，​就当我为学校做宣传了。 在大学的前两年，我没有认真学习。不对。在大学的前两年，我没有学习。疯狂的玩耍，但是那两年，我走过了祖国的很多地方，至少我没有浪费在网络游戏、泡吧追剧里面，所以我并不后悔。 有一次辅导员找我谈话:”王小白，你这样下去，学不到专业知识，毕业以后怎么找工作呢？”.我回答的很迅速:”学了也没用，反正我以后不会从事这个专业相关的工作。”其实我内心很清楚，这就是一种任性且逃避的回答。 但是，在大二快要结束的时候，发生了两件事情。让我的大学生涯发生了180度的大转弯，让我自己都惊讶的改变发生在了我的身上。 大学学习的起点—坚持梦想，看我奔腾第一件是参加学校的编程比赛的活动—奔腾杯。大赛的宣传语就是:坚持梦想，看我奔腾。奔腾杯是我们学校技术含量最高的比赛之一。由于含金量比较高，我开始的想法是跟大神组队，我端茶递水打下手，蹭一个证书。但是，大神都要和大神组队，不带我这样的小白飞！最后，我受刺激了：你们不带我，那我自己搞。 于是我提交了报名表，最后参赛名单公布出来的时候，可以看到，40多个参赛队伍，30多个都是大神组团报名，极少有单枪匹马干的，而我就是其中一个。报名之后，我冷静了：我TM什么都不会啊！ 后来我天天泡在图书馆，下了一套学习视频，一个月后我拿出了一个纯静态网站，只能在我的电脑上演示，因为毫无自适应可言。而那个时候，我甚至不知道还有自适应这个技术。就是在那个月，我每天在图书馆待到22点熄灯的时候，我开始爱上了图书馆。 初赛的时候我看到了别人的作品，感觉每一个做的都比我好。到我展示的时候，讲到一大半，电脑突然没电，我想，这下我是彻底的完了。我说:”老师稍等一下，我去拿下充电器。”老师头也没抬，在纸上打分，说:”不用了。”我听到这三个字，突然就是坦然，我知道这就是淘汰的意思。在来之前我就已经是这个心态了。所以，还好啦。至少我这个月还是学到了好多好多东西。老师接着说:”回去好好改改，半决赛好好加油。”这一句话就像炸弹在我的脑中爆炸。意思是我初赛过了!?四十多个作品，初赛砍掉一半，单枪匹马，我就过了？这是我的大学生涯中，在学习上，第一次被肯定。 初赛过后，给了我们半个月时间准备半决赛。那半个月，我还是在图书馆里面继续学习，但是我的代码，一句未动，一行未改,即使期间冒出过好的想法。因为我想好了，我要放弃了，实力悬殊实在太大。 很快到了半决赛的那天。我展示的时候第一句话是:”各位评委老师，参赛选手大家好，对不起，这半个月，我放弃比赛了。”接下来，我没有讲我的作品，而是讲我为什么参赛，为什么做网站，为什么要放弃。我的最后一句话是:”各位大神，好好加油！我是小白，干不过你们了。”在半决赛结束之后，班主任把我叫住了，仔细的看了我的作品，给我指出了几个修改的地方，说作品看的出来是用心做的，其实还是不错的。之后的第二天晚上，我收到一条短信，大概是这样的：王小白同学，恭喜你进入计算机系奔腾杯比赛的决赛决赛将在活动中心举行 —-计算机系科创部。看到短信的时候，我久久不能平静，内心涌动。 你知道那是什么感觉吗？ 从最开始的想和大神组队，蹭个证书，到自己单枪匹马的杀出一个作品，再到初赛之后的完全放弃，最后，杀入决赛。进入决赛，就有证书。自己真刀真枪夺来的证书。我能进入决赛，有一部分原因是老师暗中相助，老师相助的原因在第二个转折点里面会说明。有一部分原因是我的作品也没有我自己想象的那么差，从布局到设计，从按钮到链接，每一个都是我自己想出来的，全部都是原创。那天我在我的手机便签里面写了一句话： 从此，我的人生中再无放弃二字！ 决赛在活动中心举行，学校办活动规格最高的地方。全系的老师，同学都在下面坐着。到我展示的时候，我简短的介绍了一下自己的作品，主要介绍了我为什么要参赛，为什么做网站，为什么站在了这里。我说:我为什么要来参加奔腾杯的比赛？我就是为了要证明，大神能做到的事情，小白通过努力一样可以做到！今天我站在了这个舞台上面，就是说明，我证明到了！展示结束之后，收到一条QQ消息，是一个素未谋面的学妹，她说：刚刚演讲的是你吗？讲的好好。 奔腾杯之后，我爱上了图书馆，这是我的大学生涯的起点。 走向程序员的第一步—困惑缠身，老师谈话第二件事发生在2014年6月9日。大二下学期一节英语课上，应到48人，实到8人，其中有3个人迟到20多分钟。我很困惑，我到底怎么了？大家到底怎么了？于是，在英语课上，写下了下面的这篇文章。 我是计算机科学与技术专业。上大学两年了，目前为止我学了C语言，C#，C++，java这几种计算机语言，期间夹杂着离散数学，数据结构，数据库，计算机网络等专业课。然后还有去他妈的大学物理，线性代数，数字电路，模拟电路。让我现在都还没有想通为什么我是计算机专业但是还是要花大量的时间去学习与专业毫无关系的课程。 大一上学期，刚刚进入大学，我就是肆无忌惮的到处骑车玩，学的很烂，但是骑了很多地方，多到我现在都记不清有那些了，基本上那一个学期，我觉得我的主要任务就是骑车，我不会打游戏，完全不会英雄联盟，但是每个周末我都在外奔波，甚至把我计划大二骑行的川藏线都搬到了大一暑假，现在想起来都很充实。虽然学的很烂，但是我毫不后悔。 大一下学期，我开始想好好学习我的专业。我开始学习C++，是的，我觉得我应该还是可以学习好这门课程的。但是还有离散，大物，高数等课程让我焦头烂额。更重要的是，我还是没有静下心来。于是，我终究还是没有学习好。于是我总结出来，老师是好老师，学生不是好学生。 大二上学期，开始痛定思痛，决心好好学习java，我那一个学期都对java都有兴趣，我都有认真努力的学习。但是顾此失彼的忽略了数据结构，更重要的是那个学期，独立了一个三班出去，留下了现在的一二班，我现在在英语课上写的这篇文章，两个班来了八个人，迟到3个。那个学期，如果不是java老师，数据结构老师仁慈让我们通过了考试，我敢保证，挂科率至少是我们系最牛逼的。现在让我回想数据结构学了什么，我还真心是想不起来，虽然老师对我们说，这门课程很重要。对于java，期末考试没有看老师给的资料，还是考过了，说明比起之前的语言，我还是学的不错的。但是，java我们只学习了一学期，而且，一本书老师没有讲完。但是，高数我们学了两个学期，大物学了两个学期，电路学了两个学期。 大二下学期，也就是这学期，还有一个月就结束了，就一个感觉，快！就是那句话，时间都去哪儿了？今天上午上网络课，老师说：“今天我们开始复习！”然后我就很诧异，学完了吗？什么时候学完了的？更重要的是，我有上课啊！还有上个星期，C#老师对我们说：“谢谢各位同学的捧场，C#这学期我们就上完了！这是我的闭关课了！”当时两个班去了10多个人（两个班一共43个人。）都很诧异，因为结束的太突然了。 之后有一天，我去图书馆找了我们的班主任，对他说了我很多很多的困惑，他说：“这不是你的问题，是这个教育制度的问题！我知道很多人不想学，老师也不能干预太多了，毕竟是成年人了，以后出身社会谁去管他？大学，主要是靠自己，我在上课我都知道，其实很多人都不懂我在讲什么。很多人也没有听课。老师负责教，学不学是你自己的事情。明确自己的发展方向。对于一二班的情况，老师也不是没有想办法，下学期的专业选修课，我会安排在一起上课的。”反正说了很多，也为我指明了发展路线。对于他说一起上课的时候，本来我想对他说：“晚了！”终究还是没有说出口来。但是真的晚了。 虽然没有清晰的方向，但是至始至终我都没有想过放弃，只是没有目标的坚持，好累。 找到合力的方向，然后走下去。 泰戈尔曾经说过，天空没有痕迹，但是飞鸟已经飞过。但是我的同学们，你自己应该知道，你曾经在这片天空飞翔过。怎么飞翔，你自己决定。 这是一沟绝望的死水， 清风吹不起半点涟漪。 好了，我去图书馆了。 可能和大多数想入门，却还没找到门的小伙伴一样： 最最开始的时候，虽然没有清晰的方向，但是自始至终我都没有想过放弃，只是没有目标的坚持，好累。 如果说奔腾杯是大学生涯学习的起点，那么和大学班主任的那一次谈话，就是我迈向程序员道路的第一步。 三井寿跪着给安西教练说:”教练，我想打篮球.”而我传达给老师的就是:”老师，我想学编程.” 那一次谈了不到30多分钟，正如图片里展示的，他说:大家都是成年人了，大学，主要是靠自己。老师负责教，学不学是你的事情。最后他给我了一套java入门学习资料，里面分为25天课程，平均每天8小时。而这次谈话正是在奔腾杯半决赛之前不久，虽然老师没说，但是我坚定的认为是他让我进入了决赛，因为我让他看到了我想学习的心，而他也想尽可能的鼓励我。 大三上学期刚刚开学的时候，消化完那一套课程，是我当时的目标。有目标了，就像在迷失在大海里面水手，突然看到了灯塔一样。已经迫不及待了，所以暑假我提前了几天来学校，一头扎进了图书馆。那套视频，我在图书馆一共完完整整看了4次，跟着讲师敲了4遍。每天早上9点之前进馆，晚上10点出馆，回到宿舍继续学习，去掉吃饭，休息，上专业课的时间（非专业课我已经不去上了）。我进入高强度的学习状态，拒绝了所有可以拒绝的无用社交，每天的有效学习时间在10小时以上。每天回到宿舍都可以看到自己青黑的眼圈，浮肿的眼袋，起了水泡的嘴角。我觉得这个阶段是每一个想要通过自学进入到计算机行业的人都必须经历的一步： 在这期间，我无数次的处于崩溃的边缘，无数次的强打起精神，无数次的敲击着键盘，无数次的自我怀疑，但是没有一次想要放弃。 三个月之后，我终于吃透了那套视频，算是java的入门选手了。并且养成了自学的好习惯，我整个大三基本上都在图书馆。把前两年落下的东西，全部学了回来，并且提前把大四的专业课程自学完毕。于是大三最后一个学期的暑假之前，我又去找了班主任，说:”老师，我大四的时候想实习，如果你有实习机会的话给我介绍一个吧，我可以不要薪资的。”老师说:”暑假早点来学校，我这边刚好有一个机会。” 走向程序员的第二步—薪资800，开始实习2015年7月23日，暑假后的第7天，我回到了学校。开始实习。 这次为期5个月的实习，是我走向程序员的第二步，也是最关键的一步。经过一年的自学后，我只会写一些孤立的小程序，完全没有工程化项目的概念。 那个时候，我距离java开发工程师就差一次完整的项目实战经验。 所以我真的很感谢老师给我提供的实习机会，让我向一个完整的程序员又迈进了一步。 而且我说的我不要工资，但是老师还是给我发了一个月800元的实习工资，在我结束实习的时候还一次性给我了4000元项目奖金。 在实习期间，我快速的学习到了很多的知识。最重要的是我遇到了一个对我很好的同事，他大我一届，比我多一年的工作经验。但是他把他这一年学到的东西，对我倾囊相授。也是他告诉我： 每一个程序员，都应该有一个北上广的梦想。 当然，期间也遇到了各种各样的问题，毕竟经验不足，难以应对，比如这种情况就经常出现: {% asset_img 5.jpg %} 2015年12月31日，我结束了为期5个月的实习。 走向程序员的第三步—正式上道，决心北漂2016年春节期间，我接到了老师的电话说：”我手上现在有一个新项目，需要找人开发，你之前实习表现得还不错，这个项目你愿意试一试吗?一个月3000元钱，餐补另算。计划做三个月，刚好不耽误你毕业。”我果断的答应了。 {% asset_img 6.jpg %} 答应之前，我根本没有想到，这就标志着我大学生涯的结束。更没想到，这段经历，直接决定了我要去北京，也为去北京奠定了一点的技术基础 总之，2016年3月，大四下学期，学校已经没有课程，只有一个毕业设计，我开始正式的上班了。 正式工作后的生活和当学生时的感觉完全不一样。但是还是和实习的同事一起工作。 有一天他对我说：”这个项目做完之后，我就要去深圳了。每个程序员，都应该有一个北上广的梦想。” 那一刻，我也开始想，我是不是也应该去试一试。 2016年5月26日，我的毕业答辩结束。那天晚上，我思考了很久，接下的路应该怎么走。 {% asset_img 7.jpg %} 一直思考了两天，因为这个决定太重要了,直接决定了我以后的人生走向。到2016年5月28日晚上，我写下了这三条路： {% asset_img 8.jpg %} 第一条，从7月份开始准备12月份的考研，问了很多有考研经历的同学和学长，综合各方意见，觉得时间还是太短。不考虑了。第二条，直接开始工作，不再考虑考研的事，但是，一定要去一线城市。第三条，在成都先工作半年，然后准备17年的考研。 2016年5月28日晚上，我最后倾向于了第二条路。我的人生轨迹在2016年5月28日晚上有一个明显的顿号，这个顿号关于三条路的慎重思考。 时间来到了7月份，项目也已接近尾声。2016年7月6日，项目我负责的部分完工。我正式离职。在这期间，对我是否要去北上广，我一直犹豫不决，但是潜意识里是想去的。于是我逢人就说，我毕业之后要去北上广，因为我怕自己怯弱了，但是自己又放话出去了，不去丢人。 2016年7月7日，我在知乎上提了一个问题如下： {% asset_img 9.jpg %} 这个回答说: 去都没去怎么逃离，一定要先去看看，逃不逃之后再说。 于是我终于决定出发了，我要去北京，我要当个北漂。 怀揣6544元，开始北漂2016年7月20日，毕业一个月后，开始了北漂。大四实习之后，再也没有找家里要钱，买完去北京的机票之后，我还剩下6544元。 {% asset_img 10.jpg %} 到北京的那天，我下载了记账软件，记了第一笔账： {% asset_img 11.jpg %} 那天北京下着大暴雨，虽然打着伞，但是等我上公交车后，鞋子已经完全湿透了，衣服贴在身上。到了大学朋友震宇兄那边，他在地铁口接我，请我去吃了一碗面，他是山东人，他说这是他们的习俗：“送行饺子接风面”。 来北京的前九天，我面试了九家公司，几乎每一个面试官都问我:成都多安逸啊，你为什么来北京？我说：就目前而言，过得舒服并不是我最重要的事情！所以，我选择来北京。还问我只身来北京，没有顾虑吗，怕吗？我说：怕，怎么不怕，但是怕了就不来了的话还是年轻人吗？况且我还有这么了解和支持我的家人。 2016年7月29日，收到了一家支付公司的offer。我在我的手机便签里面写到: {% asset_img 12.jpg %} 现在看来，北京，确实让我脱胎换骨了。 北漂—关于租房的事2016年8月1日，我到公司报到的第一天，北京已经开始炎热了起来。 面试期间我都是在震宇兄家里住。这家公司提供住宿，于是我先背了一个薄薄的被单来报道。等到下一个周末再去拉行李箱。 晚上同事把我领到宿舍的路上给我说:你要做好心理准备，由于我们的宿舍在老北京的胡同里面，虽然是二环内，但是房间里面的卫生间只能上小号，大号的话得下楼，去楼下的公用卫生间。由于是男生宿舍，卫生条件可能差点。于是一路上我都在做心理建设，但是看到房间的第一眼，还是给了我一定的视觉冲击：极度的脏乱差，到处都是灰蒙蒙的，地板上踩起来甚至有点黏黏的。 那是一个三室没有厅。我住的那个房间，由于没有空调，特别的炎热所以一直没有人住，但是有个好处是可以一个人住那个房间，其他的房间里都需要住2人。 那天晚上，我正坐在床边想着我一定要出去租房子住，这个地方只是临时落脚。妈妈给我打电话:问我宿舍怎么样。我开口先说到:”还是挺不好的，我想出去住。”后来转念一想，这样说家里人肯定担心，于是紧接着说：”没事，我先住着试一试，一个人一个房间还挺好的。房间空间也特别大。有个风扇，也不会太热”。其实，那个房间里面，除了一张1.5m的床，一个矮矮的电视桌，一个不能摇头的电风扇，剩下的就全是灰。 那天晚上我在床上裹着自己背来的薄毯子，没有枕头，就枕着自己的书包，算了一下我身上的钱，打消了出去租房的念头。但是并没有气馁，最难的已经过去了，所以内心的喜悦远大于这个小插曲带来的惆怅。我能感受到，北京就像一幅画，一幅《千里江山图》那样，举世无双的画，正在我面前徐徐展开。 如果算上从震宇兄家搬到公司宿舍那一次，我在北京期间一共经历了3次搬家。 2016年11月19日，星期一晚，北京西红门聚福缘公寓大火。19个人在大火中遇难。遇难者中8个是儿童。8人受伤。之后，北京各种整顿，各种地毯式安全大检查，各种拆。查到不合格的，政府给三天时间搬离，否则停水停电停暖气。这就导致出租房的供需不对等，你可能上午看的小单间还是1500元，下午去的时候就变成了2000元。要不给钱，要不睡街头，北京的冬天很冷。没有其他地方给你缓冲一下。工作日，你也没有那么多的时间去找房子。我在北京，我深知找到一个比较合适自己的出租房是多么的不容易。更何况是在天寒地冻，燃眉之急的情况下。还有一部分人，失去栖身之所，只有放弃工作，踏上返乡的列车。讽刺吗？让他们离开北京的不是自己不想待了，而是没有落脚的地方了。当偌大的北京，连一个落脚的地方都没有了，回家的念头也就在脑海里闪现了出来。他们一定还记得自己多年前来北京的伟大抱负，豪情万丈。也许他们离开家乡的时候，和我离开学校的时候说了一样的话：混不好我就不回来了。现在到了离开的时候，自己却是被“驱逐”的，是的，北京的“驱逐低端产业”。 北京，每年2000多万人继续漂着，因为梦想还没有实现。 北京，每年几十万人离开，也因为梦想还没有实现。 北京欢迎你，却也从不挽留你。 而由于这次的大火，公司迫于政府的压力，决定宿舍租房合同到期后，不再提供宿舍。 于是，次年8月，我迎来了在北京的最后一次搬家。通过中介找在了新宫地铁附近。同事8月中旬爆出自如甲醛房事件，我们搬过来的房子也是刚刚装修好的，所以请了第三方机构过来做空气质量检检查。在第三方机构来之前，我感觉这个房子肯定是会超标的，因为是新房间。当时我就想，如果超标了的话肯定是不能继续住了，但是我一时也找不到合适的地方，突然回家的念头在我心里一闪而过。真是讽刺，让我离开北京的理由居然是甲醛。后来检测报告出来了，还好，都在国家标准线之下。 {% asset_img 14jpg %} 北漂—转正申请在这家公司干了三个月后，我转正了。我写了一份转正申请如下: 尊敬的领导：我是产品研发部的王小白，于 2016 年 08 月 01 日正式进入公司，担任软件工程师一职。我是一个人南方人，在我人生的前 22 年，我从来没有来过北京，甚至对北方都没有太大的概念。在我人生的前 21 年，我也从来没有想过我要来北京工作。我在成都读的大学，天府之国，那里有很多朋友亲人，川妹子也很好看，也有很多好吃的，在学校附近 10 元钱就能吃个大份盖浇，肉多，饭还可以无限加。很多大学同学都留在了成都工作，他们说他们习惯了成都慢悠悠的生活。我开始也是这样想的。直到大三的某一天，我在知乎上面看到了一个话题《为什么现在很多年轻人愿意到北上广深打拼，即使过得异常艰苦，远离亲人，仍然义无反顾》,其中很多回答都深深的刺激着我，我突然明白如果人生只是追求 10 元钱的肉多还可以加饭的盖浇的话，那么几十元的卤煮怎么办，上百元的烤鸭怎么办？至今我都记得一个答案：我有个发小，问他为什么留在气候差的北京。他说：“黄沙万里觅封侯。”那个时候毕业去北京的想法便开始在心里肆意生长。我对自己说：每个程序员都应该有一个北上广的梦想。在大学的最后一年里，我默默的为着来北京做好各种准备。毕业之后来了北京，只是来北京的那天下暴雨，一来就漂起来了。然后，我来到了公司。8 月进入公司的那一天刚好是 8 月 1 日，开月度会，然后我看到的全都是一群年轻人，我就知道我来对地方了。月度会结束之后，就来到了产品研发部报道，加入了交易组。在这里，开发软件用的是 IDEA，而在这之前，我一直用的 eclipse 开发。版本控制工具用的是 git，在这之前我用的是 svn。开发软件的变更应该算是我遇到的第一个问题吧，刚刚使用 IDEA的时候，感觉特别不顺手，感到了一点压力，但是人在压力下学习东西是非常迅速的，所以，不到一周的时候，IDEA 就上手了。同时接到的第一个开发任务就是编写公众号交易的查证补单接口。然后就是这第一个开发任务，由于分页的逻辑问题，导致影响了之后的一次上线事故的问题排查。那是我第一次经历上线事故，感受到了肩上的责任。之后，我对自己的代码是慎之又慎。9 月对交易组现有业务系统中的公众号，卡牌有了一点的了解，参与了公众号对接新渠道和卡牌系统的维护开发任务中，更深层次的理解到了公司的部分业务。还记得第一次对接的是支付宝的渠道，和同事一起开发，调试，期间遇到了各种各样的问题，很多关键问题在阳哥的指导下，能够得到顺利解决。还记得有个问题：拿到了支付参数，但是在支付页面始终不能调起支付，我们从头开始排查，排查到很晚也没有找到原因，由于时间太晚了，然后我们就回家了。第二天，再次排查代码的时候，才发现在调起支付的页面有一段代码中的tradeNo应该改成tradeNO！就是因为一个字母的大小写的问题，导致我们排查了很久很久。现在想起来，还记得当时调起支付页面后的高兴和无奈。编程，是一件严谨的事。这个月中学到了很多编程技巧，也学到了优秀的编码风格和编码思想。在之前，我总是想的如何把功能实现，而现在我在实现功能的基础上考虑到代码风格、性能优化。10月10月份的时候，对卡牌系统了解的也有七七八八了，所以卡牌基本上就交给我在维护了。然后对接应用中心，对接各种渠道，对接风控，广告位开发等等开发任务也能按时完成，完成开发任务之后，也会开始一点点的重构代码，看看哪一块的性能还能提升，能不能加点缓存技术，提高访问速度。由于能够独立进行开发任务了，所以这个月也算是完成了一个从学生到社会人的转变。思想状态也有了很大的提升，遇到问题不会总是感觉无从下手，以前的第一反应是寻求帮助，现在的第一反应是思考引起问题的原因可能是哪些。 在试用期阶段，我得到了很多人的帮助，特别是我所在的交易组，他们对我的理解，宽容，引导，保护。让我真真的体会到了公司的企业文化“简单，勇敢，温暖”!比起三个月前的自己，从各个方面我也得到了质的飞跃。这一切的改变都是公司带给我的。在写这份转正申请之前，我就在想我转正之后，正式成为公司的一员的时候我会怎么样。我不能给出一个确切的答案，但是我想在公司的每一天都应该是努力的，奋斗的，美好的。在来北京之前，在我想象中就有一个北京大概的样子。但是那个样子不是那么真切，他有点模糊。直到遇到了公司，一切都变得明朗起来。我想象中的北京，就是公司的样子。所以，我提出转正申请，希望自己能成为公司的正式员工。望领导予以批准。—2016年11月13日 从转正申请中可以看出，我刚刚加入这家公司的时候工作的也不太顺利。很多东西都是第一次接触，第一次接触到IDEA，第一次接触到git，正如我之前的文章《Dubbo 2.7新特性之异步化改造》中的描述，甚至连Dubbo都是第一次听说。分布式相关的技术无限趋近于零。 北漂—在北京的日子我在北京一共漂了1003天，近三年的时间。我在北京只就职过一家公司，我在这家公司工作了991天。 我非常喜欢这家公司，这是一家年轻而富有朝气的公司。我所在的支付组，每一个人对我都很好。 我刚刚加入的时候支付组一天的交易笔数只有几十万笔。随着公司的高速发展，交易笔数稳步上涨，最后稳定在了一天800万笔左右。业务的增长，推动着技术的增长。在这个期间，我汲取到的知识和积累的经验，是海量的。可以说短短不到三年的时间，我经历了传统公司可能要花十几年才能走完的路。 为了跟上公司的发展速度，我也得不断地学习，在北京也没有什么社交。于是我每个周末都在学习，真的是每个周末都在学习。用学习来抵抗我的焦虑。当然带来的成果也是显而易见的，我的技术开始突飞猛进，甚至可以用技术爆炸来形容。当我去北京的时候，我还是一个初入江湖的毛头小子。当我离开北京的时候，我已经可以带领一个小团队冲锋陷阵了。 入了这个行，我必须得时刻保持学习。当然，我指的学习不一定全是学习专业知识，我也会看一些文学巨著，历史长篇，经济学读物，工具类图书。当我停下学习的时候，我就会焦虑。 适当的天气我还会出去跑步，在北京我报名参加了三次北京马拉松。而且我跑完北京的一环到四环，骑共享单车骑完了五环。每当我回想起这件事，我就会觉得，我的脚步包围了整个北京。我在北京用力的生活过。 关于生活方面，最开始的时候，我在北京基本上每个月收支平衡。我每周逛一次永辉超市。有一次我看见一个酸奶，感觉特别好喝，我特别想买，但是它超出了我的预算。其实没有超多少，但是就是超了，那我就觉得不划算。以后的每次逛超市，我都要去看一眼，那个酸奶有没有打折，很遗憾，每次都没有。一直到有一次我涨工资了，涨了很多。发完工资的那个周末，我终于买了那个酸奶，喝了一下，真的很好喝。但是那个周末的再下一个周末，我的房贷批下来了。我每个月又要开始还房贷了。之后，我再也没有喝过那个酸奶。也没有去关注过它的价格。我不知道你这辈子有没有为别人拼过命。但是我为了那个酸奶，是经历过强烈的心灵挣扎。 后来，每当我在北京感到艰难的时候，我就会想起那个酸奶，它能激励我前进。我也会去西单的桥上，看人来人往，告诉我自己：王小白，你在北京只身一人，一无所依，你必须靠你自己杀出一条血路来。2019年3月12日，我感觉到我可能要离开北京了。那天我下班后，又去了西单的那个桥上，我想要停下来，让我的生活停下来，给我更多的时间思考。但是现实却反复的打我耳光，让我不再幻想，推着我前进的不仅有梦想，还有房贷,我在手机里写下： 但是，在北京大多数时间都是开心的呀。比如其中一件是我买到杰伦《地表最强》演唱会的门票。我小时候的愿望就是希望自己以后用自己挣的钱，去听自己最喜欢的明星的演唱会。我在北京做到了： 北漂—留在北京有一天一个不胜酒力的同事喝了一点酒，我送他回家的路上，他给我说: 你呀，一点要拼尽全力，拼死拼活的留下来，留在北京!留在北京了，你们家族，从你这一代开始，就光宗耀祖了！ 我当然知道，他说的意思，要是能在北京留下来，我的下一代，能享受的教育资源是四川不能比的。在北京的学生，上午在语文课本里面学到了故宫，下午就可以全班游览故宫。上午在历史书里面学到了司母戊鼎，下午就可以去国家博物馆，亲眼看看。……千言万语，抵不上亲眼所见的。他们享受的教育资源，是十分优越的。 对四川的学生来说，是拼命读书，改变命运。对北京的学生来说，是认真读书，改变命运。 再说一个现实的问题，北京的房子，靠一个人那点工资，杯水车薪。 结束北漂由于一些家庭的原因，我离开了北京。我离开之前和各级领导谈的时候，他们都有一个观点： 虽然很想让你留下来，但是当面临着家庭和工作两难的抉择时候，我作为过来人，建议你多考虑家庭。你的决定没错。 2019年4月14日，我在北京的最后一个周日，我请震宇兄吃了个饭，理由就是“送风饺子迎风面”。他送了我一本书。地铁上分开的时候我抱了一下他，说:下次再见不知道是什么时候了。他说:别这样，还会再见的。 2019年4月17日，公司每周三组织球赛，那天打完之后杨哥请了我们吃饭，为磊哥和我践行。吃完之后我对磊哥说:再好好看看这个地方吧，可能这辈子都不会再来了。 人都是这样，以前时间多的时候觉得什么事都还早，都还有机会。等到真真的到最后一次的时候才会去感慨。 就像离职之前的”散伙饭”一样。我说，这顿饭之后，这辈子也不可能把在座的各位都聚在一起吃饭了。听着挺唬人的，但是仔细想想，高中毕业的时候也说过这样的话，大学毕业的时候也说过这样的话，对后来的人生造成了什么影响了吗？并没有，吃饭不重要，重要的是我们静静的躺在对方的朋友圈里，看到你发关于生活的动态，不管是结婚、生子、晒娃……我都会会心一笑，然后点个赞，时不时的再评论一个。知道你过的好，这就够了。吃饭见面，都不必强求，缘分到了，自然水到渠成。 2019年4月18日，我在北京的最后一个工作日，我走的那天，去研发部找领导签字，研发部60余人，每一个人我都认识，每一个人我都一一告别，握手拥抱。办完离职后，我团队的小伙伴们都在会议室里开会，我说:我走了啊，谢谢各位这几年的陪伴，大家加油啊。其实我准备了一大段话要说，但是一看到他们每一个人的脸，刚刚说了第一句话，就红了眼眶，我不能再说下去了，于是转身离开了。 晚上，亮总请我吃饭， 吃完后已经是深夜，分别之前他给我提了很多宝贵的建议。我握着他的手，听着听着就流出了眼泪，最后抱着他哭了起来。久久不愿意松开，因为我知道，他是我在北京抱的最后一个人，松开之后，遇到的每一个人都是陌生人。 2019年4月19日，我25岁生日，我离开北京。在这一天离开，完完全全是一个巧合，没有刻意安排。如果用宿命论的观点来说的话，这可能是宿命送我的一份生日大礼。 你好，成都在北京期间我回成都了一趟，用3天时间面试了6家企业。拿到了4家的offer。其中一家给到了2w，但是我拒绝了。因为我回来最想进的一家公司也给我发出了offer。这家公司能让我不脱离支付行业。我不能浪费北漂这几年积累的支付领域相关的知识。放在几年前，我肯定会面向工资编程。当然，几年前也不会面临这样的选择。这些都是北漂带给我的。 {% asset_img 18.jpg %} 刚刚回成都的时候，早上起来，有几次以为自己还在北京。有时候给朋友讲起北漂的一些经历，感觉像是一场梦，或者是别人的故事。 之前看到一句话:北漂就像在黑屋子里洗衣服，你不知道洗干净了没有，只能一遍又一遍地去洗。等到离开北京的那一刻，灯光亮了，你发现，如果你认真洗过了，那件衣服光亮如新。让你以后每次穿这件衣服都会想起那段岁月。 我十分感谢那个当年一直逼自己来北京的自己，这几年，我认真洗了，离开的时候光亮如新。 今天是中秋节，如果你在外漂泊，那我祝你留下来，或者早日荣归故里。如果你在家团圆，那你不需要我的祝福，请你祝福你只身在外的好友吧。 以上。 作者：why技术https://segmentfault.com/a/1190000020377011","categories":[{"name":"经历","slug":"经历","permalink":"http://chenguoji.com/categories/经历/"}],"tags":[{"name":"经历","slug":"经历","permalink":"http://chenguoji.com/tags/经历/"}],"keywords":[{"name":"经历","slug":"经历","permalink":"http://chenguoji.com/categories/经历/"}]},{"title":"Financial Software Systems校园面试经验","slug":"Financial Software Systems校园面试经验","date":"2019-09-01T02:39:50.000Z","updated":"2019-09-03T07:16:23.479Z","comments":true,"path":"2019/09/01/financial-software-systems-xiao-yuan-mian-shi-jing-yan/","link":"","permalink":"http://chenguoji.com/2019/09/01/financial-software-systems-xiao-yuan-mian-shi-jing-yan/","excerpt":"","text":"财务软件系统访谈经验| 第1集（校园内）最近，Financial Software Systems访问了我们的校园进行招聘。基本上有4轮： 第一回合这是一次在线能力测试……有60个问题必须在60分钟内完成。大多数问题都非常简单。 大约有600名学生参加了下一轮的204名学生入围。 第二轮第二轮是小组讨论。主题是外国直接投资，社交媒体等一般性主题，私立大学是否应由印度政府接管等。对于大多数人而言，GD不是淘汰赛。GD 190的学生们进行了技术面试。 第三轮对我来说，问题是关于Java，数据库，C ++（基础知识）。一些问题是： SQL中不同类型的Join，C ++和Java之间的区别，c ++中继承中使用的运算符的名称等等。如果你能够清除第三轮你几乎已经完成……。下一轮更像是一个正式轮次，其中包括我向面试官提问。 HR Round最后，发生了HR轮次，其中包括典型的HR问题。最后25人从我的大学中选出。一些提示：1。公司与新生有3年的服务协议。2.自己参加面试3.有信心并了解基本知识","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"运营学习的小总结","slug":"运营学习的小总结","date":"2019-08-21T02:39:50.000Z","updated":"2019-09-03T10:00:24.968Z","comments":true,"path":"2019/08/21/yun-ying-xue-xi-de-xiao-zong-jie/","link":"","permalink":"http://chenguoji.com/2019/08/21/yun-ying-xue-xi-de-xiao-zong-jie/","excerpt":"","text":"作为一个4年的程序猿来说，运营之前给我的感觉就是“提需求的一类人”，对于产品啊、运营啊、市场等，都被我划到了一类，可见我对于他们的工作认识有多简（wu）单（zhi）粗（xiao）暴（bai）。 现在，通过一段时间的学习，我对运营，有了一个新的认识，它对于我来说，不在简简单单是一个名词。下面，我来讲一下，现在，我眼中的运营。 运营的定义运营就是互联网环境下，为了获得用户增长，做好用户维系，提升收入，我们所需要的一切手段。通过这个定义，你知道运营是什么了吗？ 哈哈哈哈哈，是不是 安了安了，解释不会仅仅只有这个的。 运营的日常工作比如说公司做教育的，他有学员来听课，这个时候，就需要有个类似于班主任的一个人，来对一个班级的学员进行管理和维护。像在班级群里发布一些群规，发一些通知，比如课程时间啊，作业啊什么的。如果学员遇到问题，要及时进行问题解答或者1对1的沟通等。 比如新媒体运营小编的日常工作，在微博啊，公众号啊，知乎啊等各大平台上去发表一些文章。找到一些有趣的话题，去给到客户，与客户互动；寻找内容、创作、排版后发布，让更多人阅读和传播等。 比如产品内部运营，像app内，将产品进行特色规划，制作专题区域，像活动专区，新品专区，恶搞专区等等，将产品二次归类，寻找特定位置，引导客户使用。 比如活动运营，日常工作包括策划、构思活动主题，活动要以什么样的方式进行，考虑活动的时间，地点，规模等，最终将活动落地实施，来获得用户的参与和关注，想之前我参加过的自如的免费观影活动。 说到这里，应该对运营有了一个大概的感觉了吧？ 运营的职业分工一般来说，运营分为以下几类： 内容运营内容运营是指通过创造、编辑、组织产品的内容，并将合适的内容推到合适的用户去使用，从而制造出对用户的拉新、留存产生一定的正面的作用。平日的主要职责就是对产品内容的数量，话题访问数，站内热门话题的审核推荐等负责，定时的更新、筛选、生产内容或刺激用户生产内容等。 活动运营活动运营是指通过制定一些活动策划，如线上的拉新活动，线下组织一些社团活动等，并且通过这些活动，来刺激用户，进而获得可观的正向反馈。不管是日常活动，还是特定时间内的时效性大型活动，都属于活动运营的工作范畴。 用户运营用户运营就是指对于特定一群用户，进行有针对性的管理和维系，以活跃、留存、付费为目标，结合用户需求，去制定一系列方法和机制。在不同时期会有不同工作重点，比如初期，就是引入新用户并且寻找优质客户，中期会更偏向于用户黏度的提高，后期就是付费和持续付费的引导。 渠道（推广）运营渠道推广运营的职责就是负责流量引入，并对引入的数量和质量进行优化。渠道推广运营的工作就是对接各种渠道，并熟悉各种渠道的变化和使用方法。 当然还有很多，像新媒体运营、社区运营、产品运营等。 运营人的职业发展大概知道了运营是什么后，那么如何从运营新人成长为一个专家级别的运营呢？ 一般来说，都会经历这么五个阶段：小白，初级，骨干，专家，高级。每个阶段，要具备的能力和所做的事都是不一样的。 小白阶段：新人小白是指刚入门运营、零经验的人。这个时期的工作内容相对来说偏体力活，基本上是一些执行打杂的事情。能力方面可以有空白区，但是需要有较强的学习能力，执行能力和逻辑分析能力方面上，需要不断的锻炼，多做多思考多总结来提高自己的行动力和执行力。 初级阶段：对于这一阶段的工作人员来说，执行力和逻辑分析应该达到一定水平，并且已掌握了一定的专业技能，比如文案，策划等。在工作上可以慢慢独立负责一些小项目，并对项目的整体完成度负责。这个时候可能对于用户分析，行业分析，业务分析这些能力的要求会加大，需要多积累相关知识进一步提升自己。 骨干阶段：这一阶段一般要求对一两项技能达到专精的程度，在工作上能对业务对产品有了一定的理解，思维方法和宏观逻辑有了一定提高，开始可以负责一些数据、思考策略了。这个阶段的要求更多的是在管理能力以及复杂问题的拆解上，此时的学习应该多体验多分析产品及用户，从多维度去思考问题，各种业务都了解，做到相对无短板。 专家阶段：这一阶段一般就可以开始带团队，独立运营策略并推动完成了。这个时候的横向能力也需要达到一定高度，比如行业感知、对于运营各个模块之间的认知、对于业务流程的整体感知，这一阶段的学习，可能更多的是领导力、管理能力的提高以及体系化的思考，多积累各个行业的知识和新的运营方法的学习，建立自己对运营的理解。 高级专家阶段：这一阶段一般是指各方面能力都很出众的人，可以说是一个全面性人才。这一时期的学习，主要是整体的策略的理解、制定、施行，引导力和领导力的突破，这些一般都是靠时间积累起来的，需要更多的见识和思考，把自己的格局提高。 以上是我这段时间的学习总结，目前，我还是小白阶段，需要更多的学习和实际操作，用老师的一句话来结尾： 知识可以被学会，而技巧只能被习得！ 来源：https://www.jianshu.com/p/a630fa6a677a","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"我用50W+年薪的独角兽offer，犒劳自己一年的卧薪尝胆！不服输，你就不会输","slug":"我用50W+年薪的独角兽offer，犒劳自己一年的卧薪尝胆！不服输，你就不会输","date":"2019-08-11T02:39:50.000Z","updated":"2019-09-03T08:20:30.542Z","comments":true,"path":"2019/08/11/wo-yong-50w-nian-xin-de-du-jiao-shou-offer-kao-lao-zi-ji-yi-nian-de-wo-xin-chang-dan-bu-fu-shu-ni-jiu-bu-hui-shu/","link":"","permalink":"http://chenguoji.com/2019/08/11/wo-yong-50w-nian-xin-de-du-jiao-shou-offer-kao-lao-zi-ji-yi-nian-de-wo-xin-chang-dan-bu-fu-shu-ni-jiu-bu-hui-shu/","excerpt":"","text":"写在前面： 首先做个自我介绍，楼主男，渣本毕业，坐标帝都，差 4 个月 4 年工作经验。本次面试了几家独角兽和一线大厂，都拿了offer，几乎100%的命中率。 在整个面试过程中，石杉老师的指导给了我很大的帮助，因此将此次面试的经历以及个人学习方法通过老师的公众号分享出来，希望能帮到咱们更多的程序员兄弟。 首先想说说我写本文的思路，很多朋友的面经可能是自己的一些经验之谈，也可能是一坨很长的各个公司遇到的面试题 我很了解大家的这种诉求与渴望，毕竟自己也看过N篇面经。然而，并不是说你看了这篇文章就可以立刻变强，饭要一口一口吃，路要一步一步走 下面的内容第一部分是经验+学习方法，第二部分是如何准备你的面试 我的复习历程： 阶段一（学习方法之“记忆宫殿-联想记忆”）： 在我一年前给自己定下要去XX公司的目标之后，不间断的准备了一年 这一年中，我到处在知乎，脉脉，各种技术群中搜寻着别人的面试题，然后看，做，遇到不会的去查阅资料进行回答，然后储备到自己的知识库里…. 一年多下来，据不完全统计，我看过的面试题可能超过上千道，一个惊人的数字（所以现在别人问我一个题目，基本上都能回答出来） 当然，一年之中的周六日大部分时间都是去公司学习，平常的节假日回家之后当然也是看书和学习，工作日一般会下班之后到家抽出1-2个小时继续学习 这一年中我读了大概六七个框架的源码，看了不少的书，所有的学习视频都是两倍速的速度来训练 有些人看到这里会觉得很疯狂，两倍速听课？语速这么快你听得懂么？ 这个其实也是训练出来的，一开始是1.2倍，到1.5倍，到1.8倍，到最后的2倍，再快的话声音就会失真了；当然读书的速度也是成倍的提升，我记得在机场候机的两个小时刷完了一本书； 依稀记得过年的几天假期也仍然保持着一天至少6个小时以上的学习时间，导致一些亲戚朋友过来串门的时候都觉得我很冷漠，不理别人。 当然这不算什么，因为周围遇到的几个人会更拼，有些人工作日一天持续3-4个小时学习，非工作日10个小时，有些人甚至一天可能只睡4-5个小时的时间….. 正所谓 取法其上，得乎其中；取法其中，得乎其下，这一年的成长远超过我前两年浑浑噩噩的工作及生活。 tips：我当年考驾照的科目一也是这样，一晚上刷了上千道题目，第二天去考试，你可以理解为题海战术 但不仅仅是题海战术，这个时候我引申出我的学习方式的第一大杀器—-“记忆宫殿”之“空间联想” 我其实高中甚至大学的学习方法很烂，因为一直找不到我自己的学习方法，都是题海战术，靠熬夜，靠多写题目去和别人拼 后来发现成绩并没有提高，当时的我多渴望有人直接告诉我一个完美的学习方法，那我直接按照做就好了，然而事实是我在毕业之后，工作的时候才真正找到了属于我的学习方法。 所谓“记忆宫殿”之“空间联想”，并不是像卷福那样把知识点都放在脑子中，想像成自己熟悉的各个地方存放 我这里的“记忆宫殿”也是脑海中的一片连续的内存空间，像数组一样，这时候我每吸纳一个知识点，我会立刻在这片连续的内存空间中找到能和这个知识点强引用，软引用，弱引用关联的地方，将他们像树形结构一样串起来 所以当我以后想到一个知识点之后，我会立即联想到与他各种关联的知识点，脱口而出的不再是某个单一的知识点，而是既有水平横向的对比，又有纵向垂直分析的过程。 上述描述可能会有点抽象，我举一个例子： 假设我现在脑海中有一个知识点（为了通俗易懂，我的例子尽量平易近人），这个知识点是这样： 一个结构CopyOnWriteArrayList，基于一把独占锁的读写不互斥的线程安全的结构 [不清楚的可以专门看一下源码或者找网上博客去看一下] 而这里我们要汲取的知识点并不是它作为一个结构被我们记住，而是它其中的思想（写时复制），所以每次当我听到COW这个东西，我大脑中的那COW一片区域会有大量相关的知识点出来 比如redis的RDB主从复制也是用的COW这种思想，说白了是一个快照的思想 而我这时候突然又提到了“快照”，这时候脑袋中的知识点很快的将关联的mysql的MVCC涌现出来 就这样一层关联一层，错综复杂，层峦叠嶂，但也丝丝入扣，环环相连，成为一颗不断壮大的知识树…… 阶段二（学习方法之“口若悬河-刻意练习”) 上面说过了第一阶段其实已经把自己的目标定下来了，但是遇到一个很现实的问题： 你所有遇到的面试其实都是一个和别人交流的过程，你必须将自己的优势完全展示出来，并且是让人能听的简单易懂的方式 所以第二阶段的“刻意练习”分为两部分： 第一部分我会将自己学到的知识点刻意拿出来和别人讨论，比如同事，比如在一些技术群 这样不仅在交流的过程中，你会发现自己哪里说的不够严谨，不够规整，不够深入，或者说别人也会依据你所说的提出一些问题，如果你不能游刃有余的回答出来，说明这个知识点掌握的还是不够好； 第二部分其实就是“技术分享”，在团队中技术分享，或者参加线下的技术分享 这里有个好处就是，当你进行技术分享的时候，你会带着压力 你必须不仅仅是分享这个知识点，他相关的点，他横向涉及的点，以及你分享过程中别人会提问你的点，还有如果将这个知识点讲给一点都没接触过这个知识点的人等等 分享一次挑战难度会非常的大，你必须花十倍百倍的精力去准备一场面试分享 后来面试的时候发现，这其实也算一个加分项，你说你进行过技术分享，有时候别人会让你聊聊，甚至让你再进行分享一次，别人会觉得你是一个热爱技术，愿意进行交流的人…… tips: 一些技术氛围比较好的技术群里面大家会经常讨论一些生产上遇到的或者面试中遇到的问题。 这时千万不要视而不见，参与进去，说出自己的想法，并且和别人讨论，让被人给你进行纠正等等，时间长了也是一种变相锻炼的过程 阶段三（学习方法之“兵临城下-三轮决战”）： 我是裸辞，所以各位朋友们，搞清楚自己目前的状态，好好分析自己的状态，我分析了一下自己的情况： 1.没有经济压力 2.回家去家里附近的图书馆复习准备一个月，只管复习不用去考虑别的什么杂事 每天起很早开车去图书馆占座，八点到图书馆的时候，一层就已经排了将近200个人的队伍，等八点半正式开门，我们就蜂拥而上，冲进去抢占座位 我30天时间只有两天没有抢到座位，又返回家中去学习，剩下的28天几乎是风雨无阻，雷打不动的从早上八点到晚上七点时间学习 当然目标很重要，第一天就把这一个月内要复习的东西全部罗列好，每天按计划进行 我上面说的三轮是这样子，我离职之前首先审视了一下自己，发现我整个知识栈体系相对于外面问的东西有几个薄弱环节，我就专门针对性的去复习 举个例子，JVM比较薄弱，我就第二遍刷了周志明的书 然后同时每天跟着救火大队长的JVM专栏，并且我会主动去把所有同学提出的问题都在评论区给予他们回答，来锻炼自己 然后回去知乎上把所有R大关于JVM的回答都浏览一遍，至此为止JVM常见，常用的在我这里都能解答。 第二轮是把自己简历上每一个点吃透，项目吃透，能把机器配置到流量大小，每一个应用层的流量，极限的一些基本参数都得记住，同时每天挑一个重点面试题看，然后能表述出来。 第三轮也就是最后一轮，自我面试，假设自己是面试官看到你的简历会问什么，越详细越好 找你的简历的每一个漏洞去问（下面我会详细的分析你该如何准备你的简历，你的项目，你所写的知识点） 然后我之前收集的很多整轮面试题，我会专门挑一个小时时间，自我进行回答复述，算是自我演练面试的过程，事后进行复盘…… 总结学习方法： 至此我要总结一下学习方法： 构建好自己的知识体系，空间联想，不断重复，记忆曲线 刻意练习，多交流，多接受不同的意见，拓展思路 明白自己哪一个环节薄弱，专项针对，比如我redis弱，那我这一段时间就狠抓redis，不要又看redis，又看zk，又学netty的 重点：下面是你该如何准备你的项目？ 这里我就不说单一的技术栈，知识点，这并没有什么意义，网上都能找到，很多面经都会有很多题目，这也是我整篇文章没有任何一道面试题的原因 而且现在慢慢的已经逐渐不太会问你单一的技术点了，都是结合生产实际，要你对你自己做的项目知根知底 下面我以问答的方式让你来准备你的项目。 1.首先，你要简单能描述出你的项目 业务模式是什么？上下游的业务有了解么？ 这种业务模式你觉得会有什么问题？ 你的项目解决了什么问题？ 能否在墙上画出你的项目结构图，架构图 tips：软件工程很重要，我是被问到画出ER图，系统流程图，泳道图等等 项目的日活？GMV？ 每天的访问量？一年营业额？ 合作商家大概多少？租户有多少？ 目前数据量多大？ 系统部署了多少台，机器是什么配置？ 每一层的流量大概是多少？ 比如打到mysql的流量有多大，mq的流量，redis的流量？ 线上的超时时间怎么配置的？ 重试怎么配置？幂等怎么做？ db和cache在一致性怎么做？ jvm垃圾收集用的什么算法？ 老年代新生代给了多大，这样有什么问题么？ cms和g1的区别？ 线上为什么不用g1？ 目前的架构模型对于现有业务量有什么可优化的？有什么难点？以后如何扩容？ 数据库表的设计是怎么样的？违反了三范式会有什么问题，有什么好处？ 当前的数据库表设计有什么问题，有什么可优化的点？ 项目中有你负责模块的设计模式如何运用？能否画出这个设计模式的uml图？ 相比之下这种设计模式和另一种有什么区别？有什么优缺点？ tips：我这里没有细化任何一个框架知识点的问题，是因为一个知识点比如分库分表都会带来大量的问题 我这里着重整体的项目问题，这里起码要准备三个项目的亮点难点，尤其是大厂面试官，很挑剔，那种比较一般的难点就不要拿出来说了，反而会降分 2.第二，对于你项目中运用技术的思考，架构选型，为什么选它，架构设计，为什么这么设计？ 拆分微服务的理由？ 为什么XX模块和XX模块没有拆开，或者拆开了？ 举个例子zk和eureka作为注册中心，你们选型用哪一种？ 针对你们业务量，和服务实例的数量应该选择哪一种？ 这两种模型不同，为什么说一个偏向于AP一个偏向于CP？会带来什么问题？ 引入新框架是否会带来新的挑战？出了问题是否能有人hold住？团队成员开发能否快速上手这个框架？ 如果在面试官问你一个技术，你可以将为什么用它？你是怎么用的？用它有什么优点，缺点？备份方案？ 这种方式表达出来，别人会觉得你是有思考的，你相比其他竞争者是有优势的。 3.常见问题的梳理 这部分就是很常见，外面也会必问的问题，很简单，比如： spring相关的aop，ioc，mybatis相关的 dubbo，zk，netty，springcloud，springboot的starter 线程池，hashmap，并发相关的集合 CAS，volatile，synchronized（1.6之后的锁升级），原子类 网络的NIO，类加载过程，三次握手四次握手，一次http请求的过程 这些常见的问题起码应该烂熟于心，当然有些东西说的越深入越好，最好能涉及到硬件，震慑到面试官 举个例子，每次我聊到CAS： 我会提到底层的MESI协议 会聊到高速缓存的结构 会聊到Modified，Exclusive，Shared，Invalid四种状态如何切换 会聊到缓存加锁之后引入的一些写缓冲器，和无效队列问题 再提到release，acquire，store，load屏障分别做了什么，怎么保证可见性，有序性等等等 所以聊到你擅长的，你就狠狠的喷。 4.稍微深入的题目拓展 平常做一些稍微难的题目其实会拔高自己的思考的能力，我来举几个例子，我以AQS为例子 addWaiter和enq方法中新增一个节点为什么先将新节点的prev置为tail，再尝试cas，而不是cas成功之后来构造节点之间的双向链接？ 唤醒节点为什么从tail往前遍历？ unparkSuccessor有新线程争锁是否有漏洞？ aqs如何保证队列活跃？ Propagate状态的节点存在的意义？ 等等等 5.自己简历上写的每一个知识点要吃的透透的，并且能够独立描述5min，还是要把别人能讲懂的那种 6.自我攻防战，每天最好能针对你的项目找漏洞，再找到解决方案，类似“左右互搏” 有些游戏大神不都这样，每天可能只打两三把游戏，但是水平很高 那是因为别人在脑海中打游戏，演练每一种情况，每一个细节，同时结合一些网上的面经，进行模拟考试，自我演练。 时间过得很快，文章已经接近了尾声，在复习和快速成长的一年中认识到了很多大佬，大家也对我都进行了很多的帮助，这里要十分感谢他们 也有很多朋友催我出一份面经，目前能想到的只有这么多，后续会继续补充，希望这篇文章对大家有帮助，大家有什么问题可以后续加微信进行询问…… 写在最后的一点感悟：我这个人挺爱玩游戏的，爱玩dota，玩了七八年了，也玩LOL。 我经常把游戏比做是人生，从来没有主动点投降，即使背靠的世界之树已经快凋谢，但我坚信一定能找到对手失误的时候，然后一波把别人打趴下。 我经常挂在嘴上的口头禅：怕，你就会输一辈子。所以无论何时何地，保持自己的竞争意识，和自己比，亦或是和优秀的人比，都会不断促进自己的前进...... 不服输，你就不会输！ 来源：作者： 再见伐木机https://mp.weixin.qq.com/s/D46F-KHvWdPXOYEAkcC-Pg","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java面试","slug":"java面试","permalink":"http://chenguoji.com/tags/java面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"彻底干掉恶心的 SQL 注入漏洞， 一网打尽！","slug":"彻底干掉恶心的 SQL 注入漏洞， 一网打尽！","date":"2019-07-26T02:39:50.000Z","updated":"2019-07-26T02:26:29.530Z","comments":true,"path":"2019/07/26/che-di-gan-diao-e-xin-de-sql-zhu-ru-lou-dong-yi-wang-da-jin/","link":"","permalink":"http://chenguoji.com/2019/07/26/che-di-gan-diao-e-xin-de-sql-zhu-ru-lou-dong-yi-wang-da-jin/","excerpt":"","text":"简介文章主要内容包括：Java 持久层技术/框架简单介绍 不同场景/框架下易导致 SQL 注入的写法 如何避免和修复 SQL 注入 JDBC介绍JDBC：全称 Java Database Connectivity 是 Java 访问数据库的 API，不依赖于特定数据库 ( database-independent ) 所有 Java 持久层技术都基于 JDBC 说明直接使用 JDBC 的场景，如果代码中存在拼接 SQL 语句，那么很有可能会产生注入，如 // concat sql String sql = &quot;SELECT * FROM users WHERE name =&apos;&quot;+ name + &quot;&apos;&quot;; Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery(sql); 安全的写法是使用 参数化查询 ( parameterized queries )，即 SQL 语句中使用参数绑定( ? 占位符 ) 和 PreparedStatement，如 // use ? to bind variables String sql = &quot;SELECT * FROM users WHERE name= ? &quot;; PreparedStatement ps = connection.prepareStatement(sql); // 参数 index 从 1 开始 ps.setString(1, name); 还有一些情况，比如 order by、column name，不能使用参数绑定，此时需要手工过滤，如通常 order by 的字段名是有限的，因此可以使用白名单的方式来限制参数值 这里需要注意的是，使用了 PreparedStatement 并不意味着不会产生注入，如果在使用 PreparedStatement之前，存在拼接 sql 语句，那么仍然会导致注入，如 // 拼接 sql String sql = &quot;SELECT * FROM users WHERE name =&apos;&quot;+ name + &quot;&apos;&quot;; PreparedStatement ps = connection.prepareStatement(sql); 看到这里，大家肯定会好奇 PreparedStatement 是如何防止 SQL 注入的，来了解一下 正常情况下，用户的输入是作为参数值的，而在 SQL 注入中，用户的输入是作为 SQL 指令的一部分，会被数据库进行编译/解释执行。 当使用了 PreparedStatement，带占位符 ( ? ) 的 sql 语句只会被编译一次，之后执行只是将占位符替换为用户输入，并不会再次编译/解释，因此从根本上防止了 SQL 注入问题。 Mybatis介绍首个 class persistence framework 介于 JDBC (raw SQL) 和 Hibernate (ORM) 简化绝大部分 JDBC 代码、手工设置参数和获取结果 灵活，使用者能够完全控制 SQL，支持高级映射 更多请参考: http://www.mybatis.org 说明在 MyBatis 中，使用 XML 文件 或 Annotation 来进行配置和映射，将 interfaces 和 Java POJOs (Plain Old Java Objects) 映射到 database records。 XML 例子Mapper Interface @Mapper public interface UserMapper { User getById(int id); } XML 配置文件 &lt;select id=&quot;getById&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user WHERE id = #{id} &lt;/select&gt; Annotation 例子 @Mapper public interface UserMapper { @Select(&quot;SELECT * FROM user WHERE id= #{id}&quot;) User getById(@Param(&quot;id&quot;) int id); } 可以看到，使用者需要自己编写 SQL 语句，因此当使用不当时，会导致注入问题与使用 JDBC 不同的是，MyBatis 使用 #{} 和 ${} 来进行参数值替换。推荐：Mybatis传递多个参数的4种方式。 使用 #{} 语法时，MyBatis 会自动生成 PreparedStatement ，使用参数绑定 ( ?) 的方式来设置值，上述两个例子等价的 JDBC 查询代码如下： String sql = &quot;SELECT * FROM users WHERE id = ?&quot;; PreparedStatement ps = connection.prepareStatement(sql); ps.setInt(1, id); 因此 #{} 可以有效防止 SQL 注入，详细可参考 http://www.mybatis.org/mybatis-3/sqlmap-xml.html String Substitution 部分。 而使用 ${} 语法时，MyBatis 会直接注入原始字符串，即相当于拼接字符串，因而会导致 SQL 注入，如 &lt;select id=&quot;getByName&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user WHERE name = &apos;${name}&apos; limit 1 &lt;/select&gt; name 值为 ‘ or ‘1’=’1，实际执行的语句为 SELECT * FROM user WHERE name = &apos;&apos; or &apos;1&apos;=&apos;1&apos; limit 1 因此建议尽量使用 #{}，但有些时候，如 order by 语句，使用 #{} 会导致出错，如 ORDER BY #{sortBy} sortBy 参数值为 name ，替换后会成为 ORDER BY &quot;name&quot; 即以字符串 “name” 来排序，而非按照 name 字段排序详细可参考: https://stackoverflow.com/a/32996866/6467552 这种情况就需要使用 ${} ORDER BY ${sortBy} 使用了 ${}后，使用者需要自行过滤输入，方法有： 代码层使用白名单的方式，限制 sortBy 允许的值，如只能为 name, email 字段，异常情况则设置为默认值 name 在 XML 配置文件中，使用 if 标签来进行判断 Mapper 接口方法 List&lt;User&gt; getUserListSortBy(@Param(&quot;sortBy&quot;) String sortBy); xml 配置文件 &lt;select id=&quot;getUserListSortBy&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user &lt;if test=&quot;sortBy == &apos;name&apos; or sortBy == &apos;email&apos;&quot;&gt; order by ${sortBy} &lt;/if&gt; &lt;/select&gt; 因为 Mybatis 不支持 else，需要默认值的情况，可以使用 choose(when,otherwise) &lt;select id=&quot;getUserListSortBy&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user &lt;choose&gt; &lt;when test=&quot;sortBy == &apos;name&apos; or sortBy == &apos;email&apos;&quot;&gt; order by ${sortBy} &lt;/when&gt; &lt;otherwise&gt; order by name &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; 更多场景除了 orderby之外，还有一些可能会使用到 ${} 情况，可以使用其他方法避免，如 like 语句如需要使用通配符 ( wildcard characters % 和 _) ，可以 在代码层，在参数值两边加上 %，然后再使用 #{} 使用 bind 标签来构造新参数，然后再使用 #{} Mapper 接口方法 List&lt;User&gt; getUserListLike(@Param(&quot;name&quot;) String name); xml 配置文件 &lt;select id=&quot;getUserListLike&quot; resultType=&quot;org.example.User&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + name + &apos;%&apos;&quot; /&gt; SELECT * FROM user WHERE name LIKE #{pattern} &lt;/select&gt; 语句内的 value 为 OGNL expression 具体可参考 :http://www.mybatis.org/mybatis-3/dynamic-sql.html bind 部分使用 SQL concat() 函数 &lt;select id=&quot;getUserListLikeConcat&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user WHERE name LIKE concat (&apos;%&apos;, #{name}, &apos;%&apos;) &lt;/select&gt; 除了注入问题之外，这里还需要对用户的输入进行过滤，不允许有通配符，否则在表中数据量较多的时候，假设用户输入为 %%，会进行全表模糊查询，严重情况下可导致 DOS 参考: http://www.tothenew.com/blog/sql-wildcards-is-your-application-safe IN 条件使用 和 #{}Mapper 接口方法 List&lt;User&gt; getUserListIn(@Param(&quot;nameList&quot;) List&lt;String&gt; nameList); xml 配置文件 &lt;select id=&quot;selectUserIn&quot; resultType=&quot;com.example.User&quot;&gt; SELECT * FROM user WHERE name in &lt;foreach item=&quot;name&quot; collection=&quot;nameList&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{name} &lt;/foreach&gt; &lt;/select&gt; 具体可参考http://www.mybatis.org/mybatis-3/dynamic-sql.html foreach 部分 limit 语句直接使用 #{} 即可Mapper 接口方法 List&lt;User&gt; getUserListLimit(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit); xml 配置文件 &lt;select id=&quot;getUserListLimit&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user limit #{offset}, #{limit} &lt;/select&gt; JPA &amp; Hibernate介绍 JPA:全称 Java Persistence API ORM (object-relational mapping) 持久层 API，需要有具体的实现 更多请参考：https://en.wikipedia.org/wiki/JavaPersistenceAPI Hibernate:JPA ORM 实现 更多请参考 http://hibernate.org。 说明这里有一种错误的认识，使用了 ORM 框架，就不会有 SQL 注入。而实际上，在 Hibernate 中，支持 HQL (Hibernate Query Language) 和 native sql 查询，前者存在 HQL 注入，后者和之前 JDBC 存在相同的注入问题，来具体看一下。 HQLHQL 查询例子 Query&lt;User&gt; query = session.createQuery(&quot;from User where name = &apos;&quot; + name + &quot;&apos;&quot;, User.class); User user = query.getSingleResult(); 这里的 User 为类名，和原生 SQL 类似，拼接会导致注入。 正确的用法： 位置参数 (Positional parameter) Query&lt;User&gt; query = session.createQuery(&quot;from User where name = ?&quot;, User.class); query.setParameter(0, name); 命名参数 (named parameter) Query&lt;User&gt; query = session.createQuery(&quot;from User where name = :name&quot;, User.class); query.setParameter(&quot;name&quot;, name); 命名参数 list (named parameter list) Query&lt;User&gt; query = session.createQuery(&quot;from User where name in (:nameList)&quot;, User.class); query.setParameterList(&quot;nameList&quot;, Arrays.asList(&quot;lisi&quot;, &quot;zhaowu&quot;)); 类实例 (JavaBean) User user = new User(); user.setName(&quot;zhaowu&quot;); Query&lt;User&gt; query = session.createQuery(&quot;from User where name = :name&quot;, User.class); // User 类需要有 getName() 方法 query.setProperties(user); Native SQL存在 SQL 注入 String sql = &quot;select * from user where name = &apos;&quot; + name + &quot;&apos;&quot;; // deprecated // Query query = session.createSQLQuery(sql); Query query = session.createNativeQuery(sql); 使用参数绑定来设置参数值 String sql = &quot;select * from user where name = :name&quot;; // deprecated // Query query = session.createSQLQuery(sql); Query query = session.createNativeQuery(sql); query.setParameter(&quot;name&quot;, name); JPAJPA 中使用 JPQL (Java Persistence Query Language)，同时也支持 native sql，因此和 Hibernate 存在类似的问题，这里就不再细说，感兴趣的可以参考： https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-persistence-api-jpa 来源：b1ngz.github.io/java-sql-injection-note/","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"在华为写了 13 年代码，都是宝贵的经验","slug":"在华为写了 13 年代码，都是宝贵的经验","date":"2019-07-22T02:39:50.000Z","updated":"2019-07-22T03:14:25.373Z","comments":true,"path":"2019/07/22/zai-hua-wei-xie-liao-13-nian-dai-ma-du-shi-bao-gui-de-jing-yan/","link":"","permalink":"http://chenguoji.com/2019/07/22/zai-hua-wei-xie-liao-13-nian-dai-ma-du-shi-bao-gui-de-jing-yan/","excerpt":"","text":"来源：https://dwz.cn/dqgOrbQo 本文来源华为人：徐宏伟，转给大家观摩下。 一天晚上，我和老婆聊天，说部门要我写个“大咖谈软件”的文章，老婆斜了我一眼，淡淡地说：“Linus大神21岁就写出了Linux内核的雏形，缔造了一个自由主义的开源世界；张小龙28岁写出了foxmail，在2000年就卖出了1200万的价格。大咖，认识您这么久了，还不太了解您有什么杰出的成就？”我讪讪地咽了口水：“好吧，我重新组织下语言，我需要写个谈软件的文章……” 回首过去这半年，软件总工、软件专家的任命，让我们这些写了十多年代码的软件工程师激动不已。我2006年进入公司，几乎参与了华为3G控制器产品的完整生命周期，见证了华为3G从起步、上升、灵魂深处的改进、巅峰、回落的波澜壮阔历程，并在35岁“高龄”有幸加入到5G开发部的大家庭。 十几年来，我一直坚持在编码岗位，经历了普通开发人员、TL、MDE、MDEL、SDM（云化团队）、Committer、软件专家等各种岗位。然而我却深知，不算大牛的我，从事编码这个“高危”职业十几年而没有被拿去“祭天”，依靠的是一个程序员的自我修养——扎实的基础软件能力、如履薄冰的工作态度、对技术孜孜不倦的追求。 好代码长什么模样记得几年前部门第一次评选优秀代码，我成为“金码奖”获得者之一。是因为代码很炫吗？并不是。我参与评选的代码，遵循着简单的原则：简洁、逻辑清晰、函数职责单一、合理的数据结构设计。并没有使用高深的编码技巧，也没有应用某某设计模式。正如公司最新的C/C++语言编程规范，也是将编写简洁的程序放在首位。简洁、逻辑清晰的代码，易于阅读和维护，这段代码后面也因需求变化而被修改，但却从来没有引入过网上问题。 当然，简单不代表没有思考，恰恰相反，更需要我们在写代码之前谋定而后动、三思而后行。有一次项目组安排我做性能优化，通过反复分析热点函数、反复测试比对不同话务模型下的性能差异，前前后后花了3个星期的时间，我找到了引起性能恶化的最关键因素。最终我决定采用修改备份机制、减小备份数据的优化措施。这些方案代码改动都很小、很简单，但实际优化效果却很好，满足了未来几年业务发展的需求。 再来看另一个例子，某局点升级新版本后出现CPU负载上升的问题。经过近两周的攻关，我最终定位是新版本在业务处理流程中新增了直接读取DB内核的操作。直接读取DB内核，代码处理简单，也能正常实现业务功能，但是性能却非常差。如果开发过程中能多想一步，采用缓存的方案，性能会有天壤之别，也是更好的代码。 人们常说唯一不变的就是变化，客户需求一直在变化，我们的代码也会被动或者主动地在变化。设计出可扩展、自动适应客户需求变化的软件架构，是软件工程师永恒的追求。这说说容易，做起来却很难。需要我们不停积累业务知识，扩展知识面，勤于思考，识别技术未来演进趋势。我们无法从一开始就做一个无所不能的架构，来包含未来的千变万化，即使能，交付节奏也不一定允许。满足当前及未来一定时间内业务需要的设计，或许就是最合适的。 练好扎实的基本功能写出好代码，更要能持续地写出好代码，需要我们深刻理解技术原理和业务逻辑。前提是具备扎实的编程基础，即基础软件能力，如基础的数据结构和算法、编译原理等。 去年底，我跟部门几个软件高手一起，去外部参加了一次互联网架构大会。AI、区块链、物联网、云、中间件等时尚、热点、风口相关的议题非常多。但是我没想到，最火爆的却是一些基础软件设计、架构设计和演进之类的专题。就像武侠小说写的一样，练好基本功、练好内功，后续无论什么精妙招式，都会信手拈来。 另外，一些编程习惯，如果坚持下去，对于编程修养提升也是非常有用的。比如快捷键的使用、有效的代码注释、命名规则、代码风格等。每次写代码除了追求好代码之外，我都会时刻去思考软件上的优化，能否能使用更少的内存，能否有更好的性能。重视数据结构中的每一个字段，重视每一处小的代码优化，都有可能给我们带来意想不到的收获。比如去年做性能优化，我们仅仅是将流程中的一处动态内存申请修改为静态内存池，却意外获得了30 CAPS（每秒呼叫次数）的性能提升。 一行代码引发的惨案有人问，道理我都懂，为什么却依然写不出好代码？ 很多开发人员，因为个人习惯、赶工期、外部要求不高等多种原因，在编程时特别随意，直接Copy-Paste。我觉得程序员应当像追求生活品质一样，养成不将就的编程习惯、严谨的编程态度。 对于代码上库，我一直都是战战兢兢，如履薄冰。上库前我会反复看自己修改的代码，看修改代码的上下文，并进行修改前后代码比对。代码上库后再看几遍，确保都已按预期合入。进入公司这么多年，自己从来没有多合、漏合、错合过任何一行代码。 大家可能会觉得我这是小题大做，但事实上，这都是历史上曾经发生过的惨痛教训。我们在某国升级新版本后发现用户接入成功率恶化，最后定位是由于一行代码被误删除导致的。事后回溯，开发人员自己都不记得这一行代码为什么会被删除。还有一次，一行代码被误删除，导致一个关键KPI指标：软切换统计次数有变更。部门把这两起事件总结为“一行代码引发的惨案”，无论是对产品品牌、客户印象、还是对于个人，都造成了恶劣的影响。 事后大家都在思考，我们有结对编程、代码检视、开发者自测试等非常完善的开发流程，还有MDE（模块设计师）检视作为代码上库前的“守门员”，为什么还会发生这么低级的错误？是流程没执行到位，还是MDE疏忽、没把好关？ 在IPD 2.0变革中，公司借鉴开源组织的Committer运作，来加强我们的Committer机制和文化。5G开发部也选拔、任命了一批Committer，我有幸成为其中之一。刚开始履行Committer职责时，我有点疑惑：这不就是给MDE角色披上了新的外衣，把MDE原先“私下”做的事情，通过Committer统计数据给呈现出来嘛？ 不过，经过几个月的摸索、实践后，我渐渐地明白，Committer机制应该是一种文化上的变革，牵引大家提升自己的软件能力。Committer的职责很多，作为代码提交前的最后一道关卡，这是在当前人员能力不足阶段有效果，但是最终应该被弱化的一项实践。参与编码前的软件设计、持续做好架构看护和技术债务清理，让大家都有更大的机会写出更好的代码，我认为这是Committer更大的价值。 随着个人和组织的软件工程能力提升，自动化测试防护网和变更防护墙建设完善之后，前面提到的“一行代码引起的惨案”，是可以避免的。 “变更防护墙”够不够可靠对于大部分老员工，特别是无线2G/3G/4G等部门的老员工来说，一提到变更控制，都会如临大敌。版本升级后，KPI变差是绝对不允许的，严重时可能面临版本回退、客户投诉和上报事故。而KPI变好，除了要向客户解释，还有可能面临商务风险，客户会觉得之前吃亏了。现实世界对我们就是这么苛刻，谁让我们是影响世界的通信软件工程师呢，他们这是爱之深、责之切啊！ 我们开发一个版本，动辄涉及几十万代码的新增、修改或重构。要想不引入变更问题，除了做好设计、结对编码、代码检视和测试之外，我认为最关键的就是完善的自动化防护网。在3G时，我带着两个同事将IT测试工程从只有几百个用例扩充到上万个用例。全方位的场景覆盖、严密的信元有效性检查、完善的用例失败判决机制、无死角的资源泄漏检查等手段，让变更错误无所遁形，给3G留下了一道变更防护墙。 开发过程中补充IT和PC-ST测试用例，不是为了提升代码覆盖率，而是为了自动化防护。而要能达成自动化防护的前提，是每个用例都具备完善的有效性检查，否则防护网就是形同虚设。几年前，我跟一个同事开玩笑：“我会故意将某行代码改错，看看你补充的用例是否能检查出来。”让我意外的是，在交付紧张的情况下，他仍然多花了半天时间完善用例有效性检查，并请我故意改错代码来做试验。当然，最终的结果是，他准备得很充分，我没能发现问题。多么有自我追求的一个程序员！ 保持对于新兴技术的好奇心说起程序员的追求，我还想起了2016年参与的一个产品云化项目，我负责弹性伸缩特性的方案设计。在此之前，我一直在投入嵌入式软件开发，虽然期间产品也换了好几代的硬件，经历了产品与平台解耦、制式间解耦、软件与硬件解耦等过程，但是对于服务化、微服务化、云化等概念，我却基本处于懵懂的状态。 不懂怎么办，只能是“站在巨人肩膀上，为我所用”。兄弟产品线不是已经做了吗，那就找他们做同行协助；友商不是有路标和规划了吗，那就在他们的有限材料中寻找可借鉴的地方；互联网的亚马逊云、阿里云不是有非常成熟的方案了吗，那就下载他们的产品手册和用户指南……那段时间感觉自己就像是入了魔一样，疯狂地学习分布式软件相关技术，疯狂地吸收各方面的能量为我所用，最终给出了一个令自己和项目满意的设计方案。 这也让我充分意识到自己之前把眼光局限于所在产品、系统、子系统的不足。 作为一个程序员，除了要提升自己的基础软件能力，我们也要始终保持对于新兴技术的好奇心，孜孜不倦的追求，不断拓宽自己的视野。而这方面的能力和诉求，在5G时代更是如此。 当前我们华为5G面临的网络安全问题，虽然有着很大的政治因素，但也从侧面反映了5G的战略意义。超高速率、超大连接数、超高可靠低时延，对我们在软件处理时延、可靠性、安全、韧性等方面的能力都提出了更高的要求。同时，5G承载的垂直行业应用、接口开放和硬件“白盒化”等趋势，也必将对我们当前的知识和技术体系，提出更大的挑战。 公司计划用五年的时间，全面提升软件工程能力，对我们是考验，也是机会。统一编程规范、整洁代码、整洁优雅的架构，不同的人有不同的追求，需要我们有持之以恒、水滴石穿的决心。五年或者十年后，当我们回首时，会发现自己曾经的付出是值得的。正如，清代著名学者王国维提出的读书三境界之第三境：“众里寻她千百度，蓦然回首，那人却在灯火阑珊处。” 也许我们绝大多数人终其一生也无法成为Linus、张小龙这样的大神。然而，我们能够做一个有修养的程序员，并参与到改变世界的华为5G产品开发中来，在人类的通信史中留下自己的优秀代码，幸哉。","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"开发中一些常会用到的sql和java语句","slug":"开发中一些常会用到的sql和java语句","date":"2019-07-21T02:39:50.000Z","updated":"2019-09-03T08:00:04.132Z","comments":true,"path":"2019/07/21/kai-fa-zhong-yi-xie-chang-hui-yong-dao-de-sql-he-java-yu-ju/","link":"","permalink":"http://chenguoji.com/2019/07/21/kai-fa-zhong-yi-xie-chang-hui-yong-dao-de-sql-he-java-yu-ju/","excerpt":"","text":"一、ORACLE1.Oracle锁表与解锁查看锁表进程SQL语句 select * from v$session t1, v$locked_object t2 where t1.sid = t2.SESSION_ID; 杀掉锁表进程：记录下SID和serial# ，分别替换掉下面的1155,39095，即可解除锁表 alter system kill session &apos;1155,39095&apos;; 对象锁与解锁 这里以包为PKG_ZLGL_BASEDATA为例 注意name为包或者存储过程等； SELECT * FROM V$DB_OBJECT_CACHE WHERE name=&apos;PKG_ZLGL_BASEDATA&apos; AND LOCKS!=&apos;0&apos;; 查看sid 注意object为包或者存储过程等； SELECT SID from V$ACCESS WHERE object=&apos;PKG_ZLGL_BASEDATA&apos;; 查看查看SID和SERIAL# in后面的条件为上述查的sid SELECT SID,SERIAL#,PADDR,STATUS FROM V$SESSION WHERE SID IN(&apos;283&apos;,&apos;343&apos;); 杀进程 实例如下： alter system kill session ‘sid,SERIAL’ alter system kill session &apos;283,50673&apos; /查看被锁住的存储过程/SELECT FROM V$DB_OBJECT_CACHE WHERE OWNER = ‘APPADMIN’ AND LOCKS != ‘0’;SELECT FROM DBA_DDL_LOCKS WHERE NAME = UPPER(‘TEMP_EXPORT’);SELECT T.SID, T.SERIAL# FROM V$SESSION T WHERE T.SID = 24; /查看被锁住的表/SELECT DO.OWNER, DO.OBJECT_NAME, LO.SESSION_ID, LO.LOCKED_MODE FROM V$LOCKED_OBJECT LO, DBA_OBJECTS DO WHERE DO.OBJECT_ID = LO.OBJECT_ID; SELECT B.USERNAME, B.SID, B.SERIAL#, LOGON_TIME FROM V$LOCKED_OBJECT A, V$SESSION B WHERE A.SESSION_ID = B.SID ORDER BY B.LOGON_TIME; /kill被锁的进程 ‘sid, serial#’ /ALTER SYSTEM KILL SESSION ‘24,30992’; /lock相关表/SELECT FROM V$LOCK;SELECT FROM V$SQLAREA;SELECT FROM V$SESSION;SELECT FROM V$PROCESS;SELECT FROM V$LOCKED_OBJECT;SELECT FROM ALL_OBJECTS;SELECT * FROM V$SESSION_WAIT; 1、修改字段名： alter table 表名 rename column A to B 2、修改字段类型： alter table 表名 alter column 字段名 type not null 3、修改字段默认值 alter table 表名 add default (0) for 字段名 with values 如果字段有默认值，则需要先删除字段的约束，在添加新的默认值， select c.name from sysconstraints a inner join syscolumns b on a.colid=b.colid inner join sysobjects c on a.constid=c.id where a.id=object_id(‘表名’) and b.name=’字段名’ 根据约束名称删除约束 alter table 表名 drop constraint 约束名 根据表名向字段中增加新的默认值 alter table 表名 add default (0) for 字段名 with values 4、增加字段： alter table 表名 add 字段名 type not null default 0 5、删除字段： alter table 表名 drop column 字段名; CHARINDEX 作用 写SQL语句我们经常需要判断一个字符串中是否包含另一个字符串，但是SQL SERVER中并没有像C#提供了Contains函数，不过SQL SERVER中提供了一个叫CHAEINDX的函数，顾名思义就是找到字符（char）的位置（index），既然能够知道所在的位置，当然就可以判断是否包含在其中了。 通过CHARINDEX如果能够找到对应的字符串，则返回该字符串位置，否则返回0。 基本语法如下： CHARINDEX ( expressionToFind , expressionToSearch [ , start_location ] ) expressionToFind ：目标字符串，就是想要找到的字符串，最大长度为8000 。 expressionToSearch ：用于被查找的字符串。 start_location：开始查找的位置，为空时默认从第一位开始查找。 PATINDEX 和CHARINDEX类似，PATINDEX也可以用来判断一个字符串中是否包含另一个字符串，两种的差异在于，前者是全匹配，后者支持模糊匹配。 1.简单示例 select PATINDEX(‘%ter%’,’interesting data’) STUFF ( character_expression , start , length ,character_expression )参数character_expression一个字符数据表达式。character_expression 可以是常量、变量，也可以是字符列或二进制数据列。 start一个整数值，指定删除和插入的开始位置。如果 start 或 length 为负，则返回空字符串。如果 start 比第一个character_expression 长，则返回空字符串。start 可以是 bigint 类型。 length一个整数，指定要删除的字符数。如果 length 比第一个 character_expression 长，则最多删除到最后一个character_expression 中的最后一个字符。length 可以是 bigint 类型。 返回类型如果 character_expression 是受支持的字符数据类型，则返回字符数据。如果 character_expression 是一个受支持的 binary 数据类型，则返回二进制数据。 备注如果开始位置或长度值是负数，或者如果开始位置大于第一个字符串的长度，将返回空字符串。如果要删除的长度大于第一个字符串的长度，将删除到第一个字符串中的第一个字符。如果结果值大于返回类型支持的最大值，则产生错误。 html选择器1.通过 id 来查找 HTML 元素2.通过标签名来查找 HTML 元素3.通过类名来查找 HTML 元素4.通过 CSS 选择器查找 HTML 元素","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"Java开发必知道的国外20大网站","slug":"Java开发必知道的国外20大网站","date":"2019-07-21T02:39:50.000Z","updated":"2019-07-22T02:12:58.121Z","comments":true,"path":"2019/07/21/java-kai-fa-bi-zhi-dao-de-guo-wai-20-da-wang-zhan/","link":"","permalink":"http://chenguoji.com/2019/07/21/java-kai-fa-bi-zhi-dao-de-guo-wai-20-da-wang-zhan/","excerpt":"","text":"1、谷歌 https://www.google.com/ 2、https://stackoverflow.com里面包含各种开发遇到的问题及答案，质量比较高。 3、https://github.com/免费的开源代码托管网站，包括了许多开源的项目及示例项目等。 4、https://dzone.com/提供技术新闻、编程教程、及各种工具、开发者的博客等。 5、http://www.programcreek.com/一个非常优秀的Java博客，包含很多精选文集。 6、https://gitlab.com/免费代码托管网站，可以用来做私服，和GitHub最大区别是GitLab可以有私有项目。 7、https://www.ibm.com/developerworks/learn/java/index.htmlIBM的JAVA开发者网站，很多干货。 8、http://www.javaworld.com/一个不错的综合性的java网站。 9、http://www.onjava.com/某位国外大神的网站。 10、http://www.oracle.com/technetwork/java/index.htmloracle java的官方网站。 11、https://dzone.com/DZone是一个提供编程，Web开发和DevOps新闻，教程和工具的网站。很多开发者在网站里分享其自己的博客文章。 12、https://leetcode.com/LeetCode Online Judge是一个提供JavaScript和Ruby编程的网站。目前，网站提供9种编程语言：C，C ++，Java，Python，C＃，JavaScript，Ruby，Bash，MySQL。 13、https://www.coursera.org/Coursera是全球最好视频讲座网站，用户可以从著名的教授那里获得很多计算机科学课程。 14、http://www.javaworld.com/JavaWorld是一个拥有大量关于各种Java主题教程资源的网站。网站里的很多文章写得非常好，并配有插图。JavaWorld可以作为一个深度学习的网站来阅读。 15、https://en.wikipedia.org/维基百科（Wikipedia）是开发人员查找和学习几乎任何编程概念最好的资源网站之一。作为一个有经验的Java开发人员，你可能只会一些概念，但了解不多。维基百科是一个免费了解最新信息的好地方，例如，什么是面向服务的编程。 16、Program CreekProgram Creek是世界上排名前100的Java博客之一。用户可以找到一些没有被任何其他网站所写的主题，每篇文章总是包含很好的图表或代码示例。Program Creek包含研究和行业人员撰写的文章，并始终向Java开发人员分享优质文章。","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"Github上10个开源免费的后台控制面板你值得拥有！","slug":"Github上10个开源免费的后台控制面板你值得拥有！","date":"2019-07-19T02:39:50.000Z","updated":"2019-07-19T08:54:54.615Z","comments":true,"path":"2019/07/19/github-shang-10-ge-kai-yuan-mian-fei-de-hou-tai-kong-zhi-mian-ban-ni-zhi-de-yong-you/","link":"","permalink":"http://chenguoji.com/2019/07/19/github-shang-10-ge-kai-yuan-mian-fei-de-hou-tai-kong-zhi-mian-ban-ni-zhi-de-yong-you/","excerpt":"","text":"Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10。 AdminLTE Github Star 数 24969 ， Github 地址： https://github.com/almasaeed2010/AdminLTE 非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 vue-Element-Admin Github Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin 一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 tabler Github Star 数 15870， Github 地址： https://github.com/tabler/tabler 构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 Gentelella Github Star 数 15654， Github 地址： https://github.com/puikinsh/gentelella 一个基于 Bootstarp 的免费的后台控制面板。 ng2-admin Github Star 数 13181， Github 地址： https://github.com/akveo/ngx-admin 基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。 ant-design-pro Github Star 数 12707，Github 地址： https://github.com/ant-design/ant-design-pro 开箱即用的中台前端/设计解决方案 blur-admin Github Star 数 9241，Github 地址： https://github.com/akveo/blur-admin 基于 Angular 和 Bootstrap 的后台管理面板框架。 vue-admin Github Star 数 8676，Github 地址： https://github.com/vue-bulma/vue-admin 基于 Vue 和 Bulma 的控制面板。 iview-admin Github Star 数 8668，Github 地址： https://github.com/iview/iview-admin 基于 iView 的 Vue 2.0 控制面板。 material-dashboard Github Star 数 7111，Github 地址： https://github.com/creativetimofficial/material-dashboard 基于 Bootstrap 4 和 Material 风格的控制面板。 来源：www.jianshu.com/p/3bc7404af887","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"Java开发最常犯的10个错误，打死都不要犯！","slug":"Java开发最常犯的10个错误，打死都不要犯！","date":"2019-07-08T02:39:50.000Z","updated":"2019-07-08T05:58:41.305Z","comments":true,"path":"2019/07/08/java-kai-fa-zui-chang-fan-de-10-ge-cuo-wu-da-si-du-bu-yao-fan/","link":"","permalink":"http://chenguoji.com/2019/07/08/java-kai-fa-zui-chang-fan-de-10-ge-cuo-wu-da-si-du-bu-yao-fan/","excerpt":"","text":"阅读目录1.Array转ArrayList 2.判断一个数组是否包含某个值 3.在循环内部删除List中的一个元素 4.HashTable与HashMap 5.使用集合原始类型（raw type） 6.访问级别 7.ArrayList和LinkedList 8.可变与不可变 9.父类和子类的构造方法 10.“”还是构造方法 11.未来工作 这个列表总结了10个Java开发人员最常犯的错误。 1、Array转ArrayList当需要把Array转成ArrayList的时候，开发人员经常这样做： List&lt;String&gt; list = Arrays.asList(arr); Arrays.asList()会返回一个ArrayList，但是要特别注意，这个ArrayList是Arrays类的静态内部类，并不是java.util.ArrayList类。 java.util.Arrays.ArrayList类实现了set()， get()，contains()方法，但是并没有实现增加元素的方法（事实上是可以调用add方法，但是没有具体实现，仅仅抛出UnsupportedOperationException异常），因此它的大小也是固定不变的。为了创建一个真正的java.util.ArrayList，你应该这样做： ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr)); ArrayList的构造方法可以接收一个Collection类型，而java.util.Arrays.ArrayList已经实现了该接口。 2、判断一个数组是否包含某个值开发人员经常这样做： Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr)); return set.contains(targetValue); 以上代码可以正常工作，但是没有必要将其转换成set集合，将一个List转成Set需要额外的时间，其实我们可以简单的使用如下方法即可： Arrays.asList(arr).contains(targetValue); 或者 for(String s: arr){ if(s.equals(targetValue)) return true; } return false; 第一种方法可读性更强。 3、在循环内部删除List中的一个元素考虑如下代码，在迭代期间删除元素： ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;)); for (int i = 0; i &lt; list.size(); i++) { list.remove(i); } System.out.println(list); 结果打印：[b, d] 在上面这个方法中有一系列的问题，当一个元素被删除的时候，list大小减小，然后原先索引指向了其它元素。所以如果你想在循环里通过索引来删除多个元素，将不会正确工作。 你也许知道使用迭代器是在循环里删除元素的正确方式，或许你也知道foreach循环跟迭代器很类似，但事实情况却不是这样，如下代码： ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;)); for (String s : list) { if (s.equals(&quot;a&quot;)) list.remove(s); } 将抛出ConcurrentModificationException异常。 然而接下来的代码却是OK的： ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;)); Iterator&lt;String&gt; iter = list.iterator(); while (iter.hasNext()) { String s = iter.next(); if (s.equals(&quot;a&quot;)) { iter.remove(); } } next()方法需要在remove()方法之前被调用，在foreach循环里，编译器会在删除元素操作化调用next方法，这导致了ConcurrentModificationException异常。更多详细信息，可以查看ArrayList.iterator()的源码。 4、HashTable与HashMap从算法的角度来讲，HashTable是一种数据结构名称。但是在Java中，这种数据结构叫做HashMap。 HashTable与HashMap的一个主要的区别是HashTable是同步的，所以，通常来说，你会使用HashMap，而不是Hashtable。推荐：HashMap 和 Hashtable 的 6 个区别！ 5、使用集合原始类型（raw type）在Java中，原始类型（raw type）和无界通配符类型很容易让人混淆。举个Set的例子，Set是原始类型，而Set是无界通配符类型。 请看如下代码，add方法使用了一个原始类型的List作为入参： public static void add(List list, Object o){ list.add(o); } public static void main(String[] args){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); add(list, 10); String s = list.get(0); } 运行以上代码将会抛出异常： Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at … 使用原始类型集合非常危险，因为它跳过了泛型类型检查，是不安全的。另外，Set, Set, 和Set这三个有很大的不同。 6、访问级别开发人员经常使用public修饰类字段，虽然这很容易让别人直接通过引用获取该字段的值，但这是一个不好的设计。根据经验，应该尽可能的降低成员属性的访问级别。 7、ArrayList和LinkedList为什么开发人员经常使用ArrayList和LinkedList，却不知道他们之间的区别，因为它们看起来很像。然而它们之间有着巨大的性能差异。简单的说，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首选LinkedList。 8、可变与不可变不可变对象有很多优点，如简单、安全等。但是对于每个不同的值都需要一个单独的对象，太多的对象会引起大量垃圾回收，因此在选择可变与不可变的时候，需要有一个平衡。 通常，可变对象用于避免产生大量的中间对象，一个经典的例子是大量字符串的拼接。如果你使用一个不可变对象，将会马上产生大量符合垃圾回收标准的对象，这浪费了CPU大量的时间和精力。使用可变对象是正确的解决方案（StringBuilder）； String result=&quot;&quot;; for(String s: arr){ result = result + s; } 另外，在有些其它情况下也是需要使用可变对象。例如往一个方法传入一个可变对象，然后收集多种结果，而不需要写太多的语法。另一个例子是排序和过滤：当然，你可以写一个方法来接收原始的集合，并且返回一个排好序的集合，但是那样对于大的集合就太浪费了。 9、父类和子类的构造方法class Super{ String s; public Super(String s){ this.s = s; } } public class Sub extends Super{ int x = 200; public Sub(String s){ } public Sub(){ System.out.println(&quot;Sub&quot;); } public static void main(String[] args){ Sub s = new Sub(); } } 之所以出现这个编译错误，是因为父类的默认构造方法未定义。在Java中，如果一个类没有定义构造方法，编译器会默认插入一个无参数的构造方法；但是如果一个构造方法在父类中已定义，在这种情况，编译器是不会自动插入一个默认的无参构造方法，这正是以上demo的情况； 对于子类来说，不管是无参构造方法还是有参构造方法，都会默认调用父类的无参构造方法；当编译器尝试在子类中往这两个构造方法插入super()方法时，因为父类没有一个默认的无参构造方法，所以编译器报错； 要修复这个错误，很简单： 1、在父类手动定义一个无参构造方法：public Super(){ System.out.println(&quot;Super&quot;); } 2、移除父类中自定义的构造方法3、在子类中自己写上父类构造方法的调用；如super(value)；10、“”还是构造方法有两种创建字符串的方式： //1. use double quotes String x = &quot;abc&quot;; //2. use constructor String y = new String(&quot;abc&quot;); 它们之间有什么区别呢？ 以下代码提供了一个快速回答： String a = &quot;abcd&quot;; String b = &quot;abcd&quot;; System.out.println(a == b); // True System.out.println(a.equals(b)); // True String c = new String(&quot;abcd&quot;); String d = new String(&quot;abcd&quot;); System.out.println(c == d); // False System.out.println(c.equals(d)); // True 更多关于它们内存分配的信息，请参考Create Java String Using ” ” or Constructor?? 未来工作 这个列表是我基于大量的github上的开源项目，Stack overflow上的问题，还有一些流行的google搜索的分析。没有明显示的评估证明它们是前10，但它们绝对是很常见的。 如果您不同意任一部分，请留下您的评论。如果您能提出其它一些常见的错误，我将会非常感激。 原文：http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/译文：cnblogs.com/chenpi/p/5508949.html","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"创业公司技术总监，去上市公司面试，结果凉了！","slug":"创业公司技术总监，去上市公司面试，结果凉了！","date":"2019-07-05T02:39:50.000Z","updated":"2019-07-08T05:56:37.125Z","comments":true,"path":"2019/07/05/chuang-ye-gong-si-ji-zhu-zong-jian-qu-shang-shi-gong-si-mian-shi-jie-guo-liang-liao/","link":"","permalink":"http://chenguoji.com/2019/07/05/chuang-ye-gong-si-ji-zhu-zong-jian-qu-shang-shi-gong-si-mian-shi-jie-guo-liang-liao/","excerpt":"","text":"1、先来个自我介绍首先，大概介绍下自己，后端开发8年，头两年用.NET，之后用Python至今，大概六年。 大概工作到第三年的时候，就开始兼着任管理职位。工作地点是在一个三、四线的沿海城市，本地IT业不发达，公司规模普遍偏小，对技术要求不高，但需要较为全面的人才。 而我长时间在这样的氛围下工作，慢慢也成长为一位偏“全栈”的WEB开发人员，从前端angular，到后端Python，到服务器部署，统统可以一人搞定。 2、人到中年的焦虑现在在这家公司差不多2年，担任技术合伙人，工资12K，在当地应该几乎达到顶点了，同时拥有一定的股权。但是公司近来越来越不景气，时不时出现了拖欠工资的行为。因而引发了我的焦虑。 心里想着，万一公司解散了，在本地很难找到相当水平的岗位。再者，就算换了一家别的公司，结局是否跟之前的一样，不断出现公司经营情况慢慢变差，随后再次出现解散的情况呢？ 我心里没底，现在的我，三十出头，还处在事业的高峰期。如果在我四十岁、甚至五十岁，不断遇到这样类似的情况，那么我该何去何从呢？ 3、萌生回到厦门的念头于是乎，在招聘网站上填了我的资料，寻找机会。 这次我的择业选择比较明确，到大公司去，最好是上市公司。为什么呢？一是之前都在小公司，想到真正的大公司去体验大公司的工作；二是大公司的上升空间比较大，相对来说也比较稳定。 自从填了资料，时不时有企业联系，规模小的，一般直接拒绝了。规模大的，也有一部分看不上我的。 一直到昨天，有个厦门的上市游戏公司邀请我过去聊聊。我向HR说明了，我没有游戏服务端的开发经验。但是她说没关系，你有多年的Python经验。 4、面试过程：笔试昨天，2018年7月25日早上，我按约定来到了这家公司。先是填一些个人资料，然后笔试。 笔试的题目就是做过什么最有难度的项目，你是怎么设计架构的，你遇到了什么难题，你是怎么处理这些难题的。 于是，我把在这家公司的项目结构解析了下。 1.微服务架构、将系统拆分成5大微服务，包括用户、积分、会员卡、商户、订单。2.微服务内部采用RESTAPI进行通信。3.数据库采用各自独立，但是统一在一个数据库服务器上，并且进行读写分离。4.服务器采用分布式+负载均衡5.采用单点登录6.前端是angular实际上我在笔试中写得更详细一点，但是大概就这么回事。 5、面试过程：HR面HR问了为什么来厦门，我坦言就业遇到瓶颈，寻求突破。估计HR看了我的简历，我有多年的管理岗位的经验。于是问了我不少管理上的问题。 例如：如果有人在上班时间炒股票，被你发现你会怎么办？ 根据以往的经验，如果频率不高，我就当做没看见。为什么这样呢？因为小公司很难留住人，在不响应项目进度的前停下，这点小毛病，我不想管，当然也怕管了，人走了，会更公司带来更多的麻烦。 这点HR觉得我答得不好，他说公司有规定，看到就得当面指出，再犯可能开除。 我细想了下，嗯，有道理。 例如：如果有个员工一份月刚涨薪，六月份他又来提涨薪，你怎么处理？ 我巴拉巴拉说了一堆，自己感觉也没答好。 这点HR说：应该去关注为什么他会想要涨薪。 我一听，也觉得确实应该这样。 最后呢，HR说虽然有管理经验，但是一般般。 这个事情呢，后来仔细的想，一是确实管理能力不足，二是当公司规模不同时，你如果按照你原有的经验去答，那可能不行。你得站在他的环境下去回答，大公司讲究制度，规模大了，没有制度管不了那么多的人。 6、面试过程：技术面跟HR聊了很久，大概有2个小时，实际上涉及的问题比我在这里写的要多很多。我给他开的薪水是，最低18K，他问我是否确定要这么多，他觉得我的水平要不到那么多，我坚持，他就去找技术那边的人了。 几分钟后回来，说抱歉，看了我的笔试，觉得他们公司一般的小伙伴都具备的能力，我的技术没有突出点。 7、总结从我6年前，回到所在城市的那次面试外，这个是我第一次去面试。感觉收获很多，一是处在管理岗位，确实应该有很多管理上的能力，得加强学习，不能两眼只盯着技术栈；二是隔一段时间去面试下，避免坐井观天，活在自己的世界里。 作者： 森林木https://www.cnblogs.com/senlinmu/","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"系统运行缓慢，CPU 100%，Full GC次数过多，这一招帮你全搞定！","slug":"系统运行缓慢，CPU 100%，Full GC次数过多，这一招帮你全搞定！","date":"2019-07-01T02:39:50.000Z","updated":"2019-07-08T03:08:32.175Z","comments":true,"path":"2019/07/01/xi-tong-yun-xing-huan-man-cpu-100-full-gc-ci-shu-guo-duo-zhe-yi-zhao-bang-ni-quan-gao-ding/","link":"","permalink":"http://chenguoji.com/2019/07/01/xi-tong-yun-xing-huan-man-cpu-100-full-gc-ci-shu-guo-duo-zhe-yi-zhao-bang-ni-quan-gao-ding/","excerpt":"","text":"处理过线上问题的同学基本上都会遇到系统突然运行缓慢，CPU 100%，以及Full GC次数过多的问题。当然，这些问题的最终导致的直观现象就是系统运行缓慢，并且有大量的报警。本文主要针对系统运行缓慢这一问题，提供该问题的排查思路，从而定位出问题的代码点，进而提供解决该问题的思路。 对于线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出jstack和内存信息，然后重启系统，尽快保证系统的可用性。这种情况可能的原因主要有两种： 1.代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致Full GC次数过多，系统缓慢； 2.代码中有比较耗CPU的操作，导致CPU过高，系统运行缓慢； 相对来说，这是出现频率最高的两种线上问题，而且它们会直接导致系统不可用。另外有几种情况也会导致某个功能运行缓慢，但是不至于导致系统不可用： 1.代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的； 2.某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现； 3.由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢。 对于这三种情况，通过查看CPU和系统内存情况是无法查看出具体问题的，因为它们相对来说都是具有一定阻塞性操作，CPU和系统内存使用情况都不高，但是功能却很慢。下面我们就通过查看系统日志来一步一步甄别上述几种问题。 1. Full GC次数过多相对来说，这种情况是最容易出现的，尤其是新功能上线时。对于Full GC较多的情况，其主要有如下两个特征： 1.线上多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程 2.通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。 首先我们可以使用 top命令查看系统CPU的占用情况，如下是系统CPU较高的一个示例： 可以看到，有一个Java程序此时CPU占用量达到了98.8%，此时我们可以复制该进程id 9，并且使用如下命令查看呢该进程的各个线程运行情况： top -Hp 9 该进程下的各个线程运行情况如下： 可以看到，在进程为 9的Java程序中各个线程的CPU占用情况，接下来我们可以通过jstack命令查看线程id为 10的线程为什么耗费CPU最高。需要注意的是，在jsatck命令展示的结果中，线程id都转换成了十六进制形式。可以用如下命令查看转换结果，也可以找一个科学计算器进行转换： 这里打印结果说明该线程在jstack中的展现形式为 0xa，通过jstack命令我们可以看到如下信息： 这里的VM Thread一行的最后显示 nid=0xa，这里nid的意思就是操作系统线程id的意思。而VM Thread指的就是垃圾回收的线程。这里我们基本上可以确定，当前系统缓慢的原因主要是垃圾回收过于频繁，导致GC停顿时间较长。我们通过如下命令可以查看GC的情况： 可以看到，这里FGC指的是Full GC数量，这里高达6793，而且还在不断增长。从而进一步证实了是由于内存溢出导致的系统缓慢。那么这里确认了内存溢出，但是如何查看你是哪些对象导致的内存溢出呢，这个可以dump出内存日志，然后通过eclipse的mat工具进行查看，如下是其展示的一个对象树结构： 经过mat工具分析之后，我们基本上就能确定内存中主要是哪个对象比较消耗内存，然后找到该对象的创建位置，进行处理即可。这里的主要是PrintStream最多，但是我们也可以看到，其内存消耗量只有12.2%。也就是说，其还不足以导致大量的Full GC，此时我们需要考虑另外一种情况，就是代码或者第三方依赖的包中有显示的 System.gc()调用。这种情况我们查看dump内存得到的文件即可判断，因为其会打印GC原因： 比如这里第一次GC是由于 System.gc()的显示调用导致的，而第二次GC则是JVM主动发起的。总结来说，对于Full GC次数过多，主要有以下两种原因： 1.代码中一次获取了大量的对象，导致内存溢出，此时可以通过eclipse的mat工具查看内存中有哪些对象比较多； 2.内存占用不高，但是Full GC次数还是比较多，此时可能是显示的 System.gc()调用导致GC次数过多，这可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。 2. CPU过高在前面第一点中，我们讲到，CPU过高可能是系统频繁的进行Full GC，导致系统缓慢。而我们平常也肯能遇到比较耗时的计算，导致CPU过高的情况，此时查看方式其实与上面的非常类似。首先我们通过 top命令查看当前CPU消耗过高的进程是哪个，从而得到进程id；然后通过 top-Hp来查看该进程中有哪些线程CPU过高，一般超过80%就是比较高的，80%左右是合理情况。这样我们就能得到CPU消耗比较高的线程id。接着通过该 线程id的十六进制表示在 jstack日志中查看当前线程具体的堆栈信息。 在这里我们就可以区分导致CPU过高的原因具体是Full GC次数过多还是代码中有比较耗时的计算了。如果是Full GC次数过多，那么通过 jstack得到的线程信息会是类似于VM Thread之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。如下是一个代码中有比较耗时的计算，导致CPU过高的线程信息： 这里可以看到，在请求UserController的时候，由于该Controller进行了一个比较耗时的调用，导致该线程的CPU一直处于100%。我们可以根据堆栈信息，直接定位到UserController的34行，查看代码中具体是什么原因导致计算量如此之高。 3. 不定期出现的接口耗时现象对于这种情况，比较典型的例子就是，我们某个接口访问经常需要2~3s才能返回。这是比较麻烦的一种情况，因为一般来说，其消耗的CPU不多，而且占用的内存也不高，也就是说，我们通过上述两种方式进行排查是无法解决这种问题的。而且由于这样的接口耗时比较大的问题是不定时出现的，这就导致了我们在通过 jstack命令即使得到了线程访问的堆栈信息，我们也没法判断具体哪个线程是正在执行比较耗时操作的线程。 对于不定时出现的接口耗时比较严重的问题，我们的定位思路基本如下：首先找到该接口，通过压测工具不断加大访问力度，如果说该接口中有某个位置是比较耗时的，由于我们的访问的频率非常高，那么大多数的线程最终都将阻塞于该阻塞点，这样通过多个线程具有相同的堆栈日志，我们基本上就可以定位到该接口中比较耗时的代码的位置。如下是一个代码中有比较耗时的阻塞操作通过压测工具得到的线程堆栈日志： 从上面的日志可以看你出，这里有多个线程都阻塞在了UserController的第18行，说明这是一个阻塞点，也就是导致该接口比较缓慢的原因。 4. 某个线程进入WAITING状态对于这种情况，这是比较罕见的一种情况，但是也是有可能出现的，而且由于其具有一定的“不可复现性”，因而我们在排查的时候是非常难以发现的。笔者曾经就遇到过类似的这种情况，具体的场景是，在使用CountDownLatch时，由于需要每一个并行的任务都执行完成之后才会唤醒主线程往下执行。而当时我们是通过CountDownLatch控制多个线程连接并导出用户的gmail邮箱数据，这其中有一个线程连接上了用户邮箱，但是连接被服务器挂起了，导致该线程一直在等待服务器的响应。最终导致我们的主线程和其余几个线程都处于WAITING状态。 对于这样的问题，查看过jstack日志的读者应该都知道，正常情况下，线上大多数线程都是处于 TIMED_WAITING状态，而我们这里出问题的线程所处的状态与其是一模一样的，这就非常容易混淆我们的判断。解决这个问题的思路主要如下： 1.通过grep在jstack日志中找出所有的处于 TIMED_WAITING状态的线程，将其导出到某个文件中，如a1.log 2.等待一段时间之后，比如10s，再次对jstack日志进行grep，将其导出到另一个文件，如a2.log 3.重复步骤2，待导出3~4个文件之后，我们对导出的文件进行对比，找出其中在这几个文件中一直都存在的用户线程，这个线程基本上就可以确认是包含了处于等待状态有问题的线程。因为正常的请求线程是不会在20~30s之后还是处于等待状态的。 4.经过排查得到这些线程之后，我们可以继续对其堆栈信息进行排查，如果该线程本身就应该处于等待状态，比如用户创建的线程池中处于空闲状态的线程，那么这种线程的堆栈信息中是不会包含用户自定义的类的。这些都可以排除掉，而剩下的线程基本上就可以确认是我们要找的有问题的线程。通过其堆栈信息，我们就可以得出具体是在哪个位置的代码导致该线程处于等待状态了。 这里需要说明的是，我们在判断是否为用户线程时，可以通过线程最前面的线程名来判断，因为一般的框架的线程命名都是非常规范的，我们通过线程名就可以直接判断得出该线程是某些框架中的线程，这种线程基本上可以排除掉。而剩余的，比如上面的 Thread-0，以及我们可以辨别的自定义线程名，这些都是我们需要排查的对象。 经过上面的方式进行排查之后，我们基本上就可以得出这里的 Thread-0就是我们要找的线程，通过查看其堆栈信息，我们就可以得到具体是在哪个位置导致其处于等待状态了。如下示例中则是在SyncTask的第8行导致该线程进入等待了。 5. 死锁对于死锁，这种情况基本上很容易发现，因为 jstack可以帮助我们检查死锁，并且在日志中打印具体的死锁线程信息。如下是一个产生死锁的一个 jstack日志示例： 可以看到，在jstack日志的底部，其直接帮我们分析了日志中存在哪些死锁，以及每个死锁的线程堆栈信息。这里我们有两个用户线程分别在等待对方释放锁，而被阻塞的位置都是在ConnectTask的第5行，此时我们就可以直接定位到该位置，并且进行代码分析，从而找到产生死锁的原因。 6. 小结本文主要讲解了线上可能出现的五种导致系统缓慢的情况，详细分析了每种情况产生时的现象，已经根据现象我们可以通过哪些方式定位得到是这种原因导致的系统缓慢。简要的说，我们进行线上日志分析时，主要可以分为如下步骤： 1.通过 top命令查看CPU情况，如果CPU比较高，则通过 top-Hp&lt;pid&gt;命令查看当前进程的各个线程运行情况，找出CPU过高的线程之后，将其线程id转换为十六进制的表现形式，然后在jstack日志中查看该线程主要在进行的工作。这里又分为两种情况 1.1 如果是正常的用户线程，则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消耗CPU； 1.2 如果该线程是 VMThread，则通过 jstat-gcutil&lt;pid&gt;&lt;period&gt;&lt;times&gt;命令监控当前系统的GC状况，然后通过 jmapdump:format=b,file=&lt;filepath&gt;&lt;pid&gt;导出系统当前的内存数据。导出之后将内存情况放到eclipse的mat工具中进行分析即可得出内存中主要是什么对象比较消耗内存，进而可以处理相关代码； 2.如果通过 top命令看到CPU并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于另外三种情况导致的问题。具体的可以根据具体情况分析： 2.1如果是接口调用比较耗时，并且是不定时出现，则可以通过压测的方式加大阻塞点出现的频率，从而通过 jstack查看堆 栈信息，找到阻塞点； 2.2如果是某个功能突然出现停滞的状况，这种情况也无法复现，此时可以通过多次导出 jstack日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程； 2.3如果通过 jstack可以查看到死锁状态，则可以检查产生死锁的两个线程的具体阻塞点，从而处理相应的问题。 本文主要是提出了五种常见的导致线上功能缓慢的问题，以及排查思路。当然，线上的问题出现的形式是多种多样的，也不一定局限于这几种情况，如果我们能够仔细分析这些问题出现的场景，就可以根据具体情况具体分析，从而解决相应的问题。 来源：http://t.cn/EI9JdBu","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"这么牛逼的正则表达式，可惜你不会写！","slug":"这么牛逼的正则表达式，可惜你不会写！","date":"2019-06-28T02:39:50.000Z","updated":"2019-06-28T01:50:33.548Z","comments":true,"path":"2019/06/28/zhe-me-niu-bi-de-zheng-ze-biao-da-shi-ke-xi-ni-bu-hui-xie/","link":"","permalink":"http://chenguoji.com/2019/06/28/zhe-me-niu-bi-de-zheng-ze-biao-da-shi-ke-xi-ni-bu-hui-xie/","excerpt":"","text":"一、校验数字的表达式数字： ^[0-9]*$ n位的数字： ^\\d{n}$ 至少n位的数字： ^\\d{n,}$ m-n位的数字： ^\\d{m,n}$ 零和非零开头的数字： ^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字： ^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数： ^(-)?\\d+(.\\d{1,2})$ 正数、负数、和小数： ^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数： ^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数： ^[0-9]+(.[0-9]{1,3})?$ 非零的正整数： ^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数： ^-[1-9][]0-9”*$ 或 ^-[1-9]\\d*$ 非负整数： ^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数： ^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数： ^\\d+(.\\d+)?$ 或 ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数： ^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数： ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数： ^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数： ^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式汉字： ^[\\u4e00-\\u9fa5]{0,}$ 英文和数字： ^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符： ^.{3,20}$ 由26个英文字母组成的字符串： ^[A-Za-z]+$ 由26个大写英文字母组成的字符串： ^[A-Z]+$ 由26个小写英文字母组成的字符串： ^[a-z]+$ 由数字和26个英文字母组成的字符串： ^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串： ^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线： ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号： ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 禁止输入含有~的字符： [^~\\x22]+ 三、特殊需求表达式Email地址： ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$ 域名： [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL： [a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码： ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 国内电话号码(0511-4405222、021-87888822)： \\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X： (^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： ^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式： ^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)： ^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)： ^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件： ^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式： [\\u4e00-\\u9fa5] 空白行的正则表达式： \\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式： &lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号： [1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码： [1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址： ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 来源：编程无界（ID：qianshic）","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"自动创建Spring Boot 工程，太爽了！","slug":"自动创建Spring Boot 工程，太爽了！","date":"2019-06-24T02:39:50.000Z","updated":"2019-06-24T02:47:26.203Z","comments":true,"path":"2019/06/24/zi-dong-chuang-jian-spring-boot-gong-cheng-tai-shuang-liao/","link":"","permalink":"http://chenguoji.com/2019/06/24/zi-dong-chuang-jian-spring-boot-gong-cheng-tai-shuang-liao/","excerpt":"","text":"Spring Boot 大家都知道是啥吧？ 顺便再往下看，今天博主给你带来年轻人的第一个 Spring Boot 工程，撸码史无前例的轻松，那就一个字：爽！ 第一步打开这个网站，快速生成一个 Spring Boot 项目。 https://start.spring.io/ 废话不说，看下图，几秒搞定！ 第二步解压生成的 demo 项目，导入到 IDE 中。 来看下 pom.xml 文件内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.javastack&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 以及 DemoApplication 入口类内容： @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 这里不作过多介绍。 第三步添加年轻人的第一个 Spring Boot 请求：/hello. 修改 DemoApplication 添加一个请求方法，修改后的代码内容如下： @RestController @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello&quot;; } } 第四步运行 Spring Boot 应用，在 IDE 中运行 DemoApplication main 方法即可。 如图所示，程序已经启动，牛逼啊，2秒多就启动起来了，爽。。。它能跑起来，是因为内置了 Tomcat 容器，当然你也可以替换或者自定义配置， 第五步访问 /hello 请求，在浏览器中访问以下链接： http://localhost:8080/hello 如下图所示，页面输出了hello. 总结我就在官网生成一个 demo 项目，然后导入到 IDE 中，写几行代码后输出：hello，开启了年轻人的第一个 Spring Boot 项目。 全程下来，我就只用几分钟，然后只加了 5 行代码，没有其他乱七八糟的 XML 配置，这叫一个爽。","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"【美团】Java岗154道面试题","slug":"【美团】Java岗154道面试题","date":"2019-06-21T02:39:50.000Z","updated":"2019-06-21T05:27:07.213Z","comments":true,"path":"2019/06/21/mei-tuan-java-gang-154-dao-mian-shi-ti/","link":"","permalink":"http://chenguoji.com/2019/06/21/mei-tuan-java-gang-154-dao-mian-shi-ti/","excerpt":"","text":"Java集合22题ArrayList 和 Vector 的区别。说说 ArrayList,Vector, LinkedList 的存储性能和特性。快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？hashmap 的数据结构。HashMap 的工作原理是什么?Hashmap 什么时候进行扩容呢？List、Map、Set 三个接口，存取元素时，各有什么特点？Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?heap 和 stack 有什么区别。Java 集合类框架的基本接口有哪些？HashSet 和 TreeSet 有什么区别？HashSet 的底层实现是什么?LinkedHashMap 的实现原理?为什么集合类没有实现 Cloneable 和 Serializable 接口？什么是迭代器 (Iterator)？Iterator 和 ListIterator 的区别是什么？数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？Java 集合类框架的最佳实践有哪些？Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？Comparable 和 Comparator 接口是干什么的？列出它们的区别Collection 和 Collections 的区别。 JVM与调优21题Java 类加载过程？描述一下 JVM 加载 Class 文件的原理机制?Java 内存分配。GC 是什么? 为什么要有 GC？简述 Java 垃圾回收机制如何判断一个对象是否存活？（或者 GC 对象的判定方法）垃圾回收的优点和原理。并考虑 2 种回收机制垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？Java 中会存在内存泄漏吗，请简单描述深拷贝和浅拷贝。System.gc() 和 Runtime.gc() 会做什么事情？finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？什么是分布式垃圾回收（DGC）？它是如何工作的？串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？在 Java 中，对象什么时候可以被垃圾回收？简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。JVM 的永久代中会发生垃圾回收么？Java 中垃圾收集的方法有哪些？什么是类加载器，类加载器有哪些？类加载器双亲委派模型机制？ 并发编程28题Synchronized 用过吗，其原理是什么？你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？什么是可重入性，为什么说 Synchronized 是可重入锁？JVM 对 Java 的原生锁做了哪些优化？48为什么说 Synchronized 是非公平锁？49什么是锁消除和锁粗化？49为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？乐观锁一定就是好的吗？跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？那么请谈谈 AQS 框架是怎么回事儿？请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。ReentrantLock 是如何实现可重入性的？除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？请谈谈 ReadWriteLock 和 StampedLock。如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？Java 线程池相关问题Java 中的线程池是如何实现的？创建线程池的几个核心构造参数？线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同如何在 Java 线程池中提交线程？什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？请对比下 volatile 对比 Synchronized 的异同。请谈谈 ThreadLocal 是怎么解决并发安全的？很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？ spring 25题1、什么是 Spring 框架？Spring 框架有哪些主要模块？2、使用 Spring 框架能带来哪些好处？3、什么是控制反转(IOC)？什么是依赖注入？4、请解释下 Spring 框架中的 IoC？5、BeanFactory 和 ApplicationContext 有什么区别？6、Spring 有几种配置方式？7、如何用基于 XML 配置的方式配置 Spring？8、如何用基于 Java 配置的方式配置 Spring？9、怎样用注解的方式配置 Spring？10、请解释 Spring Bean 的生命周期？11、Spring Bean 的作用域之间有什么区别？12、什么是 Spring inner beans？13、Spring 框架中的单例 Beans 是线程安全的么？14、请举例说明如何在 Spring 中注入一个 Java Collection？15、如何向 Spring Bean 中注入一个 Java.util.Properties？16、请解释 Spring Bean 的自动装配？17、请解释自动装配模式的区别？18、如何开启基于注解的自动装配？19、请举例解释@Required 注解？20、请举例解释@Autowired 注解？21、请举例说明@Qualifier 注解？22、构造方法注入和设值注入有什么区别？23、Spring 框架中有哪些不同类型的事件？24、FileSystemResource 和 ClassPathResource 有何区别？25、Spring 框架中都用到了哪些设计模式？ 设计模式 10题1.请列举出在 JDK 中几个常用的设计模式？2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式4.在 Java 中，什么叫观察者设计模式（observer design pattern）？5.使用工厂模式最主要的好处是什么？在哪里使用？6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？7.在 Java 中，为什么不允许从静态方法中访问非静态变量？8.设计一个 ATM 机，请说出你的设计思路？9.在 Java 中，什么时候用重载，什么时候用重写？10.举例说明什么情况下会更倾向于使用抽象类而不是接口 springboot 22题什么是 Spring Boot？Spring Boot 有哪些优点？什么是 JavaConfig？如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot 中的监视器是什么？如何在 Spring Boot 中禁用 Actuator 端点安全性？如何在自定义端口上运行 Spring Boot 应用程序？什么是 YAML？如何实现 Spring Boot 应用程序的安全性？如何集成 Spring Boot 和 ActiveMQ？如何使用 Spring Boot 实现分页和排序？什么是 Swagger？你用 Spring Boot 实现了它吗？什么是 Spring Profiles？什么是 Spring Batch？什么是 FreeMarker 模板？如何使用 Spring Boot 实现异常处理？您使用了哪些 starter maven 依赖项？什么是 CSRF 攻击？什么是 WebSockets？什么是 AOP？什么是 Apache Kafka？我们如何监视所有 Spring Boot 微服务？ Netty10题BIO、NIO和AIO的区别？NIO的组成？Netty的特点？Netty的线程模型？TCP 粘包/拆包的原因及解决方法？了解哪几种序列化协议？如何选择序列化协议？Netty的零拷贝实现？Netty的高性能表现在哪些方面？NIOEventLoopGroup源码？ Redis 16题什么是redis?Reids的特点Redis支持的数据类型Redis是单进程单线程的虚拟内存Redis锁读写分离模型数据分片模型Redis的回收策略使用Redis有哪些好处？redis相比memcached有哪些优势？4redis常见性能问题和解决方案MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据245Memcache与Redis的区别都有哪些？Redis 常见的性能问题都有哪些？如何解决？Redis 最适合的场景","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"如何写出让同事无法维护的代码？","slug":"如何写出让同事无法维护的代码？","date":"2019-06-20T02:39:50.000Z","updated":"2019-06-21T05:42:49.748Z","comments":true,"path":"2019/06/20/ru-he-xie-chu-rang-tong-shi-wu-fa-wei-hu-de-dai-ma/","link":"","permalink":"http://chenguoji.com/2019/06/20/ru-he-xie-chu-rang-tong-shi-wu-fa-wei-hu-de-dai-ma/","excerpt":"","text":"对，你没看错，本文就是教你怎么写出让同事无法维护的代码。 一、程序命名容易输入的变量名。比如：Fred，asdf 单字母的变量名。比如：a,b,c, x,y,z（如果不够用，可以考虑a1,a2,a3,a4,….） 有创意地拼写错误。比如：SetPintleOpening， SetPintalClosing。这样可以让人很难搜索代码。 抽象。比如：ProcessData, DoIt, GetData… 抽象到就跟什么都没说一样。 缩写。比如：WTF，RTFSC …… （使用拼音缩写也同样给力，比如： BT，TMD，TJJTDS） 随机大写字母。比如：gEtnuMbER.. 重用命名。在内嵌的语句块中使用相同的变量名有奇效。 使用重音字母。比如：int ínt（第二个 ínt不是int） 使用下划线。比如：_, , _。 使用不同的语言。比如混用英语，德语，或是中文拼音。 使用字符命名。比如：slash, asterix, comma… 使用无关的单词。比如：god, superman, iloveu…. 混淆l和1。字母l和数字1有时候是看不出来的。 二、伪装欺诈把注释和代码交织在一起。 for(j=0; j&lt;array_len; j+ =8) { total += array[j+0 ]; total += array[j+1 ]; total += array[j+2 ]; /* Main body of total += array[j+3]; * loop is unrolled total += array[j+4]; * for greater speed. total += array[j+5]; */ total += array[j+6 ]; total += array[j+7 ]; } 代码和显示不一致。 比如，你的界面显示叫postal code，但是代码里确叫 zipcode. 隐藏全局变量。 把使用全局变量以函数参数的方式传递给函数，这样可以让人觉得那个变量不是全局变量。 使用相似的变量名。 如：单词相似，swimmer 和 swimner，字母相似：ilI1| 或 oO08。parselnt 和 parseInt， D0Calc 和 DOCalc。还有这一组：xy_Z, xy__z, _xy_z, _xyz, XY_Z, xY_z, Xy_z。 重载函数。 使用相同的函数名，但是其功能和具体实现完全没有关系。 操作符重载。 重载操作符可以让你的代码变得诡异，感谢CCTV，感谢C++。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 ! ! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。 三、文档和注释在注释中撒谎。 你不用真的去撒谎，只需在改代码的时候不要更新注释就可以了。 注释里面写废话。 比如：/* add 1 to i */ 只注释是什么，而不是为什么。 不要注释秘密。 如果你开发一个航班系统，请你一定要保证每有一个新的航班被加入，就得要修改25个以上的位置的程序。千万别把这个事写在文档中。 注重细节。 当你设计一个很复杂的算法的时候，你一定要把所有的详细细设计都写下来，没有100页不能罢休，段落要有5级以上，段落编号要有500个以上，例如：1.2.4.6.3.13 – Display all impacts for activity where selected mitigations can apply (short pseudocode omitted). 这样，当你写代码的时候，你就可以让你的代码和文档一致，如：Act1_2_4_6_3_13() 千万不要注释度衡单位。比如时间用的是秒还是毫秒，尺寸用的是像素还是英寸，大小是MB还是KB。等等。另外，在你的代码里，你可以混用不同的度衡单位，但也不要注释。 Gotchas。陷阱， 千万不要注释代码中的陷阱。 在注释和文档中发泄不满。 四、程序设计Java Casts。 Java的类型转型是天赐之物。每一次当你从Collection里取到一个object的时候，你都需要把其转回原来的类型。因些，这些转型操作会出现在N多的地方。如果你改变了类型，那么你不一定能改变所有的地方。而编译器可能能检查到，也可能检查不到。 利用Java的冗余。 比如：Bubblegum b = new Bubblegom(); 和 swimmer = swimner + 1; 注意变量间的细微差别。 从不验证。 从不验证输入的数据，从不验证函数的返回值。这样做可以向大家展示你是多么的信任公司的设备和其它程序员 不要封装。 调用者需要知道被调用的所有的细节。 克隆和拷贝。 为了效率，你要学会使用copy + paste。你几乎都不用理解别人的代码，你就可以高效地编程了。 巨大的listener。 写一个listener，然后让你的所有的button类都使用这个listener，这样你可以在这个listener中整出一大堆if…else…语句，相当的刺激。 使用三维数组。 如果你觉得三维还不足够，你可以试试四维。 混用。 同时使用类的get/set方法和直接访问那个public变量。这样做的好处是可以极大的挫败维护人员。 包装，包装，包装。 把你所有的API都包装上6到8遍，包装深度多达4层以上。然后包装出相似的功能。 没有秘密。 把所有的成员都声明成public的。这样，你以后就很难限制其被人使用，而且这样可以和别的代码造成更多的耦合度，可以让你的代码存活得更久。 排列和阻碍。 把drawRectangle(height, width) 改成 drawRectangle(width, height)，等release了几个版本后，再把其改回去。这样维护程序的程序员们很快就不明白哪一个是对的。 把变量改在名字上。 例如，把setAlignment(int alignment)改成，setLeftAlignment, setRightAlignment, setCenterAlignment。 保留你所有的没有使用的和陈旧的变量，方法和代码。 Final你所有的子结点的类， 这样，当你做完这个项目后，没有人可以通过继承来扩展你的类。java.lang.String不也是这样吗？ 避免使用layout。 这样就使得我们只能使用绝对坐标。如果你的老大强制你使用layout，你可以考虑使用GridBagLayout，然后把grid坐标hard code. 环境变量。 如果你的代码需要使用环境变量。那么，你应该把你的类的成员的初始化使用环境变量，而不是构造函数。 使用全局变量。 1）把全局变量的初始化放在不同的函数中，就算这个函数和这个变量没有任何关系，这样能够让我们的维护人员就像做侦探工作一样。2）使用全局变量可以让你的函数的参数变得少一些。 配置文件。 配置文件主要用于一些参数的初始化。在编程中，我们可以让配置文件中的参数名和实际程序中的名字不一样。 膨胀你的类。 让你的类尽可能地拥有各种臃肿和晦涩的方法。比如，你的类只实现一种可能性，但是你要提供所有可能性的方法。不要定义其它的类，把所有的功能都放在一个类中。 使用子类。 面向对象是写出无法维护代码的天赐之物。如果你有一个类有十个成为（变量和方法）你可以考虑写10个层次的继承，然后把这十个属性分别放在这十个层次中。如果可能的话，把这十个类分别放在十个不同的文件中。 混乱你的代码。 使用XML。XML的强大是无人能及的。使用XML你可以把本来只要10行的代码变成100行。而且，还要逼着别人也有XML。（参看，信XML得永生，信XML得自信） 分解条件表达式。 如：把 a==100分解成，a&gt;99 &amp;&amp; a&lt;101 学会利用分号。 如：if ( a );else;{ int d; d = c;} 间接转型。 如：把double转string，写成new Double(d).toString() 而不是 Double.toString(d) 大量使用嵌套。 一个NB的程序员可以在一行代码上使用超过10层的小括号（），或是在一个函数里使用超过20层的语句嵌套{}，把嵌套的if else 转成 [? :] 也是一件很NB的事。 长代码行。 一行的代码越长越好。这样别人阅读时就需要来来回回的 不要过早的return。 不要使用break，这样，你就需要至少5层以上的if-else来处理错误。 不要使用{}。 不要在if else使用{}，尤其是在你重量地使用if-else嵌套时，你甚至可以在其中乱缩进代码，这样一来，就算是最有经验的程序员也会踩上陷阱。 琐碎的封装。 比较封装一个bool类，类里面什么都做，就是一个bool. 循环。 千万不可用for(int i=0; i&lt;n; i++)使用while代替for，交换n和i，把&lt;改成&lt;=，使用 i–调整步伐 。 五、测试1.从不测试。 千万不要测试任何的出错处理，从来也不检测系统调用的返回值。 2.永远不做性能测试。 如果不够快就告诉用户换一个更快的机器。如果你一做测试，那么就可能会要改你的算法，甚至重设计，重新架构。 3.不要写测试案例。 不要做什么代码覆盖率测试，自动化测试。 4.测试是懦夫行为。 一个勇敢的程序员是根本不需要这一步的。太多的程序太害怕他们的老板，害怕失去工作，害怕用户抱怨，甚至被起诉。这种担心害怕直接影响了生产力。如果你对你的代码有强大的信心，那还要什么测试呢？真正的程序员是不需要测试自己的代码的。 六、其他1.你的老板什么都知道。 无论你的老板有多SB，你都要严格地遵照他的旨意办事，这样一来，你会学到更多的知识以及如何写出更加无法维护的代码。 2.颠覆Help Desk。 你要确保你那满是bug的程序永远不要被维护团队知道。当用户打电话和写邮件给你的时候，你就不要理会，就算要理会，让用户重做系统或是告诉用户其帐号有问题，是标准的回答。 3.闭嘴。 对于一些像y2k这样的大bug，你要学会守口如瓶，不要告诉任何人，包括你的亲人好友以及公司的同事和管理层，这样当到那一天的时候，你就可以用这个bug挣钱了。 4.忽悠。 你会学会忽悠，就算你的代码写得很烂，你也要为其挂上GoF设计模式的标签，就算你的项目做得再烂，你也要为其挂上敏捷的标签，让整个团队和公司，甚至整个业界都开始躁动，这样才能真正为难维护的代码铺平道路。 总之，我们的口号是—— Write Everywhere, Read Nowhere 原文：http://mindprod.com/jgloss/unmain.html译者：陈皓 （@左耳朵耗子）译文：http://coolshell.cn/articles/4758.html","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"8种常见SQL错误用法，你中招了吗？","slug":"8种常见SQL错误用法，你中招了吗？","date":"2019-06-18T02:39:50.000Z","updated":"2019-06-20T07:01:19.234Z","comments":true,"path":"2019/06/18/8-chong-chang-jian-sql-cuo-wu-yong-fa-ni-zhong-zhao-liao-ma/","link":"","permalink":"http://chenguoji.com/2019/06/18/8-chong-chang-jian-sql-cuo-wu-yong-fa-ni-zhong-zhao-liao-ma/","excerpt":"","text":"1、LIMIT 语句分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。 SELECT * FROM operation WHERE type = &apos;SQLStats&apos; AND name = &apos;SlowLog&apos; ORDER BY create_time LIMIT 1000, 10; 好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？ 要知道数据库也并不知道第1000000条记录从什么地方开始，即使有索引也需要从头计算一次。出现这种性能问题，多数情形下是程序员偷懒了。 在前端数据浏览翻页，或者大数据分批导出等场景下，是可以将上一页的最大值当成参数作为查询条件的。SQL 重新设计如下： SELECT * FROM operation WHERE type = &apos;SQLStats&apos; AND name = &apos;SlowLog&apos; AND create_time &gt; &apos;2017-03-16 14:00:00&apos; ORDER BY create_time limit 10; 在新设计下查询时间基本固定，不会随着数据量的增长而发生变化。 2、隐式转换SQL语句中查询变量和字段定义类型不匹配是另一个常见的错误。比如下面的语句： mysql&gt; explain extended SELECT * &gt; FROM my_balance b &gt; WHERE b.bpn = 14000000123 &gt; AND b.isverified IS NULL ; mysql&gt; show warnings; | Warning | 1739 | Cannot use ref access on index &apos;bpn&apos; due to type or collation conversion on field &apos;bpn&apos; 其中字段 bpn 的定义为 varchar(20)，MySQL 的策略是将字符串转换为数字之后再比较。函数作用于表字段，索引失效。 上述情况可能是应用程序框架自动填入的参数，而不是程序员的原意。现在应用框架很多很繁杂，使用方便的同时也小心它可能给自己挖坑。 3、关联更新、删除虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。对于更新或删除需要手工重写成 JOIN。 比如下面 UPDATE 语句，MySQL 实际执行的是循环/嵌套子查询（DEPENDENT SUBQUERY)，其执行时间可想而知。 UPDATE operation o SET status = &apos;applying&apos; WHERE o.id IN (SELECT id FROM (SELECT o.id, o.status FROM operation o WHERE o.group = 123 AND o.status NOT IN ( &apos;done&apos; ) ORDER BY o.parent, o.id LIMIT 1) t); 执行计划： +—-+——————–+——-+——-+—————+———+———+——-+——+—————————————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+——-+——-+—————+———+———+——-+——+—————————————————–+| 1 | PRIMARY | o | index | | PRIMARY | 8 | | 24 | Using where; Using temporary || 2 | DEPENDENT SUBQUERY | | | | | | | | Impossible WHERE noticed after reading const tables || 3 | DERIVED | o | ref | idx_2,idx_5 | idx_5 | 8 | const | 1 | Using where; Using filesort |+—-+——————–+——-+——-+—————+———+———+——-+——+—————————————————–+ 重写为 JOIN 之后，子查询的选择模式从 DEPENDENT SUBQUERY 变成 DERIVED，执行速度大大加快，从7秒降低到2毫秒。 UPDATE operation o JOIN (SELECT o.id, o.status FROM operation o WHERE o.group = 123 AND o.status NOT IN ( &apos;done&apos; ) ORDER BY o.parent, o.id LIMIT 1) t ON o.id = t.id SET status = &apos;applying&apos; 执行计划简化为： +—-+————-+——-+——+—————+——-+———+——-+——+—————————————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——+—————+——-+———+——-+——+—————————————————–+| 1 | PRIMARY | | | | | | | | Impossible WHERE noticed after reading const tables || 2 | DERIVED | o | ref | idx_2,idx_5 | idx_5 | 8 | const | 1 | Using where; Using filesort |+—-+————-+——-+——+—————+——-+———+——-+——+—————————————————–+ 4、混合排序MySQL 不能利用索引进行混合排序。但在某些场景，还是有机会使用特殊方法提升性能的。 SELECT * FROM my_order o INNER JOIN my_appraise a ON a.orderid = o.id ORDER BY a.is_reply ASC, a.appraise_time DESC LIMIT 0, 20 执行计划显示为全表扫描： +—-+————-+——-+——–+————-+———+———+—————+———+-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra+—-+————-+——-+——–+————-+———+———+—————+———+-+| 1 | SIMPLE | a | ALL | idx_orderid | NULL | NULL | NULL | 1967647 | Using filesort || 1 | SIMPLE | o | eq_ref | PRIMARY | PRIMARY | 122 | a.orderid | 1 | NULL |+—-+————-+——-+——–+———+———+———+—————–+———+-+ 由于 is_reply 只有0和1两种状态，我们按照下面的方法重写后，执行时间从1.58秒降低到2毫秒。 SELECT * FROM ((SELECT * FROM my_order o INNER JOIN my_appraise a ON a.orderid = o.id AND is_reply = 0 ORDER BY appraise_time DESC LIMIT 0, 20) UNION ALL (SELECT * FROM my_order o INNER JOIN my_appraise a ON a.orderid = o.id AND is_reply = 1 ORDER BY appraise_time DESC LIMIT 0, 20)) t ORDER BY is_reply ASC, appraisetime DESC LIMIT 20; 5、EXISTS语句MySQL 对待 EXISTS 子句时，仍然采用嵌套子查询的执行方式。如下面的 SQL 语句： SELECT * FROM my_neighbor n LEFT JOIN my_neighbor_apply sra ON n.id = sra.neighbor_id AND sra.user_id = &apos;xxx&apos; WHERE n.topic_status &lt; 4 AND EXISTS(SELECT 1 FROM message_info m WHERE n.id = m.neighbor_id AND m.inuser = &apos;xxx&apos;) AND n.topic_type &lt;&gt; 5 执行计划为： +—-+——————–+——-+——+—–+——————————————+———+——-+———+ —–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+——-+——+ —–+——————————————+———+——-+———+ —–+| 1 | PRIMARY | n | ALL | | NULL | NULL | NULL | 1086041 | Using where || 1 | PRIMARY | sra | ref | | idx_user_id | 123 | const | 1 | Using where || 2 | DEPENDENT SUBQUERY | m | ref | | idx_message_info | 122 | const | 1 | Using index condition; Using where |+—-+——————–+——-+——+ —–+——————————————+———+——-+———+ —–+ 去掉 exists 更改为 join，能够避免嵌套子查询，将执行时间从1.93秒降低为1毫秒。 SELECT * FROM my_neighbor n INNER JOIN message_info m ON n.id = m.neighbor_id AND m.inuser = &apos;xxx&apos; LEFT JOIN my_neighbor_apply sra ON n.id = sra.neighbor_id AND sra.user_id = &apos;xxx&apos; WHERE n.topic_status &lt; 4 AND n.topic_type &lt;&gt; 5 新的执行计划： +—-+————-+——-+——–+ —–+——————————————+———+ —–+——+ —–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——–+ —–+——————————————+———+ —–+——+ —–+| 1 | SIMPLE | m | ref | | idx_message_info | 122 | const | 1 | Using index condition || 1 | SIMPLE | n | eq_ref | | PRIMARY | 122 | ighbor_id | 1 | Using where || 1 | SIMPLE | sra | ref | | idx_user_id | 123 | const | 1 | Using where |+—-+————-+——-+——–+ —–+——————————————+———+ —–+——+ —–+ 6、条件下推外部查询条件不能够下推到复杂的视图或子查询的情况有： 聚合子查询； 含有 LIMIT 的子查询； UNION 或 UNION ALL 子查询； 输出字段中的子查询； 如下面的语句，从执行计划可以看出其条件作用于聚合子查询之后： SELECT * FROM (SELECT target, Count(*) FROM operation GROUP BY target) t WHERE target = &apos;rm-xxxx&apos; +—-+————-+————+——-+—————+————-+———+——-+——+————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+————+——-+—————+————-+———+——-+——+————-+| 1 | PRIMARY | | ref | &lt;auto_key0&gt; | &lt;auto_key0&gt; | 514 | const | 2 | Using where || 2 | DERIVED | operation | index | idx_4 | idx_4 | 519 | NULL | 20 | Using index |+—-+————-+————+——-+—————+————-+———+——-+——+————-+ 确定从语义上查询条件可以直接下推后，重写如下： SELECT target, Count(*) FROM operation WHERE target = &apos;rm-xxxx&apos; GROUP BY target 执行计划变为： +—-+————-+———–+——+—————+——-+———+——-+——+——————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+———–+——+—————+——-+———+——-+——+——————–+| 1 | SIMPLE | operation | ref | idx_4 | idx_4 | 514 | const | 1 | Using where; Using index |+—-+————-+———–+——+—————+——-+———+——-+——+——————–+ 7、提前缩小范围先上初始 SQL 语句： SELECT * FROM my_order o LEFT JOIN my_userinfo u ON o.uid = u.uid LEFT JOIN my_productinfo p ON o.pid = p.pid WHERE ( o.display = 0 ) AND ( o.ostaus = 1 ) ORDER BY o.selltime DESC LIMIT 0, 15 该SQL语句原意是：先做一系列的左连接，然后排序取前15条记录。从执行计划也可以看出，最后一步估算排序记录数为90万，时间消耗为12秒。 +—-+————-+——-+——–+—————+———+———+—————–+——–+—————————————————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——-+——–+—————+———+———+—————–+——–+—————————————————-+| 1 | SIMPLE | o | ALL | NULL | NULL | NULL | NULL | 909119 | Using where; Using temporary; Using filesort || 1 | SIMPLE | u | eq_ref | PRIMARY | PRIMARY | 4 | o.uid | 1 | NULL || 1 | SIMPLE | p | ALL | PRIMARY | NULL | NULL | NULL | 6 | Using where; Using join buffer (Block Nested Loop) |+—-+————-+——-+——–+—————+———+———+—————–+——–+—————————————————-+ 由于最后 WHERE 条件以及排序均针对最左主表，因此可以先对 my_order 排序提前缩小数据量再做左连接。SQL 重写后如下，执行时间缩小为1毫秒左右。 SELECT * FROM ( SELECT * FROM my_order o WHERE ( o.display = 0 ) AND ( o.ostaus = 1 ) ORDER BY o.selltime DESC LIMIT 0, 15 ) o LEFT JOIN my_userinfo u ON o.uid = u.uid LEFT JOIN my_productinfo p ON o.pid = p.pid ORDER BY o.selltime DESC limit 0, 15 再检查执行计划：子查询物化后（select_type=DERIVED)参与 JOIN。虽然估算行扫描仍然为90万，但是利用了索引以及 LIMIT 子句后，实际执行时间变得很小。 +—-+————-+————+——–+—————+———+———+——-+——–+—————————————————-+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+————+——–+—————+———+———+——-+——–+—————————————————-+| 1 | PRIMARY | | ALL | NULL | NULL | NULL | NULL | 15 | Using temporary; Using filesort || 1 | PRIMARY | u | eq_ref | PRIMARY | PRIMARY | 4 | o.uid | 1 | NULL || 1 | PRIMARY | p | ALL | PRIMARY | NULL | NULL | NULL | 6 | Using where; Using join buffer (Block Nested Loop) || 2 | DERIVED | o | index | NULL | idx_1 | 5 | NULL | 909112 | Using where |+—-+————-+————+——–+—————+———+———+——-+——–+—————————————————-+ 8、中间结果集下推再来看下面这个已经初步优化过的例子(左连接中的主表优先作用查询条件)： SELECT a.*, c.allocated FROM ( SELECT resourceid FROM my_distribute d WHERE isdelete = 0 AND cusmanagercode = &apos;1234567&apos; ORDER BY salecode limit 20) a LEFT JOIN ( SELECT resourcesid， sum(ifnull(allocation, 0) * 12345) allocated FROM my_resources GROUP BY resourcesid) c ON a.resourceid = c.resourcesid 那么该语句还存在其它问题吗？不难看出子查询 c 是全表聚合查询，在表数量特别大的情况下会导致整个语句的性能下降。 其实对于子查询 c，左连接最后结果集只关心能和主表 resourceid 能匹配的数据。因此我们可以重写语句如下，执行时间从原来的2秒下降到2毫秒。 SELECT a.*, c.allocated FROM ( SELECT resourceid FROM my_distribute d WHERE isdelete = 0 AND cusmanagercode = &apos;1234567&apos; ORDER BY salecode limit 20) a LEFT JOIN ( SELECT resourcesid， sum(ifnull(allocation, 0) * 12345) allocated FROM my_resources r, ( SELECT resourceid FROM my_distribute d WHERE isdelete = 0 AND cusmanagercode = &apos;1234567&apos; ORDER BY salecode limit 20) a WHERE r.resourcesid = a.resourcesid GROUP BY resourcesid) c ON a.resourceid = c.resourcesid 但是子查询 a 在我们的SQL语句中出现了多次。这种写法不仅存在额外的开销，还使得整个语句显的繁杂。使用 WITH 语句再次重写： WITH a AS ( SELECT resourceid FROM my_distribute d WHERE isdelete = 0 AND cusmanagercode = &apos;1234567&apos; ORDER BY salecode limit 20) SELECT a.*, c.allocated FROM a LEFT JOIN ( SELECT resourcesid， sum(ifnull(allocation, 0) * 12345) allocated FROM my_resources r, a WHERE r.resourcesid = a.resourcesid GROUP BY resourcesid) c ON a.resourceid = c.resourcesid 总结数据库编译器产生执行计划，决定着SQL的实际执行方式。但是编译器只是尽力服务，所有数据库的编译器都不是尽善尽美的。 上述提到的多数场景，在其它数据库中也存在性能问题。了解数据库编译器的特性，才能避规其短处，写出高性能的SQL语句。 程序员在设计数据模型以及编写SQL语句时，要把算法的思想或意识带进来。 编写复杂SQL语句要养成使用 WITH 语句的习惯。简洁且思路清晰的SQL语句也能减小数据库的负担 。 来源：https://yq.aliyun.com/articles/72501","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"javascript上传图片限制图片大小及格式","slug":"javascript上传图片限制图片大小及格式","date":"2019-06-16T02:39:50.000Z","updated":"2019-06-21T02:22:26.433Z","comments":true,"path":"2019/06/16/javascript-shang-chuan-tu-pian-xian-zhi-tu-pian-da-xiao-ji-ge-shi/","link":"","permalink":"http://chenguoji.com/2019/06/16/javascript-shang-chuan-tu-pian-xian-zhi-tu-pian-da-xiao-ji-ge-shi/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;javascript上传图片限制图片大小及格式&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 图片类型验证function verificationPicFileType(file) &#123; var flag=false; var fileTypes = [&quot;.jpg&quot;, &quot;.png&quot;]; var filePath = file.value; //当括号里面的值为0、空字符、false 、null 、undefined的时候就相当于false if(filePath)&#123; var isNext = false; var fileEnd = filePath.substring(filePath.indexOf(&quot;.&quot;)); for (var i = 0; i &lt; fileTypes.length; i++) &#123; if (fileTypes[i] == fileEnd) &#123; isNext = true; flag= true; break; &#125; &#125; if (!isNext)&#123; alert(&apos;不接受此文件类型，请上传jpg或png格式文件&apos;); file.value = &quot;&quot;; flag=false; &#125; &#125; return flag;&#125;//图片大小验证 function verificationPicFileSize(file) &#123; var flag=false; var fileSize = 0; var fileMaxSize = 1024;//1M var filePath = file.value; if(filePath)&#123; fileSize =file.files[0].size; var size = fileSize / 1024; if (size &gt; fileMaxSize) &#123; alert(&quot;文件大小不能大于1M！&quot;); file.value = &quot;&quot;; flag=false; &#125;else if (size &lt;= 0) &#123; alert(&quot;文件大小不能为0M！&quot;); file.value = &quot;&quot;; flag=false; &#125;else&#123; flag=true; &#125; &#125; return flag;&#125;//图片尺寸验证 function verificationPicFileMeasure(file) &#123; var filePath = file.value; if(filePath)&#123; //读取图片数据 var filePic = file.files[0]; var reader = new FileReader(); reader.onload = function (e) &#123; var data = e.target.result; //加载图片获取图片真实宽度和高度 var image = new Image(); image.onload=function()&#123; var width = image.width; var height = image.height; if (width == 132 | height == 132)&#123; alert(&quot;文件尺寸符合！&quot;); &#125;else &#123; alert(&quot;文件尺寸应为：132*132！&quot;); file.value = &quot;&quot;; return false; &#125; &#125;; image.src= data; &#125;; reader.readAsDataURL(filePic); &#125;else&#123; return false; &#125; &#125;//图片验证 function checkFile(file) &#123; debugger; //文件为空判断 if (file === null || file === undefined) &#123; alert(&quot;请选择您要上传的文件！&quot;); $$(&quot;btnSelect&quot;).innerHTML = &quot;单击选择要上传的照片&quot;; return false; &#125; var typeFlag=verificationPicFileType(file); var sizeFlage=verificationPicFileSize(file); var gs = verificationPicFileMeasure(file); if(true==typeFlag &amp;&amp; true==sizeFlage &amp;&amp; true == gs )&#123; //添加预览图片 document.getElementById(&apos;btnSelect&apos;).innerHTML = &quot;&lt;img class=\\&quot;photo\\&quot; src=\\&quot;&quot;+createObjectURL(file)+&quot;\\&quot;/&gt;&quot;; return true; &#125;else&#123; return false; &#125; &#125;//获取数据的URL地址function createObjectURL(blob) &#123; if (window.URL) &#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL) &#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;br /&gt; &lt;form&gt; &lt;div id=&quot;wp&quot; class=&quot;warpper&quot;&gt; &lt;a id=&quot;btnSelect&quot;&gt;单击选择要上传的照片&lt;/a&gt; &lt;br /&gt; &lt;input id=&quot;uploadFile&quot; type=&quot;file&quot; name=&quot;myPhoto&quot; onchange=&quot;checkFile(this)&quot; /&gt; &lt;div id=&quot;maskLayer&quot; class=&quot;mask-layer&quot; style=&quot;display:none;&quot;&gt; &lt;p&gt;图片正在上传中...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"SQLServer 日期函数大全","slug":"SQLServer 日期函数大全","date":"2019-06-15T07:39:50.000Z","updated":"2019-06-20T06:08:58.935Z","comments":true,"path":"2019/06/15/sqlserver-ri-qi-han-shu-da-quan/","link":"","permalink":"http://chenguoji.com/2019/06/15/sqlserver-ri-qi-han-shu-da-quan/","excerpt":"","text":"一、统计语句1、–统计当前【&gt;当天00点以后的数据】SELECT * FROM 表 WHERE CONVERT(Nvarchar, dateandtime, 111) = CONVERT(Nvarchar, GETDATE(), 111) ORDER BY dateandtime DESC 2、–统计本周SELECT * FROM 表 WHERE datediff(week,[dateadd],getdate())=0 3、–统计本月SELECT * FROM 表 WHERE datediff(month,[dateadd],getdate())=0 4、统计当前SELECT * FROM 表 WHERE datediff(day,[dateadd],getdate())=0 Select * From table with(nolock) Where Convert(varchar(10),[CreateTime],120) = Convert(varchar(10),getDate(),120) 二、时间函数 1、当前系统日期、时间select getdate() 2、dateadd 在向指定日期加上一段时间的基础上，返回新的 datetime 值，例如：向日期加上2天select dateadd(day,2,&apos;2004-10-15&apos;) --返回：2004-10-17 00:00:00.000 3、datediff 返回跨两个指定日期的日期和时间边界数select datediff(day,&apos;2004-09-01&apos;,&apos;2004-09-18&apos;) --返回：17 4、datepart 返回代表指定日期的指定日期部分的整数SELECT DATEPART(month, &apos;2004-10-15&apos;) --返回 10 5、datename 返回代表指定日期的指定日期部分的字符串SELECT datename(weekday, &apos;2004-10-15&apos;) --返回：星期五 6、day(), month(),year() –可以与datepart对照一下select 当前日期=convert(varchar(10),getdate(),120), select 当前时间=convert(varchar(8),getdate(),114), select 今天是周几=datename(dw,&apos;2004-10-15&apos;) select 本年第多少周=datename(week,&apos;2004-10-15&apos;), select 今天是周几=datename(weekday,&apos;2004-10-15&apos;) 7、求相差天数select datediff(day,&apos;2004-01-01&apos;,getdate()) 8、一个月第一天的SELECT DATEADD(mm, DATEDIFF(mm,0,getdate()), 0) 9、本周的星期一SELECT DATEADD(wk, DATEDIFF(wk,0,getdate()), 0) select dateadd(wk,datediff(wk,0,getdate()),6) 10、一年的第一天SELECT DATEADD(yy, DATEDIFF(yy,0,getdate()), 0) 11、季度的第一天SELECT DATEADD(qq, DATEDIFF(qq,0,getdate()), 0) 12、当天的半夜SELECT DATEADD(dd, DATEDIFF(dd,0,getdate()), 0) 13、上个月的最后一天SELECT dateadd(ms,-3,DATEADD(mm, DATEDIFF(mm,0,getdate()), 0)) 14、去年的最后一天SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)) 15、本月的最后一天SELECT dateadd(ms,-3,DATEADD(mm, DATEDIFF(m,0,getdate())+1, 0)) 16、本年的最后一天SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate())+1, 0)) 17、本月的第一个星期一select DATEADD(wk, DATEDIFF(wk,0,dateadd(dd,6-datepart(day,getdate()),getdate())), 0) 18、查询本周注册人数select count(*) from [user] where datediff(week,create_day-1,getdate())=0 19、上周注册人数select count(*) from [user] where datediff(week,create_day-1,getdate())=1 20、本月注册人数select count(*) from [user] where datediff(month,create_day,getdate())=0 21、上月注册人数select count(*) from [user] where datediff(month,create_day,getdate())=1 如果要效率,用一下方式 22、查询本周注册人数select count(*) from [user] where create_day&gt;=dateadd(day,2-datepart(weekday,getdate()),convert(varchar,getdate(),112)) and create_day&lt;dateadd(day,9-datepart(weekday,getdate()),convert(varchar,getdate(),112)) 23、上周注册人数select count(*) from [user] where create_day&gt;=dateadd(day,-5-datepart(weekday,getdate()),convert(varchar,getdate(),112)) and create_day&lt;dateadd(day,2-datepart(weekday,getdate()),convert(varchar,getdate(),112)) 24、本月注册人数select count(*) from [user] where create_day&gt;=dateadd(day,1-day(getdate()),convert(varchar,getdate(),112)) and create_day&lt;dateadd(month,1,dateadd(day,1-day(getdate()),convert(varchar,getdate(),112))) 25、上月注册人数select count(*) from [user] where create_day&gt;=dateadd(month,-1,dateadd(day,1-day(getdate()),convert(varchar,getdate(),112))) and create_day&lt;dateadd(day,1-day(getdate()),convert(varchar,getdate(),112)) 26、本周select count(*) from User where datediff(dd,create_day,getdate()) &lt;= datepart(dw,getdate()) 27、上周select count(*) from User where datediff(dd,create_day,(getdate() - datepart(dw,getdate()))) &lt;= 7 28、本月select count(*) from User where datepart(mm,create_day) = datepart(mm,getdate()) 29、上月select count(*) from User where datepart(mm,create_day) = datepart(mm,getdate()) - 1 30、本周注册人数select count(*) from [User] where datediff(dd,create_day,getdate()) &lt;= datepart(dw,getdate()) 31、上周注册人数select count(*) from [User] where datediff(dd,create_day,(getdate() - datepart(dw,getdate()))) &lt;= 7 32、本月注册人数select count(*) from [User] where datepart(mm,create_day) = datepart(mm,getdate()) 33、上月注册人数select count(*) from [User] where datepart(mm,create_day) = datepart(mm,getdate()) - 1 34、查询今日所有SELECT * from feedback WHERE (DATEDIFF(d,fedtime,GETDATE())=0) ORDER BY fedid DESC month(create_day)=month(getdate())本月 month(create_day)=month(getdate())-1 上月 今天的所有数据：select * from 表名 where DateDiff(dd,datetime类型字段,getdate())=0 昨天的所有数据：select * from 表名 where DateDiff(dd,datetime类型字段,getdate())=1 7天内的所有数据：select * from 表名 where DateDiff(dd,datetime类型字段,getdate())&lt;=7 30天内的所有数据：select * from 表名 where DateDiff(dd,datetime类型字段,getdate())&lt;=30 本月的所有数据：select * from 表名 where DateDiff(mm,datetime类型字段,getdate())=0 本年的所有数据：select * from 表名 where DateDiff(yy,datetime类型字段,getdate())=0 系统函数： 函数 参数/功能 GetDate( ) 返回系统目前的日期与时间 DateDiff (interval,date1,date2) 以interval 指定的方式，返回date2 与date1两个日期之间的差值 date2-date1 DateAdd (interval,number,date) 以interval指定的方式，加上number之后的日期 DatePart (interval,date) 返回日期date中，interval指定部分所对应的整数值 DateName (interval,date) 返回日期date中，interval指定部分所对应的字符串名称 参数 interval的设定值： 值 缩写（Sql Server） Access 和 ASP 说明 Year Yy yyyy 年 1753 ~ 9999 Quarter Qq q 季 1 ~ 4 Month Mm m 月1 ~ 12 Day of year Dy y 一年的日数,一年中的第几日 1-366 Day Dd d 日，1-31 Weekday Dw w 一周的日数，一周中的第几日 1-7 Week Wk ww 周，一年中的第几周 0 ~ 51 Hour Hh h 时0 ~ 23 Minute Mi n 分钟0 ~ 59 Second Ss s 秒 0 ~ 59 Millisecond Ms - 毫秒 0 ~ 999 access 和 asp 中用date()和now()取得系统日期时间；其中DateDiff,DateAdd,DatePart也同是能用于Access和asp中，这些函数的用法也类似 举例： 1.GetDate() 用于sql server :select GetDate() 2.DateDiff(&apos;s&apos;,&apos;2005-07-20&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 514592 秒 3.DateDiff(&apos;d&apos;,&apos;2005-07-20&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 5 天 4.DatePart(&apos;w&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 2 即星期一(周日为1，周六为7) 5.DatePart(&apos;d&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 25即25号 6.DatePart(&apos;y&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 206即这一年中第206天 7.DatePart(&apos;yyyy&apos;,&apos;2005-7-25 22:56:32&apos;)返回值为 2005即2005年 注意:Convert()函数中的各个参数的意义,第一个参数,varchar(10)是目标系统所提供的数据类型，包括 bigint 和 sql_variant。不能使用用户定义的数据类型。第二个参数是你要转换的字段,我这里是[time]。最后一个就是格式了，这个值是可选的:20或者120都可以,它遵循的是[ODBC 规范],输入/输出样式为:yyyy-mm-dd hh:mm:ss[.fff]具体的可以参考Sql Server的联机帮助!","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"坑爹的 Java 可变参数，把我整得够惨。。","slug":"坑爹的 Java 可变参数，把我整得够惨。。","date":"2019-06-10T02:39:50.000Z","updated":"2019-06-10T01:55:52.323Z","comments":true,"path":"2019/06/10/keng-die-de-java-ke-bian-can-shu-ba-wo-zheng-de-gou-can/","link":"","permalink":"http://chenguoji.com/2019/06/10/keng-die-de-java-ke-bian-can-shu-ba-wo-zheng-de-gou-can/","excerpt":"","text":"最近在写一个功能点，用了 Java 中的可变参数，真是把我搞得够惨。。 什么是可变参数？就是方法参数用 Object… args 三个点形式，一个参数可以接收多个参数。 实际的代码就不帖了，来看这个示例吧： 示例1public static void main(String[] args) { test(&quot;name=%s&amp;memo=%s&quot;, &quot;陈国际博客&quot;, &quot;666&quot;); } private static void test(String text, Object... params) { String result = String.format(text, params); System.out.println(result); } 大家猜结果是什么？结果如我们想象： name=陈国际博客&amp;memo=666 示例2public static void main(String[] args) { test(&quot;name=%s&amp;memo=%s&quot;, &quot;陈国际博客&quot;); } private static void test(String text, Object... params) { String result = String.format(text, params, &quot;666&quot;); System.out.println(result); } 我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。 name=[Ljava.lang.Object;@4cb2c100&amp;memo=666 这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。 JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。 关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。 说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ） 正例： public ListlistUsers(String type, Long… ids) {…} 阿里巴巴也是不建议大家合作可变参数的，可知它带来的坑会有多坑。。","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"想成为顶尖 Java 程序员？先过了下面这些问题！","slug":"想成为顶尖 Java 程序员？先过了下面这些问题！","date":"2019-06-09T02:39:50.000Z","updated":"2019-06-10T02:05:21.691Z","comments":true,"path":"2019/06/09/xiang-cheng-wei-ding-jian-java-cheng-xu-yuan-xian-guo-liao-xia-mian-zhe-xie-wen-ti/","link":"","permalink":"http://chenguoji.com/2019/06/09/xiang-cheng-wei-ding-jian-java-cheng-xu-yuan-xian-guo-liao-xia-mian-zhe-xie-wen-ti/","excerpt":"","text":"一、数据结构与算法基础1、说一下几种常见的排序算法和分别的复杂度。 2、用Java写一个冒泡排序算法 3、描述一下链式存储结构。 4、如何遍历一棵二叉树？ 5、倒排一个LinkedList。 6、用Java写一个递归遍历目录下面的所有文件。 二、Java基础接口与抽象类的区别？ Java中的异常有哪几类？分别怎么使用？ 常用的集合类有哪些？比如List如何排序？ ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和优缺点？ 内存溢出是怎么回事？请举一个例子？ ==和equals的区别？ hashCode方法的作用？ NIO是什么？适用于何种场景？ HashMap实现原理，如何保证HashMap的线程安全？ JVM内存结构，为什么需要GC？ NIO模型，select/epoll的区别，多路复用的原理 Java中一个字符占多少个字节，扩展再问int, long, double占多少字节 创建一个类的实例都有哪些办法？ final/finally/finalize的区别？ Session/Cookie的区别？ String/StringBuffer/StringBuilder的区别，扩展再问他们的实现？ Servlet的生命周期？ 如何用Java分配一段连续的1G的内存空间？需要注意些什么？ Java有自己的内存回收机制，但为什么还存在内存泄露的问题呢？ 什么是java序列化，如何实现java序列化?(写一个实例)？ String s = new String(&quot;abc&quot;);创建了几个 String Object? 三、JVMJVM堆的基本结构。 JVM的垃圾算法有哪几种？CMS垃圾回收的基本流程？ JVM有哪些常用启动参数可以调整，描述几个？ 如何查看JVM的内存使用情况？ Java程序是否会内存溢出，内存泄露情况发生？举几个例子。 你常用的JVM配置和调优参数都有哪些？分别什么作用？ JVM的内存结构？ 常用的GC策略，什么时候会触发YGC，什么时候触发FGC？ 四、多线程/并发 如何创建线程？如何保证线程安全？ 如何实现一个线程安全的数据结构 如何避免死锁 Volatile关键字的作用？ HashMap在多线程环境下使用需要注意什么？为什么？ Java程序中启动一个线程是用run()还是start()？ 什么是守护线程？有什么用？ 什么是死锁？如何避免 线程和进程的差别是什么？ Java里面的Threadlocal是怎样实现的？ ConcurrentHashMap的实现原理是？ sleep和wait区别 notify和notifyAll区别 volatile关键字的作 ThreadLocal的作用与实现 两个线程如何串行执行 上下文切换是什么含义 可以运行时kill掉一个线程吗？ 什么是条件锁、读写锁、自旋锁、可重入锁？ 线程池ThreadPoolExecutor的实现原理？ 五、Linux使用与问题分析排查使用两种命令创建一个文件？ 硬链接和软链接的区别？ Linux常用命令有哪些？ 怎么看一个Java线程的资源耗用？ Load过高的可能性有哪些？ /etc/hosts文件什么做用？ 如何快速的将一个文本中所有“abc”替换为“xyz”？ 如何在log文件中搜索找出error的日志？ 发现磁盘空间不够，如何快速找出占用空间最大的文件？ Java服务端问题排查（OOM，CPU高，Load高，类冲突） Java常用问题排查工具及用法（top, iostat, vmstat, sar, tcpdump, jvisualvm, jmap, jconsole） Thread dump文件如何分析（Runnable，锁，代码栈，操作系统线程ID关联） 如何查看Java应用的线程信息？ 六、框架使用描述一下Hibernate的三个状态？ Spring中Bean的生命周期。 SpringMVC或Struts处理请求的流程。 Spring AOP解决了什么问题？怎么实现的？ Spring事务的传播属性是怎么回事？它会影响什么？ Spring中BeanFactory和FactoryBean有什么区别？ Spring框架中IOC的原理是什么？ spring的依赖注入有哪几种方式 struts工作流程 用Spring如何实现一个切面？ Spring 如何实现数据库事务？ Hibernate对一二级缓存的使用，Lazy-Load的理解； mybatis如何实现批量提交？ 七、数据库相关MySQL InnoDB、Mysaim的特点？ 乐观锁和悲观锁的区别？ 数据库隔离级别是什么？有什么作用？ MySQL主备同步的基本原理。 select * from table t where size &gt; 10 group by size order by size的sql语句执行顺序？ 如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署） SQL什么情况下不会使用索引（不包含，不等于，函数） 一般在什么字段上建索引（过滤数据最多的字段） 如何从一张表中查出name字段不包含“XYZ”的所有行？ MySQL，B+索引实现，行锁实现，SQL优化 Redis，RDB和AOF，如何做高可用、集群 如何解决高并发减库存问题 mysql存储引擎中索引的实现机制； 数据库事务的几种粒度； 行锁，表锁；乐观锁，悲观锁 八、网络协议和网络编程TCP建立连接的过程。 TCP断开连接的过程。 浏览器发生302跳转背后的逻辑？ HTTP协议的交互流程。HTTP和HTTPS的差异，SSL的交互流程？ Rest和Http什么关系？ 大家都说Rest很轻量，你对Rest风格如何理解？ TCP的滑动窗口协议有什么用？讲讲原理。 HTTP协议都有哪些方法？ 交换机和路由器的区别？ Socket交互的基本流程？ http协议（报文结构，断点续传，多线程下载，什么是长连接） tcp协议（建连过程，慢启动，滑动窗口，七层模型） webservice协议（wsdl/soap格式，与rest协议的区别） NIO的好处，Netty线程模型，什么是零拷贝 九、Redis等缓存系统/中间件/NoSQL/一致性Hash等列举一个常用的Redis客户端的并发模型。 HBase如何实现模糊查询？ 列举一个常用的消息中间件，如果消息要保序如何实现？ 如何实现一个Hashtable？你的设计如何考虑Hash冲突？如何优化？ 分布式缓存，一致性hash LRU算法，slab分配，如何减少内存碎片 如何解决缓存单机热点问题 什么是布隆过滤器，其实现原理是？ False positive指的是？ memcache与redis的区别 zookeeper有什么功能，选举算法如何进行 map/reduce过程，如何用map/reduce实现两个数据源的联合统计 十、设计模式与重构1、你能举例几个常见的设计模式 2、你在设计一个工厂的包的时候会遵循哪些原则？ 3、你能列举一个使用了Visitor/Decorator模式的开源项目/库吗？ 4、你在编码时最常用的设计模式有哪些？在什么场景下用？ 5、如何实现一个单例？ 6、代理模式（动态代理） 7、单例模式（懒汉模式，并发初始化如何解决，volatile与lock的使用） 8、JDK源码里面都有些什么让你印象深刻的设计模式使用，举例看看？ 本套试题没有答案，仅提供给大家参考。 作者：rowkeyhttps://zhuanlan.zhihu.com/p/31552882","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"12 岁开始学编程，17 岁总结了 7 个重要教训！","slug":"12 岁开始学编程，17 岁总结了 7 个重要教训！","date":"2019-06-08T02:39:50.000Z","updated":"2019-06-10T02:08:32.118Z","comments":true,"path":"2019/06/08/12-sui-kai-shi-xue-bian-cheng-17-sui-zong-jie-liao-7-ge-chong-yao-jiao-xun/","link":"","permalink":"http://chenguoji.com/2019/06/08/12-sui-kai-shi-xue-bian-cheng-17-sui-zong-jie-liao-7-ge-chong-yao-jiao-xun/","excerpt":"","text":"以下为译文： 大家好，我名叫Alec，今年17岁，我从12岁起就开始学习 Web 编程开发了。我远非优秀的开发人员，但我学到了一些普通开发人员应该知晓的经验教训。 以下是我学到的一些经验教训，我认为每个开发人员，特别是新手，都应该了解这些经验教训。 1、没有人无所不知没有开发人员知道一切，所以你也不需要知道一切。 作为一名开发人员，你需要用心学习知识，例如在PHP 5.6版本中操作数组的方法，除此之外还有很多重要的技能需要掌握。是否知道这些小知识点无关紧要，即便忘了也可以上网搜索。 作为开发人员，很多技能远胜于学习这些微不足道的知识，例如： 提高解决问题的能力 提高团队合作和沟通技巧 增加对编程概念和语言的了解 创建优秀的项目来展示你的工作 专注于编写整洁高效的代码 成为开发人员的一个好处是你不需要知道一切。你只需要知道解决问题的方法。 2、Bug有助于学习相信你们都听过《五只小猴子》的童谣，下面是bug版的童谣： 99个Bug在代码里闹， 99个Bug在代码里闹， 打个补丁，把1个改掉。 127个bug在代码里闹…… 如果你在编程的过程中没有遇到任何Bug，那么就意味着你什么都没学到。 没有遇到Bug并不意味着你是一位伟大的开发人员，你太聪明了，压根不会犯错。这只能说明类似的东西你开发过很多次，你已经知道如何避免这些Bug。 遇到Bug说明你成长了。开发中存在无穷无尽的Bug，因此你必须学会处理这些Bug，越快越好。 3、没有必要接受正规的教育17岁的我非常纠结这个问题。我应该上大学攻读计算机科学学位吗？ 这对我来说是一个棘手的问题。但是，大多数读这篇文章的人可能不是17岁，可能你们大多数人已经工作了。 如果你大学毕业，那么绝对没必要再回去攻读计算机科学学位。你也不需要参加编程培训班。 GitHub中一些有趣的项目可以为你代言。如果你能够证明自己拥有编程的能力，那么你的背景并不重要。 这只是一个如何通过最佳方式学习的问题。 我没得选，只能在周末学习编程，因为我不能在高中期间请6个星期的假去参加培训班。 如果你想回到大学攻读计算机科学学位，或参加为期8周的培训班，那尽管去吧。但这没有必要。 4、上网搜索也是一门技术如果你想成为一名出色的开发人员，那么就需要加强上网搜索的能力。能够找到你所需要的解决方案和代码至关重要。 你需要频繁地上网搜索，尤其是在学习一种全新的技术的时候。 有时，你需要将一些不明的东西添加到代码中。有时，你需要找到一个不太理解的问题的解决方案。但好消息是，网上都有答案。 5、勤思考在编写代码的时候，你需要思考：“如何才能用最好的方式编写这段代码？” 这方面我做的并不好，所以经常写出水平很次的解决方案。通常，一旦脑海中涌现某个解决方案，我就会立即动手写出来。大多数时候，问题的第一个解决方案并不是最好的。 写代码无需花费太多时间。任何人都可以快速地编写代码，但结果往往很草率。你需要花时间想出一个优秀、稳定的解决方案。 测试驱动可能很无聊，但是它能够极大地推动你勤思考，因为你必须考虑清楚期望的功能以及实现方式。如果你提前做计划，就无法动手写代码了。 当然，凡事都有例外。我并不是说你应该安静地坐下来仔细考虑每一行代码。 然而，勤思考能够为你省却重构和改bug的时间。 6、当心网上的教程刚开始学习编程时，可以从网上找一些教程，但我认为你应该利用的资源远不止这些教程。 当你按照教程学习编程时，实际上可能什么都学不到。虽然你可能学到了一些知识，但你并没有真正明白自己编写的代码以及这样做的原因。 此外，这些教程还可能会漏掉一些重要的代码。初学者更喜欢直接从教程中复制和粘贴代码，而不会认真思考问题。 一种更好的学习编程的方式是构建自己的项目。找到一小段代码，然后自己编写代码、解决bug、阅读文章和帖子。 最有效的学习方法是东拼西凑出一个能够运行的程序。 7、制表符比空格好读这篇文章的时候，你肯定在想：“很明显，这个小孩肯定喜欢使用空格。”非也，每个人都应该在编程的时候，使用制表符。 我明白，每台计算机上的制表符可能不尽相同。但是，你只需要轻轻敲下制表符就好，而无需哐当哐当地敲打空格键。努力成为喜欢制表符的人吧！ 感谢你阅读本文中介绍的简单而重要的经验教训。如果你有不同的看法，请在下方留言。 原文：https://www.freecodecamp.org/news/7-important-lessons-about-programming-that-ive-learned-at-17-516ae619686/作者：Alec Jones，译：弯月，责编：屠敏译文：CSDN（ID：CSDNnews）","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"七大排序算法精讲，图文+代码，超全！","slug":"七大排序算法精讲，图文+代码，超全！","date":"2019-06-01T02:39:50.000Z","updated":"2019-06-05T05:29:44.214Z","comments":true,"path":"2019/06/01/qi-da-pai-xu-suan-fa-jing-jiang-tu-wen-dai-ma-chao-quan/","link":"","permalink":"http://chenguoji.com/2019/06/01/qi-da-pai-xu-suan-fa-jing-jiang-tu-wen-dai-ma-chao-quan/","excerpt":"","text":"排序的相关概念 排序的分类根据在排序过程中带排序的记录是否全部被放置在内存中，排序分为： 内排序 外排序 1.内排序内排序是在排序整个过程中，带排序的所有记录全部放置在内存中。 影响内排序的主要因素 时间性能。 (主要受比较和移动两种操作的影响） 辅助空间。 算法的复杂性。 内排序的分类 根据排序过程中借助的主要操作，内排序分为： 插入排序 交换排序 选择排序 归并排序 2.外排序外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。 按照算法的复杂度分类 简单算法： 冒泡排序、简单选择排序、直接插入排序。 复杂排序： 希尔排序、堆排序、归并排序、快速排序。 一、冒泡排序算法因为在冒泡排序中要用到顺序表结构和数组两元素的交换，先把这些写成函数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAXSIZE 100 #define TRUE 1 #define FALSE 0 typedef struct { int r[MAXSIZE + 1]; int length; }SqList; void swap(SqList *L, int i, int j){ int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp; } 1.1 冒泡排序的初级版实现冒泡排序（Bubble Sort）是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 void BubblSort0(SqList *L){ int i,j; for (i = 1; i &lt; L-&gt;length; i++) for (j = i+1; j &lt;= L-&gt;length; j++) if (L-&gt;r[i] &gt; L-&gt;r[j]) swap(L, i, j); } 对于这段代码，是最简单的冒泡，其实就是最简单的交换排序而已。它的思路就是让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在第一次循环后一定变成最小值。 假设我们待排序的关键字序列是{9，1，5，8，3，7，4，6，2} 当i = 1时，9与1交换后，在第一位置的1与后面的关键字比较都小，因此它就只最小值。 当i = 2时，第二位置先后由9换成5，换成3，换成2，完成了第二小的数字交换。 后面数字依次比较和交换，得到最终结果。 1.2 冒泡排序的实现对于上面的算法，代码虽然简单易懂，但是效率非常低。可以改进成接下来的代码 void BubbleSort(SqList *L){ int i,j; for (i = 1; i &lt; L-&gt;length; i++) for (j = L-&gt;length - 1; j &gt;= i; j--) if (L-&gt;r[j] &gt; L-&gt;r[j+1]) swap(L, j, j+1); } 代码解释 假设我们待排序的关键字序列是{9，1，5，8，3，7，4，6，2} 当i = 1时，变量j由8反向循环到1，逐个比较，将较小值交换到前面，直到最后找到最小值放置在了第1的位置。 当i = 1、 j = 8时，6 &gt; 2 ，因此交换了它们的位置，j = 7时，4 &gt; 2， 所以交换......直到j = 2时，因为 1 &lt; 2， 所以不交换。 j = 1 时，9 &gt; 1，交换，最终得到最小值1放置第一的位置。 在不断循环的过程中，除了将关键字1放到第一的位置，还将关键字2从第九位置提到了第三的位置，显然比前面的算法有进步。 当i = 2时，变量j由8反向循环到2，逐个比较，在将关键字2交换到第二位置的同时，也将关键字4和3有所提升。 1.3 冒泡排序的优化在排序的过程中，增加一个标记变量flag来记录位置是否发生了变化 如果没有发生交换，说明数组已经有序了。 void BubbleSort1(SqList *L){ int i,j; int flag = TRUE; for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) { flag = FALSE; for (j = L-&gt;length - 1; j &gt;= i; j--) { if (L-&gt;r[j] &gt; L-&gt;r[j+1]) { swap(L, j, j+1); flag = TRUE; } } } } 测试 #define N 9 int main(int argc, const char * argv[]) { int i; int d[N] = {9,1,5,8,3,7,4,6,2}; SqList l0; for (i = 0; i &lt; N; i++) l0.r[i+1] = d[i]; l0.length = N; printf(&quot;排序前：\\n&quot;); for (i = 0; i &lt; l0.length; i++) { printf(&quot;%d &quot;, l0.r[i+1]); } printf(&quot;\\n&quot;); printf(&quot;1.0 初级冒泡排序结果:\\n&quot;); BubblSort0(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf(&quot;%d &quot;, l0.r[i+1]); } printf(&quot;\\n&quot;); printf(&quot;1.1 冒泡排序结果:\\n&quot;); BubbleSort(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf(&quot;%d &quot;, l0.r[i+1]); } printf(&quot;\\n&quot;); printf(&quot;1.2 优化后冒泡排序结果:\\n&quot;); BubbleSort1(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf(&quot;%d &quot;, l0.r[i+1]); } printf(&quot;\\n&quot;); return 0; } 测试结果 二、简单选择排序简单选择排序法(Simple Selection Sort)是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换。 简单选择排序法的工作原理是：每一次从无序组的数据元素中选出最小（或最大）的一个元素，存放在无序组的起始位置，无序组元素减少，有序组元素增加，直到全部待排序的数据元素排完。 void SelectSort(SqList *L){ int i, j, min; for (i = 1; i &lt; L-&gt;length; i++) { min = i; for (j = i + 1; j &lt;= L-&gt;length; j++) { if (L-&gt;r[min] &gt; L-&gt;r[j]) min = j; } if (i != min) swap(L, i, min); } } 代码说明 简单选择排序相对简单，交换移动数据的次数相当少，节约时间。 简单选择排序的时间复杂度为O(n^2)。 三、直接插入排序直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录增1的有序表。 直接插入排序的核心思想：将一个记录插入到一个已经排序好的表中，以得到一个记录增加1的有序表。并且它把当前元素大的记录都往后移动，用以腾出“自己”该插入的位置。当n-1趟插入完成后该记录就是有序序列。 void InsertSort(SqList *L){ int i, j; for (i = 2; i &lt; L-&gt;length; i++) { if (L-&gt;r[i] &lt; L-&gt;r[i-1]) { L-&gt;r[0] = L-&gt;r[i]; for (j = i-1; L-&gt;r[j] &gt; L-&gt;r[0]; j++) L-&gt;r[j+1] = L-&gt;r[i]; L-&gt;r[j+1] = L-&gt;r[0]; } } } 代码说明 直接插入排序的时间复杂度为O(n^2)。 直接插入排序比冒泡和简单选择排序的性能要好一些。 四、希尔排序希尔排序是对直接插入排序的改进： 将原本有大量记录数的记录进行分组。分割成若干个子序列； 对子序列分别进行直接插入排序； 当整个序列都基本有序时（注意是基本有序），再对全体记录进行一次直接插入排序。 所谓的基本有序，就是小的关键字基本在前，大的基本在后面，不大不小的基本在中间，如{9,1,5,8,3,7,5,6,2}，变成{2,1,3,6,4,7,8,9}这样就是基本有序，但是像{1,5,9,7,8,2,4,6}这样9在第三位，2在倒数第三位就不是基本有序。 对于分割子序列，采取跳跃分割的策略： 将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。 增量的选取非常关键，但是现在还是一个数学难题(迄今没有找到一种最好的增量序列),大量研究表明，增量序列为dlta[k] = 2^(t-k+1) - 1时，可以获得不错的效果。 希尔排序的核心思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 void ShellSort(SqList *L){ int i,j; int increment = L-&gt;length; do { increment = increment /3 +1; for (i = increment + 1; i &lt; L-&gt;length; i++) { if (L-&gt;r[i] &lt; L-&gt;r[i-increment]) { L-&gt;r[0] = L-&gt;r[i]; for (j = i - increment; i &gt;0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j]; j -= increment) L-&gt;r[j+increment] = L-&gt;r[j]; L-&gt;r[j+increment] = L-&gt;r[0]; } } } while (increment &gt; 1); } 代码说明 希尔排序的时间复杂度为O(n^(3/2))，要好于直接插入排序的O(n^2); 增量的最后一个增量之必须等于1才行。 由于记录是跳跃式的移动，所以希尔排序不是一种稳定的排序算法。 五、堆排序堆的概念 堆是具有如下性质的完全二叉树： 每个结点的值都大于或等于其其左右孩子结点的值，为大顶堆。 或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 因此根节点一定是堆中所有结点最大（小）者。 如图左边为大顶堆，右边为小顶堆： {% asset_img 3.jpg %} 左边为大顶堆，右边为小顶堆 堆排序算法堆排序（Heap Sort）是利用堆（假设是大顶堆）进行排序。堆排序的核心思想： 将待排序的序列构造成一个大顶堆。 此时，整个序列的最大值就是堆顶的根节点。 将根节点移走(其实就是将它与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素的次小值。 重复上诉操作，便能得到一个有序序列。 {% asset_img 4.jpg %} 堆排序算法核心 如何由一个无序序列构建成一个堆 如何在输出堆顶元素后，调整剩余元素成一个新的堆 堆排序算法代码实现 void HeadAdjust(SqList *L, int s, int m){ int temp, j; temp = L-&gt;r[s]; for (j = 2 *s; j &lt;= m; j *= 2) { if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) j++; if (temp &gt;= L-&gt;r[j]) break; L-&gt;r[s] = L-&gt;r[j]; s = j; } L-&gt;r[s] = temp; } void HeapSort(SqList *L){ int i; for (i = L-&gt;length / 2; i&gt;0; i--) HeadAdjust(L, i, L-&gt;length); for (i = L-&gt;length; i &gt; 1; i--) { swap(L, 1, i); HeadAdjust(L, 1, i-1); } } 堆排序算法代码说明 堆排序方法HeapSort中有两个for循环： 第一个for循环完成将现在的待排序序列构建成一个大顶堆； 第二个for循环完成逐渐将每个最大值的根节点与末尾元素交换，并且再调整其成为大顶堆。 第一个for循环中的i = L-&gt;length / 2,i从[9/2]=4开始，4-&gt;3-&gt;2-&gt;1的变化量。 （这里赋值的原因是这些都是有孩子的结点） 构建好有孩子的结点之后，就可以从上到下、从左到右，将每个将每个非终端结点（非叶子结点）当做根节点,将其和子树调整成大顶堆。 函数HeadAdjust的作用是将数组构建成一个大顶堆，在构建的时候利用了二叉树的性质。 构建堆的时间复杂度为O(n)，重建堆的时间复杂度为O(nlogn)，所以总体来说堆排序的时间复杂度为O(nlogn)，性能上远好于冒泡、简单选择、直接插入的时间复杂度。 在空间复杂度上，由于记录的交换和比较是跳跃式进行的，所以堆排序是一种不稳定的排序方法。 六、归并排序归并排序(Merging Sort)是利用归并的思想实现的。2路归并排序的核心思想如下： 假设初始序列有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2或者1的有序子序列 再两两归并...如此重复，直至得到一个长度为n的有序序列为止。 6.1归并排序的实现思路（递归实现）将序列平均分成两部分 分别对这两部分用递归来归并 将这两部分归并到一起 归并排序的代码实现（递归实现） #pragma - 6.归并排序(递归实现) void Merge(int SR[], int TR[], int i, int m, int n){ int j, k, l; for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) { if (SR[i] &lt; SR[j]) TR[k] = SR[i++]; else TR[k] = SR[j++]; } if (i &lt;= m) { for (l=0; l &lt;= m-i; l++) TR[k+l] = SR[i+l]; } if (j &lt;= n) { for (l=0; l &lt;= n-j; l++) TR[k+l] = SR[j+l]; } } void MSort(int SR[], int TR1[], int s, int t){ int m; int TR2[MAXSIZE+1]; if (s == t) { TR1[s] = SR[s]; }else{ m = (s+t)/2; MSort(SR, TR2, s, m); MSort(SR, TR2, m+1, t); Merge(TR2, TR1, s, m, t); } } void MergeSort(SqList *L){ MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length); } 归并排序的总结（递归实现） 归并排序总的时间复杂度为O(nlogn)，并且这是归并排序算法中最好、最坏、平均的时间性能。 归并排序的空间复杂度为O(n+logn) 归并排序是一种比较占内存，但是效率高且稳定的算法。 6.2归并排序的实现（迭代非递归实现）用迭代实现的话，可以从最小的序列开始归并直到完成。 #pragma - 7.归并排序（迭代实现） void MergePass(int SR[], int TR[], int s, int n){ int i = 1; int j; while (i &lt;= n-2*s+1) { Merge(SR, TR, i, i+s-1, i+2*s-1); i = i+2*s; } if (i &lt; n-s+1) Merge(SR, TR, i, i+s-1, n); else for (j = i; j &lt;= n; j++) TR[j] = SR[j]; } void MergeSort2(SqList *L){ int * TR = (int *)malloc(sizeof(L-&gt;length*sizeof(int))); int k = 1; while (k &lt; L-&gt;length) { MergePass(L-&gt;r, TR, k, L-&gt;length); k = 2*k; MergePass(TR, L-&gt;r, k, L-&gt;length); k = 2*k; } } 归并的迭代实现总结 非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O(n). 并且相对于递归，在时间性能上也有一定的提升，所以使用归并时，尽量使用非递归实现。 七、快速排序快速排序(Quick Sort)的基本思想是： 通过一趟排序将待排序记录分割成独立的两部分 其中一部分记录的关键字均比另一部分记录的关键字小； 则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 快速排序的实现思路 选取一个关键字，放到一个位置，使得它的左边的值都比它小，右边的值都比它大，这个关键字叫做枢轴（pivot) 然后分别对左边和右边进行排序。 快速排序的代码实现 #pragma - 8.快速排序 int Partition(SqList * L, int low, int high){ int pivotkey; pivotkey = L-&gt;r[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high --; swap(L, low, high); while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) high++; swap(L, low, high); } return low; } void QSort(SqList *L, int low, int high){ int pivot; if (low &lt; high) { pivot = Partition(L, low, high); QSort(L, low, pivot-1); QSort(L, pivot+1, high); } } void QuickSort(SqList *L){ QSort(L, 1, L-&gt;length); } 快速排序的代码说明 Partition函数就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的交换到它的右边，它也在交换中不断更改自己的位置，直到完全满足这个要求为止。 快速排序的时间性能取决于快速递归的深度，快排的时间复杂度为O(nlogn)。 快速排序的空间复杂度主要是递归造成的栈空间的使用，平均情况下空间复杂度为O(nlogn)。 由于关键字的比较和交换是跳跃进行的，因此，快排是一种不稳定的排序算法 快速排序的优化 1、优化选取枢轴 在上面的代码中，选取枢轴的方式为： 2、pivotkey = L-&gt;r[low]，即用序列的第一个元素作为枢轴，这是理想情况下 L-&gt;r[low]是中间数。 3、但是对于其他情况，这种固定选取第一个关键子作为首个枢轴的方法就不是很合理。 于是可以用下面的方法优化： 4、 三数取中(median-of-three)法： 取三个关键子进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取。 九数取中(median-of-nine)法： 先从数组中分三次取样，每次取三个数，三个样品各取中数，然后从这三个数当中再取出一个中数作为枢轴 三数取中(median-of-three)法代码： int pivotkey; int m = low + (high - low)/2; if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high); if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low); pivotkey = L-&gt;r[low]; 2、优化不必要的交换 3、优化小数组时的排序方案 4、优化递归操作 快速排序优化后的代码 int Partition1(SqList * L, int low, int high){ int pivotkey; int m = low + (high - low)/2; if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high); if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low); pivotkey = L-&gt;r[low]; L-&gt;r[0] = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; L-&gt;r[low] = L-&gt;r[high]; while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; L-&gt;r[high] = L-&gt;r[low]; } L-&gt;r[low] = L-&gt;r[0]; return low; } void QSort1(SqList *L, int low, int high){ int pivot; if ((high -low) &gt; MAX_LINEGIH_INSERT_SORT) { while (low &lt; high) { pivot = Partition1(L, low, high); QSort1(L, low, pivot-1); low = pivot+1; } }else InsertSort(L); } void QuickSort1(SqList *L){ QSort1(L, 1, L-&gt;length); } 希尔排序相当于直接插入排序的升级，同属于插入排序类堆排序相当于简单选择排序的升级，同属于选择排序类快速排序相当于冒泡排序的升级，同属于交换排序类原文：https://www.jianshu.com/p/876931436177 作者：STzen","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"Eclipse 最常用的 10 组快捷键，个个牛逼！","slug":"Eclipse 最常用的 10 组快捷键，个个牛逼！","date":"2019-05-22T02:39:50.000Z","updated":"2019-06-04T09:28:29.290Z","comments":true,"path":"2019/05/22/eclipse-zui-chang-yong-de-10-zu-kuai-jie-jian-ge-ge-niu-bi/","link":"","permalink":"http://chenguoji.com/2019/05/22/eclipse-zui-chang-yong-de-10-zu-kuai-jie-jian-ge-ge-niu-bi/","excerpt":"","text":"今天，我大概整理了 10 组 Eclipse 我觉得比较常用的牛逼快捷键，希望对你有帮助。 1、打开资源CTRL + SHIFT + R：打开所有类型文件，不包括 JAR 包； CTRL + SHIFT + T：打开 Java 类型文件，包括 JAR 包； 2、查找资源CTRL + F：查找当前编辑器内容； CTRL + H：查找所有文件内容； CTRL + SHIFT + G：快速查找所有引用的地方； 3、代码整理CTRL + SHIFT + F：格式化代码； CTRL + SHIFT + O：去除没有用到的引用； CTRL + SHIFT + M：导入需要的类引用； 4、重命名ALT + SHIFT + R：重命名； CTRL + SHIFT + X：转换大写； CTRL + SHIFT + Y：转换小写； 5、切换编辑器CTRL + E：显示所有打开的编辑器列表； CTRL + SHIFT + E：显示更详细的所有打开的编辑器列表； ALT + 左右方向键：回到上一次/下一次编辑所在的代码； 6、快速处理行CTRL + D：删除当前行； CTRL + ALT + 上下方向键：向上/下复制当前行； ALT + 上下方向键：向上/下替换行； 7、类继承关系CTRL + T：显示当前类继承关系列表； F4：打开当前类继承关系对话框； CTRL + SHIFT + H：打开指定的类继承关系对话框； 8、快速修复CTRL + 1：快速修复问题； 9、重构ALT + SHIFT + L：提取出局部变量； ALT + SHIFT + M：提取出方法； ALT + SHIFT + C：修改当前方法构造； 10.添加注释CTRL + /：用行注释注释当前行或者选择的行； CTRL + SHIFT + C：和上面一样； CTRL + SHIFT + /：用块注释注释选择的行； 大概是这些了，服不服？还有一个 CTRL + SHIFT + L 万能快捷键，不知道有什么按什么快捷键，可以按一组这个快捷键查看，要修改快捷键，就连续按两个这个组合键。","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"为什么培训班出来的程序员总遭人嫌弃？","slug":"为什么培训班出来的程序员总遭人嫌弃？","date":"2019-05-22T02:39:50.000Z","updated":"2019-06-04T09:32:27.159Z","comments":true,"path":"2019/05/22/wei-shi-me-pei-xun-ban-chu-lai-de-cheng-xu-yuan-zong-zao-ren-xian-qi/","link":"","permalink":"http://chenguoji.com/2019/05/22/wei-shi-me-pei-xun-ban-chu-lai-de-cheng-xu-yuan-zong-zao-ren-xian-qi/","excerpt":"","text":"由于it软件行业对人才的需求很大，很多传统行业也纷纷创办“互联网+”项目，加上app开发热潮，微信公众平台也催生了更多的就业岗位。于是it从业人员的薪水也随之水涨船高。同时it培训班也随雨后春笋般涌出，一个个打出的口号都很响。 “0基础入学，三个月包就业”“毕业月入不过万，不收学费”“从前是你找工作，接下来是工作找你”真是人有多大胆，口号就有多不要脸。对于迫切想改变自己境遇的人来说，这些口号无疑是很具诱惑力的。在培训机构的宣传下，好像软件开发行业是一个门槛低，收入高，只要几个月的培训就可以月入过万，实现人生理想的好职业。 可现实是越来越多的企业不想招，甚至明言不招培训班出来的学生。而不少培训班也会教学生隐瞒自己的培训经历，会教学生面试的技巧，包装简历，虚报学历和工作经历，把学生包装成一个具有两年项目开发经验的软件工程师，而且开价往往都不低，动不动就8k以上… 为什么会被嫌弃培训班出身的学生被嫌弃的原因主要有以下几个： 计算机基础知识极其薄弱，基本上只是会简单的业务逻辑，懂得基本的增删改查，自学能力弱，在短期培训过程中，接收的是填鸭式的教育，即使讲师的教学水平极高，学生极努力，也不可能在短时间内将这些知识消化，大多数只是一知半解，知道有这么个概念罢了，面试时也许可以做到应答自如，可实操能力极弱。而且习惯的是视频式的、类似于手把手教学的模式。对于新知识的自学能力是很差的，看文档的能力很弱。 开价高，心浮气躁。大多数参加培训的都不是学计算机专业的。有些甚至以前连电脑都没怎么用过，连打字都很慢。这些人之所以去培训，是因为在原行业混得不好，又听说it行业工资高，才转行过去。 有这种心态的人，做哪个行业都很难有成就，但别说在it行业，要做好软件开发，专注、执着、认真是必备的素质。为钱而来的还是请退场吧。你们把因果关系颠倒了。不是it行业高薪，而是因为专注于这个行业，才高薪。那些靠混的，凭借着互联网热潮上位的，是有可能混到一份不错的offer，可不会长久。 你弱你还有理了有些人因为培训班的身份被拒还很委屈，认为企业对他们有歧视。在此，引用时下热门的句式：“你弱，你还有理了”。 你弱，你还有理了。 不否认，有些人虽然是培训班出身，但很优秀，可这个占比太小了。对于企业用人部门来说，他们不值得去为此而冒险，优秀的企业在招人时是很慎重的，招一个人的成本也是相当高，企业招一个人肯定会综合衡量利弊。尤其是软件开发行业，优秀与平庸的人相差太多了，效率上可能相差十倍以上。 一个优秀的程序员写出诗一样的代码，一个平庸的写出的是屎一样的代码。不仅不可用，还会对整个项目起到污染，连累他人擦屁股。 换位思考，当你处于企业用人单位的角色，你也不会选择冒险去招培训班出身人的，宁愿多花时间，提高offer去招更有可能是靠谱的人。 毕竟，好的程序员是写代码，差的程序员是写bug… 别以为自己真有两年经验千万别相信讲师给你灌输的鬼话：“这几个月就已经让你们有两年的项目经验了”。 复制代码，跟实际经验完全不同！ 那几个月，你学到的只是知识，只是最基础的知识，你并没有得到半点经验！经验是不可能靠他人传授的，因为自己经历过才算得上是经验！没有经历过项目deadline，没有被莫名其妙的bug弄得焦头烂额，没有真正的团队合作经历，就够那几个月复制讲师的代码，就说自己有两年的开发经验了。 打铁还需自身硬那么是不是培训班出身的人就没有机会了？ 当然不是，出身不好，起点差都不代表着前面的路就被堵死了。前面说了那么多嫌弃的话，主要是要让你认识到自己为什么会被嫌弃，而不是以受害者的心态自怨自艾（“受害者心态无济于事”）。 以下是对于真正想从事软件开发行业的人提供的建议： 认清自己的能力，不骄狂自大：因为你真的很弱。不妄自菲薄：因为每个人都是从弱小中成长的。认清自己的能力，是成长的第一步。 尽快摆脱填鸭式教育带来的被动学习方式。诚然，几个月的学习对于新人来说，是极其高效的，能以最快的速度踏入编程的门槛。但绝不能再依赖培训班的学习方式，要知道，你是毕业了，但对于软件开发，你的路还是刚开始，往后的学习是以看文档、看书、搜索资料为主。现在开始就要改变自己的学习习惯，认真地看书，你会发现，那些原本你以为自己懂了的知识，在看书后，才知道自己原先的认知是多么浅薄。 证明自己的能力。程序员证明自己能力最简单的方式就是代码。“Talk is cheap, Show me the code”. 从现在开始，你就要养成输出知识的习惯，可以是写技术博客，也可以是构建个人网站，把这些作品展示出来，现在免费的展示平台那么多，你一定要长久地积累，这些就是你最好的简历。 忘记自己是从培训班出来的，把自己当成一个自学者。优秀的程序员都是野生的，培训班出来的是只是宠物，面试时不用提你培训的经历，虽然这并不丢人，但可能会带来偏见。只要你能展示你的作品，表现你的自学能力，而你自身的能力又过关，其实不管你是什么出身，都无关紧要。（我自己就是文科出身，毕业前连半句代码都看不懂） 总结嫌弃的不是你的出身，而是你的综合素养。 总之，出身差，就靠实力，实力差，就靠态度。你之所以会被嫌弃，不是因为你来自培训班，而是因为你没有摆脱培训班，没有构建自己的知识体系。当然，这些积累是需要长时间的，所以慢慢来，只要你不是奔着钱来的，你总能找到工作，也总能得到成长。 作者：塞亚猫http://www.jianshu.com/p/a3f650d93216","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"MySQL 到底是怎么解决幻读的？","slug":"MySQL 到底是怎么解决幻读的？","date":"2019-05-21T02:39:50.000Z","updated":"2019-06-04T06:12:45.721Z","comments":true,"path":"2019/05/21/mysql-dao-di-shi-zen-me-jie-jue-huan-du-de/","link":"","permalink":"http://chenguoji.com/2019/05/21/mysql-dao-di-shi-zen-me-jie-jue-huan-du-de/","excerpt":"","text":"一、什么是幻读在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做幻行。 二、为什么要解决幻读在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。 三、MySQL 是如何解决幻读的如果你看到了这篇文章，那么我会默认你了解了脏读 、不可重复读与可重复读。 1. 多版本并发控制（MVCC）（快照读/一致性读）多数数据库都实现了多版本并发控制，并且都是靠保存数据快照来实现的。以 InnoDB 为例，每一行中都冗余了两个字断。 一个是行的创建版本，一个是行的删除（过期）版本。具体的版本号（trx_id）存在 information_schema.INNODB_TRX 表中。版本号（trx_id）随着每次事务的开启自增。 事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。 普通的 select 就是快照读。 select * from T where number = 1; 原理：将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。 2. next-key 锁 （当前读）next-key 锁包含两部分： 记录锁（行锁） 间隙锁 记录锁是加在索引上的锁，间隙锁是加在索引之间的。（思考：如果列上没有索引会发生什么？） select * from T where number = 1 for update; select * from T where number = 1 lock in share mode; insert update delete 原理：将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。 其他：MySQL InnoDB 引擎 RR 隔离级别是否解决了幻读引用一个 github 上面的评论 地址： Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读。 a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意dml操作），a事务再select出来的结果在MVCC下还和第一次select一样，接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了，实测在RR级别下确实如此。 如果这样理解的话，Mysql的RR级别确实防不住幻读 有道友回复 地址： 在快照读读情况下，mysql通过mvcc来避免幻读。 在当前读读情况下，mysql通过next-key来避免幻读。 select * from t where a=1;属于快照读 select * from t where a=1 lock in share mode;属于当前读 不能把快照读和当前读得到的结果不一样这种情况认为是幻读，这是两种不同的使用。所以我认为mysql的rr级别是解决了幻读的。 先说结论，MySQL 存储引擎 InnoDB 隔离级别 RR 解决了幻读问题。面试问烂的 MySQL 四种隔离级别，这篇文章建议大家看下。 如引用一问题所说，T1 select 之后 update，会将 T2 中 insert 的数据一起更新，那么认为多出来一行，所以防不住幻读。看着说法无懈可击，但是其实是错误的，InnoDB 中设置了快照读和当前读两种模式，如果只有快照读，那么自然没有幻读问题，但是如果将语句提升到当前读，那么 T1 在 select 的时候需要用如下语法： select * from t for update (lock in share mode) 进入当前读，那么自然没有 T2 可以插入数据这一回事儿了。 注意next-key 固然很好的解决了幻读问题，但是还是遵循一般的定律，隔离级别越高，并发越低。 作者：LastSunhttps://www.cnblogs.com/wdy1184/p/10655180.html","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"困扰我多年的Java泛型<? extends T> 和 <? super T>，终于搞清楚了！","slug":"困扰我多年的Java泛型 extends T 和  super T，终于搞清楚了！","date":"2019-05-20T02:39:50.000Z","updated":"2019-06-03T10:06:12.944Z","comments":true,"path":"2019/05/20/kun-rao-wo-duo-nian-de-java-fan-xing-extends-t-he-super-t-zhong-yu-gao-qing-chu-liao/","link":"","permalink":"http://chenguoji.com/2019/05/20/kun-rao-wo-duo-nian-de-java-fan-xing-extends-t-he-super-t-zhong-yu-gao-qing-chu-liao/","excerpt":"","text":"一、为什么要用通配符和边界？使用泛型的过程中，经常出现一种很别扭的情况。 比如我们有Fruit类，和它的派生类Apple class Fruit{} class Apple 然后有一个最简单的容器：Plate类 盘子里可以放一个泛型的”东西” 我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。 现定义一个“水果盘”，逻辑上水果盘当然可以装苹果。 但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。 实际上，编译器认定的逻辑是这样的： 苹果 IS-A 水果 装苹果的盘子 NOT-IS-A 装水果的盘子 所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系。 所以我们不可以把Plate的引用传递给Plate。 为了让泛型用起来更舒服，Sun的大师们就想出了&lt;? extends T&gt;和&lt;? super T&gt;的办法，来让”水果盘子“和”苹果盘子“之间发生正当关系。 二、上界下面就是上界通配符（Upper Bounds Wildcards） 一个能放水果以及一切是水果派生类的盘子 再直白点就是：啥水果都能放的盘子 这和我们人类的逻辑就比较接近了 Plate&lt;？ extends Fruit&gt;和Plate最大的区别就是：Plate&lt;？ extends Fruit&gt;是Plate及Plate的基类 直接的好处就是，我们可以用“苹果盘”给“水果盘”赋值了。 再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。 在这个体系中，上界通配符Plate&lt;？ extends Fruit&gt;覆盖下图中蓝色的区域。 三、下界相对应的下界通配符（Lower Bounds Wildcards） Plate&lt;? super Fruit&gt; 表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。 Plate&lt;？ super Fruit&gt;是Plate的基类，但不是Plate的基类 对应刚才那个例子，Plate&lt;？ super Fruit&gt;覆盖下图中红色的区域。 四、上下界通配符的副作用边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。 还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set( )新东西，以及从盘子里get( )东西。 1、上界&lt;? extends T&gt;不能往里存，只能往外取 &lt;? extends Fruit&gt;会使往盘子里放东西的set( )方法失效 但取东西get( )方法还有效 比如下面例子里两个set()方法，插入Apple和Fruit都报错。 编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。 可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：capture#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号capture#1。 然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个capture#1匹配，所以就都不允许。 所以通配符&lt;?&gt;和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。 比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer… public &lt;T&gt; List&lt;T&gt; fill(T... t); 但通配符&lt;?&gt;没有这种约束，Plate&lt;?&gt;单纯的就表示：盘子里放了一个东西，是什么我不知道。 2、下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里 使用下界&lt;? super Fruit&gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。 因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。 既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。 但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。 五、PECS原则最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了。 1、频繁往外读取内容的，适合用上界Extends。 2、经常往里插入的，适合用下界Super。 作者：JavaEdge来源：www.jianshu.com/p/ff5f5b7e8b93","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"SQL Server 日期时间如何处理","slug":"SQL Server 日期时间如何处理","date":"2019-05-19T02:39:50.000Z","updated":"2019-05-21T08:59:36.775Z","comments":true,"path":"2019/05/19/sql-server-ri-qi-shi-jian-ru-he-chu-li/","link":"","permalink":"http://chenguoji.com/2019/05/19/sql-server-ri-qi-shi-jian-ru-he-chu-li/","excerpt":"","text":"在SQL Server中，一般获取当前时间用 GetDate() 函数 GetDate()获得的日期由两部分组成，分别是今天的日期和当时的时间： Select GetDate() 用DateName()就可以获得相应的年、月、日，然后再把它们连接起来就可以了： Select Datename(year,GetDate())+&apos;-&apos;+Datename(month,GetDate())+&apos;-&apos;+Datename(day,GetDate()) 另外，DateName()还可以获得到小时、时间、秒、星期几、第几周，分别如下： Select Datename(hour,GetDate()) Select Datename(minute,GetDate()) Select Datename(second,GetDate()) Select Datename(weekDay,GetDate()) Select Datename(week,GetDate()) SQL中的日期类型DateTime的默认格式就是yyyy-mm-dd hh:mi:ss: mmm，可大多数的情况我们只想得到他的日期部分，而不许要后面的时间。 使用Convert()函数： select convert(char(10),GetDate(),120) as Date 第3个参数就是用来设置日期类型数据的显示样式的，下面介绍几种样式的参数： 100 mm dd yyyy 101 mm/dd/yyyy 102 yyyy.mm.dd 103 dd/mm/yyyy 106 dd mm yyyy 108 hh:mi:ss(时间) 111 yyyy/mm/dd 112 yyyymmdd 120 yyyy-mm-dd SELECT CONVERT(varchar(100), GETDATE(), 1) 05/09/11 SELECT CONVERT(varchar(100), GETDATE(), 2) 11.05.09 SELECT CONVERT(varchar(100), GETDATE(), 3) 09/05/11 SELECT CONVERT(varchar(100), GETDATE(), 4) 09.05.11 SELECT CONVERT(varchar(100), GETDATE(), 5) 09-05-11 SELECT CONVERT(varchar(100), GETDATE(), 6) 09 05 11 SELECT CONVERT(varchar(100), GETDATE(), 7) 05 09, 11 SELECT CONVERT(varchar(100), GETDATE(), 8) 09:13:14 SELECT CONVERT(varchar(100), GETDATE(), 9) 05 9 2011 9:13:14:670AM SELECT CONVERT(varchar(100), GETDATE(), 10) 05-09-11 SELECT CONVERT(varchar(100), GETDATE(), 11) 11/05/09 SELECT CONVERT(varchar(100), GETDATE(), 12) 110509 SELECT CONVERT(varchar(100), GETDATE(), 13) 09 05 2011 09:13:14:670 SELECT CONVERT(varchar(100), GETDATE(), 14) 09:13:14:670 SELECT CONVERT(varchar(100), GETDATE(), 20) 2011-05-09 09:13:14 SELECT CONVERT(varchar(100), GETDATE(), 21) 2011-05-09 09:13:14.670 SELECT CONVERT(varchar(100), GETDATE(), 22) 05/09/11 9:15:33 AM SELECT CONVERT(varchar(100), GETDATE(), 23) 2011-05-09 SELECT CONVERT(varchar(100), GETDATE(), 24) 09:15:33 SELECT CONVERT(varchar(100), GETDATE(), 25) 2011-05-09 09:15:33.140 SELECT CONVERT(varchar(100), GETDATE(), 100) 05 9 2011 9:15AM SELECT CONVERT(varchar(100), GETDATE(), 101) 05/09/2011 SELECT CONVERT(varchar(100), GETDATE(), 102) 2011.05.09 SELECT CONVERT(varchar(100), GETDATE(), 103) 09/05/2011 SELECT CONVERT(varchar(100), GETDATE(), 104) 09.05.2011 SELECT CONVERT(varchar(100), GETDATE(), 105) 09-05-2011 SELECT CONVERT(varchar(100), GETDATE(), 106) 09 05 2011 SELECT CONVERT(varchar(100), GETDATE(), 107) 05 09, 2011 SELECT CONVERT(varchar(100), GETDATE(), 108) 09:16:38 SELECT CONVERT(varchar(100), GETDATE(), 109) 05 9 2011 9:16:38:543AM SELECT CONVERT(varchar(100), GETDATE(), 110) 05-09-2011 SELECT CONVERT(varchar(100), GETDATE(), 111) 2011/05/09 SELECT CONVERT(varchar(100), GETDATE(), 112) 20110509 SELECT CONVERT(varchar(100), GETDATE(), 113) 09 05 2011 09:17:19:857 SELECT CONVERT(varchar(100), GETDATE(), 114) 09:17:19:857 SELECT CONVERT(varchar(100), GETDATE(), 120) 2011-05-09 09:17:19 SELECT CONVERT(varchar(100), GETDATE(), 121) 2011-05-09 09:17:19.857 SELECT CONVERT(varchar(100), GETDATE(), 126) 2011-05-09T09:17:19.857 SELECT CONVERT(varchar(100), GETDATE(), 131) 6/06/1432 9:17:19:857AM select dateadd(dd,-day(dateadd(month,-1,getdate()))+1,dateadd(month,-1,getdate())) /*上个月一号*/ select dateadd(dd,-day(getdate()),getdate()) /* 上月月底 */ select dateadd(dd,-day(getdate())+1,getdate()) /* 本月一号 */ select dateadd(dd,-day(dateadd(month,1,getdate())),dateadd(month,1,getdate())) /* 本月底 */ select dateadd(dd,-day(dateadd(month,1,getdate()))+1,dateadd(month,1,getdate())) /* 下月一号 */ select dateadd(dd,-day(dateadd(month,2,getdate())),dateadd(month,2,getdate())) /* 下月月底 */","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"Java 诞生日，Java 24 岁了！","slug":"Java 诞生日，Java 24 岁了！","date":"2019-05-19T02:39:50.000Z","updated":"2019-05-30T03:22:41.956Z","comments":true,"path":"2019/05/19/java-dan-sheng-ri-java-24-sui-liao/","link":"","permalink":"http://chenguoji.com/2019/05/19/java-dan-sheng-ri-java-24-sui-liao/","excerpt":"","text":"今天是 Java 诞生日，Java 今年 24 岁了，比栈长还年轻。。还有得搞，别慌！作为一名Java语言的学习者，对Java的起源和发展有个大概的了解应是必要的。 1991年，Sun公司成立Green项目。Oak语言诞生。 1992年11月，Sun公司为Green项目成立FirstPerson公司。 1992年12月3日，被命名为Star7的面向一种类PDA的这台设备进行了展示，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。 1993年，FirstPerson公司重定位Oak。转向到网络应用领域（背景：WWW开始席卷全球）。 1994年6月，Oak技术包括源代码全部免费公开。Oak开发出小型万维网浏览器WebRunner，后更名为Hotjava。Oak编写的Applet让网页由静态转成动态。 1995年，Oak注册登记时，发现该名已被占用，遂更名为Java。1995年5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。 1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。 1996年9月，约8.3万个网页应用了Java技术来制作。 1996年10月，Sun公司发布了Java平台的第一个即时（JIT）编译器。 1997年2月，JDK1.1发布，在随后的3周时间里，达到了22万次的下载量。 1997年4月，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录。 1997年9月，JavaDeveloperConnection社区成员超过十万。 1998年2月，JDK1.1被下载超过2,000,000次。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年4月27日，HotSpot虚拟机发布。HotSpot虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所有版本的Sun JDK的默认虚拟机。 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）。 2000年5月，JDK1.3，JDK1.4相继发布。 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机。 2001年9月24日，J2EE1.3发布。 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升。 2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.0。2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字”2″：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。 2006年11月13日，Java技术的发明者Sun公司宣布，将Java技术作为免费软件对外发布。Sun公司正式发布的有关Java平台标准版的第一批源代码，以及Java迷你版的可执行源代码。 2006年12月，SUN公司发布JRE6.0。 2007年3月起，全世界所有的开发人员均可对Java源代码进行修改 。 2009年4月，甲骨文74亿美元收购Sun。取得java的版权。 2011年7月28日，甲骨文发布java7.0的正式版。 2014年，甲骨文（O）公司发布了Java8正式版。 2017年，甲骨文发布Java9。 2018年3月，甲骨文发布Java10。 2018年9月，甲骨文发布Java11。 2019年3月，甲骨文发布Java12。 参考：www.sohu.com/a/194505161_775404 最后祝我大Java生日快乐！！！","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"html中横线使用","slug":"html中横线使用","date":"2019-05-18T02:39:50.000Z","updated":"2019-05-21T08:45:49.844Z","comments":true,"path":"2019/05/18/html-zhong-heng-xian-shi-yong/","link":"","permalink":"http://chenguoji.com/2019/05/18/html-zhong-heng-xian-shi-yong/","excerpt":"","text":"第一种： &lt;hr style=&quot; height:2px;border:none;border-top:2px dotted #185598;&quot; /&gt; 园点虚线 height:2px;是hr的高度 border:none;是没有边框 border-top:2px dotted #185598;是设置横线的样式 dotted 虚线 #185598 颜色 第二种： &lt;hr style=&quot;height:1px;border:none;border-top:1px dashed #0066CC;&quot; /&gt; 块虚线 第三种： &lt;hr style=&quot;height:1px;border:none;border-top:1px solid #555555;&quot; /&gt; 实线，一条直线 第四种： &lt;hr style=&quot;height:3px;border:none;border-top:3px double red;&quot; /&gt; 两条紧密实线， 第五种： &lt;hr style=&quot;height:5px;border:none;border-top:5px ridge green;&quot; /&gt; 两种颜色 第六种： &lt;hr style=&quot;height:10px;border:none;border-top:10px groove skyblue;&quot; /&gt; 两种颜色 border-top:10px groove skyblue; groove 上颜色 skyblue 下颜色 .style-one {/*内嵌水平线*/ width:80%; margin:0 auto; border: 0; height: 0; border-top: 1px solid rgba(0, 0, 0, 0.1); border-bottom: 1px solid rgba(255, 255, 255, 0.3); } .style-two {/*透明渐变水平线*/ width:80%; margin:0 auto; border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0)); } .style-three{/*渐变*/ width:80%; margin:0 auto; border: 0; height: 1px; background: #333; background-image: linear-gradient(to right, #ccc, #333, #ccc); }","categories":[{"name":"html","slug":"html","permalink":"http://chenguoji.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://chenguoji.com/tags/html/"}],"keywords":[{"name":"html","slug":"html","permalink":"http://chenguoji.com/categories/html/"}]},{"title":"这 17 个 JVM 参数，高级 Java 必须掌握！","slug":"这 17 个 JVM 参数，高级 Java 必须掌握！","date":"2019-05-18T02:39:50.000Z","updated":"2019-05-30T03:19:49.990Z","comments":true,"path":"2019/05/18/zhe-17-ge-jvm-can-shu-gao-ji-java-bi-xu-zhang-wo/","link":"","permalink":"http://chenguoji.com/2019/05/18/zhe-17-ge-jvm-can-shu-gao-ji-java-bi-xu-zhang-wo/","excerpt":"","text":"前言大家都知道，jvm在启动的时候，会执行默认的一些参数。一般情况下，这些设置的默认参数应对一些平常的项目也够用了。但是如果项目特别大了，需要增加一下堆内存的大小、或者是系统老是莫明的挂掉，想查看下gc日志来排查一下错误的原因，都需要咱们手动设置这些参数。 各个参数介绍1.verbose:gc表示，启动jvm的时候，输出jvm里面的gc信息。格式如下： [Full GC 178K-&gt;99K(1984K)， 0.0253877 secs]解读 ：Full GC 就表示执行了一次Full GC的操作，178K 和99K 就表示执行GC前内存容量和执行GC后的内存容量。1984K就表示内存总容量。后面那个是执行本次GC所消耗的时间，单位是秒。 2.-XX:+printGC这个打印的GC信息跟上个一样，就不做介绍了。 3.-XX:+PrintGCDetails打印GC的详细信息。格式如下： –Heap– def new generation total 13824K, used 11223K [0x27e80000, 0x28d80000, 0x28d80000)– eden space 12288K, 91% used [0x27e80000, 0x28975f20, 0x28a80000)– from space 1536K, 0% used [0x28a80000, 0x28a80000, 0x28c00000)– to space 1536K, 0% used [0x28c00000, 0x28c00000, 0x28d80000)– tenured generation total 5120K, used 0K [0x28d80000, 0x29280000, 0x34680000)– the space 5120K, 0% used [0x28d80000, 0x28d80000, 0x28d80200, 0x29280000)– compacting perm gen total 12288K, used 142K [0x34680000, 0x35280000, 0x38680000)– the space 12288K, 1% used [0x34680000, 0x346a3a90, 0x346a3c00, 0x35280000)– ro space 10240K, 44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000)– rw space 12288K, 52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)解读：new generation 就是堆内存里面的新生代。total的意思就是一共的，所以后面跟的就是新生代一共的内存大小。used也就是使用了多少内存大小。0x开头的那三个分别代表的是 底边界，当前边界，高边界。也就是新生代这片内存的起始点，当前使用到的地方和最大的内存地点。 eden space 这个通常被翻译成伊甸园区，是在新生代里面的，一些创建的对象都会先被放进这里。后面那个12288K就表示伊甸园区一共的内存大小，91% used，很明显，表示已经使用了百分之多少。后面的那个0x跟上一行的解释一样。 from space 和to space 是幸存者的两个区。也是属于新生代的。他两个区的大小必须是一样的。因为新生代的GC采用的是复制算法，每次只会用到一个幸存区，当一个幸存区满了的时候，把还是活的对象复制到另个幸存区，上个直接清空。这样做就不会产生内存碎片了。 tenured generation 就表示老年代。 compacting perm 表示永久代。由于这两个的格式跟前面我介绍的那个几乎一样，我就不必介绍了。 4.-XX:+PrintGCTimeStamps打印GC发生的时间戳。格式如下： 289.556: [GC [PSYoungGen: 314113K-&gt;15937K(300928K)] 405513K-&gt;107901K(407680K), 0.0178568 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 293.271: [GC [PSYoungGen: 300865K-&gt;6577K(310720K)] 392829K-&gt;108873K(417472K), 0.0176464 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]解读：289.556表示从jvm启动到发生垃圾回收所经历的的时间。GC表示这是新生代GC（Minor GC）。PSYoungGen表示新生代使用的是多线程垃圾回收器Parallel Scavenge。314113K-&gt;15937K(300928K)]这个跟上面那个GC格式一样。 只不过，这个是表示的是新生代，幸存者区。后面那个是整个堆的大小，GC前和GC后的情况。Times这个显而易见，代表GC的所消耗的时间，用户垃圾回收的时间和系统消耗的时间和最终真实的消耗时间。 5.-X:loggc:log/gc.log这个就表示，指定输出gc.log的文件位置。（我这里写的log/gc.log就表示在当前log的目录里，把GC日志写到叫gc.log的文件里。） 6.-XX:+PrintHeapAtGC表示每次GC后，都打印堆的信息。（这个打印的基本格式跟上面第二条的基本类似，我也就不比多说了。） 7.-XX:+TraceClassLoading监控类的加载。格式如下： •[Loaded java.lang.Object from shared objects file]•[Loaded java.io.Serializable from shared objects file]•[Loaded java.lang.Comparable from shared objects file]•[Loaded java.lang.CharSequence from shared objects file]•[Loaded java.lang.String from shared objects file]•[Loaded java.lang.reflect.GenericDeclaration from shared objects file]•[Loaded java.lang.reflect.Type from shared objects file]使用这个参数就能很清楚的看到那些类被加载的情况了。 8.-XX:+PrintClassHistogram跟踪参数。这个按下Ctrl+Break后，就会打印一下信息： num #instances #bytes class name 1: 890617 470266000 [B 2: 890643 21375432 java.util.HashMap$Node 3: 890608 14249728 java.lang.Long 4: 13 8389712 [Ljava.util.HashMap$Node; 5: 2062 371680 [C 6: 463 41904 java.lang.Class分别显示：序号、实例数量、总大小、类型。 这里面那个类型，B和C的其实就是byte和char类型。 9.-Xmx -Xms这个就表示设置堆内存的最大值和最小值。这个设置了最大值和最小值后，jvm启动后，并不会直接让堆内存就扩大到指定的最大数值。而是会先开辟指定的最小堆内存，如果经过数次GC后，还不能，满足程序的运行，才会逐渐的扩容堆的大小，但也不是直接扩大到最大内存。 10.-Xmn设置新生代的内存大小。 11.-XX:NewRatio新生代和老年代的比例。比如：1：4，就是新生代占五分之一。 12.-XX:SurvivorRatio设置两个Survivor区和eden区的比例。比如：2：8 ，就是一个Survivor区占十分之一。 13.-XX:+HeapDumpOnOutMemoryError发生OOM时，导出堆的信息到文件。 14.-XX:+HeapDumpPath表示，导出堆信息的文件路径。 15.-XX:OnOutOfMemoryError当系统产生OOM时，执行一个指定的脚本，这个脚本可以是任意功能的。比如生成当前线程的dump文件，或者是发送邮件和重启系统。 16.-XX:PermSize -XX:MaxPermSize设置永久区的内存大小和最大值。永久区内存用光也会导致OOM的发生。 17.-Xss设置栈的大小。栈都是每个线程独有一个，所有一般都是几百k的大小。 总结 以上就是我整理的一些jvm设置的参数，当然不止这些。我这只是介绍了些常用的参数。希望能够帮到大家，由于能力有限，如有错误的地方敬请谅解。 作者：SimpleSmilecnblogs.com/Simple-Object/p/10272326.html","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"那天，他无意间瞟了眼程序员的桌面……","slug":"那天，他无意间瞟了眼程序员的桌面……","date":"2019-05-17T02:39:50.000Z","updated":"2019-05-22T09:02:07.855Z","comments":true,"path":"2019/05/17/na-tian-ta-wu-yi-jian-piao-liao-yan-cheng-xu-yuan-de-zhuo-mian/","link":"","permalink":"http://chenguoji.com/2019/05/17/na-tian-ta-wu-yi-jian-piao-liao-yan-cheng-xu-yuan-de-zhuo-mian/","excerpt":"","text":"“爱因斯坦说“要是乱糟糟的桌面意味着杂乱无章的脑袋，那空白桌面意味着什么呢？” 似乎很多在某些领域拥有天赋的人都不喜欢干净整洁的桌面，包括乔布斯和扎克伯格也是，甚至有的人一看到整洁的桌面就会感到一阵惶恐，想马上弄乱。 慢慢的，杂乱无章似乎变成了创造力和脑力劳动者的代名词。对他们来说看似混乱的背后，其实自有一套混乱制造者的逻辑，并不会影响他们执行工作的效率。 这一点在程序员的身上有了很好的印证，程序员在用电脑工作的过程中，灵感随时可以从混乱的桌面获得。 “乱，乱到怀疑人生” 为了将电脑桌面整理干净，大神们开始各显神通，然后慢慢地，桌面就开始……我们来一起看看这些程序员“充满创造力”的桌面吧…… 1 这里的山路十八弯，这里的文件排排站…… 晾衣绳 图标摆放的艺术 如何优雅表现出自己的球迷身份 2 万有引力版桌面也非常炫酷啊 千万星战粉的选择 3 明天需要上线一个新功能 第二天都快下班了，需求还没上线！ 上线ing…… 新产品上线，需要一个程序员祭天 4 看毕业两年，三年工作经验 5 这一定是一位爱岗敬业的小姐姐 当感到工作烦闷的时候，来点小情调也不错 一个人就是一个部门 这些工作咋干不完，全部烧了吧 6 这是一位暴躁的程序员 7 程序员为啥单身？你自己心里没有点 X 数么！ 8 再也没有什么比工作更让我热爱的了 9 来告诉我，你用的是那个浏览器！ 你选哪边？ 真爱程序员远离 IE…远离 IE 这样对 IE 真的合适吗？ 我可算找到你了，嘿 嘿 嘿 太残忍了，轻点，别打死，慢慢折磨 10 重度强迫症同样也很精彩 终极人格分裂 11 欢喜冤家相遇了 法海然后出现，并踢翻了碗里的狗粮 12 别人不写注释……别人不写文档…… 刚刚改了三次需求 需求不知道又改了多少次 当产品经理最后要求改回第一版时 你要相信：程序员们都是脾气极好的 13 虚实结合 把桌面延伸到三维世界中 或许这就是大神吧 14 稳住，快下班了 “他人笑我太凌乱，我笑他人看不穿。”这大概是程序员的电脑桌面被无情吐槽后，内心默念几百遍的潜台词吧。 深深的感受到程序员的“创造力”了吗，想做程序员？想成为全世界人民关注群体中的一员？","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"拯救 Out Of Memory，8个案例带你飞！","slug":"拯救 Out Of Memory，8个案例带你飞！","date":"2019-05-16T02:39:50.000Z","updated":"2019-06-03T01:50:40.718Z","comments":true,"path":"2019/05/16/zheng-jiu-out-of-memory-8-ge-an-li-dai-ni-fei/","link":"","permalink":"http://chenguoji.com/2019/05/16/zheng-jiu-out-of-memory-8-ge-an-li-dai-ni-fei/","excerpt":"","text":"1. Java 堆空间发生频率：5颗星 造成原因无法在 Java 堆中分配对象吞吐量增加应用程序无意中保存了对象引用，对象无法被 GC 回收应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长 解决方案单位对应：GB -&gt; G, g；MB -&gt; M, m；KB -&gt; K, k使用 -Xmx 增加堆大小修复应用程序中的内存泄漏 2. GC 开销超过限制发生频率：5颗星 造成原因Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。 解决方案 使用 -Xmx 增加堆大小使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制修复应用程序中的内存泄漏 3. 请求的数组大小超过虚拟机限制发生频率：2颗星 造成原因应用程序试图分配一个超过堆大小的数组 解决方案使用 -Xmx 增加堆大小修复应用程序中分配巨大数组的 bug 4. Perm gen 空间发生频率：3颗星 造成原因Perm gen 空间包含：类的名字、字段、方法与类相关的对象数组和类型数组JIT 编译器优化 当 Perm gen 空间用尽时，将抛出异常。 解决方案使用 -XX: MaxPermSize 增加 Permgen 大小不重启应用部署应用程序可能会导致此问题。重启 JVM 解决 5. Metaspace发生频率：3颗星 造成原因从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常 解决方案通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小取消 -XX: maxmetsspacedize减小 Java 堆大小,为 MetaSpace 提供更多的可用空间为服务器分配更多的内存可能是应用程序 bug，修复 bug 6. 无法新建本机线程发生频率：5颗星 造成原因内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足 解决方案为机器分配更多的内存减少 Java 堆空间修复应用程序中的线程泄漏。增加操作系统级别的限制ulimit -a用户进程数增大 (-u) 1800使用 -Xss 减小线程堆栈大小 7. 杀死进程或子进程发生频率：1颗星 造成原因内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程 解决方案将进程迁移到不同的机器上给机器增加更多内存 与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。 8. 发生 stack_trace_with_native_method发生频率：1颗星 造成原因本机方法（native method）分配失败打印的堆栈跟踪信息，最顶层的帧是本机方法 解决方案使用操作系统本地工具进行诊断 来自：唐尤华https://bloggceasy.files.wordpress.com/2015/05/outofmemoryerror2.pdf","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"35个可以飞快提高千倍效率的Java语言代码小技巧，你值得拥有！","slug":"35个可以飞快提高千倍效率的Java语言代码小技巧，你值得拥有！","date":"2019-05-15T02:39:50.000Z","updated":"2019-06-20T06:11:13.099Z","comments":true,"path":"2019/05/15/35-ge-ke-yi-fei-kuai-ti-gao-qian-bei-xiao-lu-de-java-yu-yan-dai-ma-xiao-ji-qiao-ni-zhi-de-yong-you/","link":"","permalink":"http://chenguoji.com/2019/05/15/35-ge-ke-yi-fei-kuai-ti-gao-qian-bei-xiao-lu-de-java-yu-yan-dai-ma-xiao-ji-qiao-ni-zhi-de-yong-you/","excerpt":"","text":"前言代码优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。 代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是 1.减小代码的体积 2.提高代码运行的效率 代码优化细节1、尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。 此举能够使性能平均提高50% 。 2、尽量重用对象特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： for (int i = 0; i &lt; list.size(); i++) {...} 建议替换为： for (int i = 0, int length = list.size(); i &lt; length; i++) {...} 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建例如： String str = &quot;aaa&quot;;if (i == 1) { list.add(str); } 建议替换为： if (i == 1) { String str = &quot;aaa&quot;; list.add(str); } 7、慎用异常异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder() // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间； （2）把原来的4096个字符拷贝到新的的字符数组中去。 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令11、乘法和除法使用移位操作例如： for (val = 0; val &lt; 100000; val += 5) { a = val * 8; b = val / 2; } 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： for (val = 0; val &lt; 100000; val += 5) { a = val &lt;&lt; 3; b = val &gt;&gt; 1; } 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用例如： for (int i = 1; i &lt;= count; i++){Object obj = new Object();}这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： Object obj = null;for (int i = 0; i &lt;= count; i++) { obj = new Object(); }这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销15、不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。 16、尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： public class A{private static B b = new B();}此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： if (list instanceof RandomAccess){ for (int i = 0; i &lt; list.size(); i++){}}else{Iterator&lt;?&gt; iterator = list.iterable();while (iterator.hasNext()){iterator.next()}}foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了27、不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。 28、字符串变量和字符串常量equals的时候将字符串常量写在前面这是一个比较常见的小技巧了，如果有以下代码： String str = &quot;123&quot;; if (str.equals(&quot;123&quot;)) {...} 建议修改为： String str = &quot;123&quot;; if (&quot;123&quot;.equals(str)) { ... } 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。 在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： int i = 2;if (i == 1) {…}else{…}C/C++判断”i==1″不成立，所以以0表示，即false。但是如果： int i = 2;if (i = 1) { … }else{ … }万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：int i = 2;if (1 == i) { … }else{ … } 这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法看一下对数组使用toString()打印出来的是什么： public static void main(String[] args){ int[] is = new int[]{1, 2, 3};System.out.println(is.toString());}结果是： [I@18a992f本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果： public static void main(String[] args){long l = 12345678901234L;int i = (int)l;System.out.println(i);}我们可能期望得到其中的某几位，但是结果却是： 1942892530解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f” 2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试： public static void main(String[] args) { int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis();for (int j = 0; j &lt; loopTime; j++){ String str = String.valueOf(i); } System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis();for (int j = 0; j &lt; loopTime; j++) { String str = i.toString(); } System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) { String str = i + &quot;&quot;; } System.out.println(&quot;i + \\&quot;\\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); } 运行结果为： String.valueOf()：11ms Integer.toString()：5ms i + &quot;&quot;：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： public static void main(String[] args) { HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put(&quot;111&quot;, &quot;222&quot;);Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext()) { Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + &quot;\\t&quot; + entry.getValue()); } } 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些 35、对资源的close()建议分开操作意思是，比如我有这么一段代码： try{ XXX.close(); YYY.close(); }catch (Exception e) {...} 建议修改为： try{ XXX.close(); }catch (Exception e) { ... }try{ YYY.close(); }catch (Exception e) { ... } 虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。 来源:http://atjf.top/3WLPmG","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"7年Java后端被淘汰，一路北漂辛酸史","slug":"7年Java后端被淘汰，一路北漂辛酸史","date":"2019-05-14T02:39:50.000Z","updated":"2019-05-21T07:05:35.696Z","comments":true,"path":"2019/05/14/7-nian-java-hou-duan-bei-tao-tai-yi-lu-bei-piao-xin-suan-shi/","link":"","permalink":"http://chenguoji.com/2019/05/14/7-nian-java-hou-duan-bei-tao-tai-yi-lu-bei-piao-xin-suan-shi/","excerpt":"","text":"今天分享一位同行的经历： 本人Java开发6年半不到7年的样子。 英语专业，临毕业跟着隔壁专业去培训了四个月 Java 。 跟他们一起来了北京找工作，一找就是 5 个多月，面试 100 多家公司。最终还是隔壁专业的同学介绍到他们公司才就业了。 入职后同学就是我的领导，技术相对一般，我们做 Java 游戏后端的，时间很快，一眨眼，我就跟着混了四年，每天就看些博客，书籍，业务上也会做功能，但自觉做的比较蠢。没什么太大进步。 四年时间很快乐，跟着老板，同学，从一点不会，到能独立完成工作，能自主做一点小小设计。但技术上说真的，差得太远。 随着心越来越慌，工资水平属实也太低 6K 多，于是四年这个节点，我跳槽了，工资翻倍。这是一份非常苦的工作，曾经2个多月没放假，也曾经连续四天四夜没回家，工作到凌晨 3 点是司空见惯。 然而我只是个小兵，加班加了 10 个月，游戏上线两个月，人员就全部裁掉了。由于 Java 一直感觉没有入门，框架方面 掌握的也比较少，这个 MMO 的项目本是练手大好时机，连忙带懒就也这么过来了。 随后不知道算走运还是算倒霉，找到了上市公司的工作，20K「我梦想中的工资是 25K，如果达到就打算不再跳槽了，为什么是25K？因为游戏Java后端基本上 30K 算是一个封顶，哈，当时比较幼稚，以为就这么干着，早早晚晚也能混到最后，就算技术不行，吃透两套框架，在游戏圈就能立住脚」。 说是走运，因为工作相对简单，我 1 个后端对 6 个前端，听起来挺唬人，但其实还是做业务，但因为只有我一个人接手这个项目，所以我也算是主程，当时我觉得我的人生的每一步真是走的太好了，缺什么来什么，想要架构，想要自己来就有机会了，这一年多感觉特别顺利，也觉得自己终于像是入了门，不再害怕工作上的需求了。 但说是倒霉呢 ，其实也就是因为这一切其实都是假象，我根本还是几年前的那个自己，只是因为业务熟练了，以为自己行了。 这公司也是裁员，我在这里做了一年半不到，临走给了 N+1，美美的拿着钱，找自己梦想中的 25K 去了。并且决定不做游戏了，因为游戏公司有名的就那几家，没啥大发展，还是互联网好，差不到 40K 封顶，我以上所说的封顶都是指很普通的人啊，大佬就别跟我计较了。 就在裁员的第二天，我面试了京东一个物流创新部，好像是这个名字，那天我记得特别清楚，经过了一下午面试（面试的难度真是超级低，我在那里侃侃而谈，最难的问题也只是线程池那几个参数）。 然后，过了。我真的感觉自己要一飞冲天，当时在想，在这里不能做太久，公司的文化太诡异，一切围绕着强东转，公司的人说话好像都在躲着什么东西，加班也是每天固定，然后大小周。因为正赶上过年，面试的人说年后人事会联系我走流程，就能入职。 这一去就天差地别了，我在家等了一个半月，中间经过无数询问面试者，人事等，后来，流程跑着跑着就没了。当时觉得京东真是让人开眼，还特么带这么玩的。 这时候，我还是不知道愁~然而，马上就要觉醒了。我又去面试，还是25K，有时候你认真的要价真的比猥琐要好很多，我当时就是愣要，大部分人还真信。记得收到的OFFER有必要商城，赢时胜等等，后来去了一家做语音的公司负责做云平台。哈哈，这份工作只做了三天半。从入职第一天就夜夜失眠，为毛？因为看不懂代码，压力很大。 以前做游戏觉得大家都是吊丝，每天在一起呼呼哈哈，确实也快乐，有什么需求甚至直接在座位上喊着沟通这样。但是这家公司就比较正规了，我以为互联网公司都是这个样子的，同事之间一天一句话都不说，主程也只给我简单说了说流程，就自己看代码吧。 我虽然技术渣，但有时候对自己要求还是挺高的，总想快速的上手代码，这代码这手上一天，两天，三天，连个皮毛都没看出来，就慌的不行，当时就开始知道自己代码水平有点渣了，但以为自己是不适应，这次找工作其实也挺波折，醒悟是一个缓慢的过程。 所以还是想着回游戏行业，毕竟自己历经三家公司，都没碰到什么难度，虽然寻路啊，地图啊，战斗啊这些自己都完全整不了，但是还是能完成普通工作的，此时的我还以为自己能搭框架呢，啊哈哈。 于是我就辞了，公司真的不错，14薪，要走还好顿要留我。当时以为自己是不适应走的。现在回头想想，其实怕暴露真实代码水平，不好意思才走的「身体不骗人，我的脑子居然会骗自己」。 于是，我开始面游戏了，还是 2 ，但面着面着觉得不对劲，为何大部分面试我都答不上来个啥，三问两问就瘪了。两周时间，居然 10 家只收到 1 个 OFFER，并且是小公司做主程。我开始慌了，很慌，这 10 天里我慢慢认清自己的真实水平了，不敢细想，细想连面向对象都不怎么会，那些继承啊接口啊，从来也没写得好看过，都是照着别人已有的模块，拿来粘贴，还做得挺快。 多线程一想就蒙蔽，数据库就会点简单操作，Linux 也是一样就会个CP MV CAT top啥的，最常用的是 ps -aux|grep。原来，原来我什么都不会啊。但是上天还是眷顾我的，居然这十几家我最看好的那家公司，第 11 个面试。过了，哈哈，当然这时薪资下来了一点，但是我管不了那么多，从上家裁员到现在，已经整整过了 2 个月零一周了，这些天过得真不怎么样，每天都特别焦虑。也瘦了七八斤。 就这样吧，入职好好干吧，我收到OFFER时，暗暗想着，我要为公司肝脑涂地，它在我危难之时，向我伸出了关爱之手，感谢公司。 于是更大的噩梦开始了~~入职到现在 2 个月了，我几乎毛也没做。每天都想逃避都想跑，心脏压得我天天疼，好堵啊，现在也还是如此。这 2 个月我彻底认清了自我，和入职半年的新生小手差不多的水平，一直用这水平干了这六年工作。。 真汗颜，以前用的 SVN,到了新公司学 git，这 git 是真难啊，怎么都学不会，网上那堆教程跟屎一样，看着好像是会了，用着都特么不对，差得远呢，到现在还只会create a branch，写， pull develop ，切回来把develop 合过来，然后再把branch合回到develop，再push，基本上是在用svn的方法在用git，而且 git我感觉很奇怪，好像没几个真的会用，不管是网上还是我的同事。 光说痛苦了，说说自己为什么痛苦吧，我知道每个人都有自己的心酸事。我只是想说说我的。 哎，主要说说新公司的事吧，这么多天了，我死去活来，难受的要命。比如我从刚入行就不大懂开发的根本问题是什么，也许书本上的解释我也看得懂，但是真要理解这件事，应该不是只停留在字面理解，如果你有懂那一天，你应该立刻就知道，它会直接在头脑中告诉你—啊我入门了。 鉴于此，我一直都保存着前几家的源码，我想着，开发既然自己不能理解好，也没有举一返三的能力，也不会自主写出什么东西。那就收集多多的代码，涉及到的哪一部分不懂，可能就能在其中找到例子，灵感。这样就可以在框架层面也不至于什么都没有积累。 这次的工作，服务端也分了好几个进程，之前我都是用redis搞数据沟通，比如你要生成唯一ID，每个子服务里都有redis，incr就好。新的框架也是这个主程用了好多年的了，不想加入新的东西，但是又要求我按他的思路去做，又说代码版权等问题，之前所有的源码都不能给我看，我想其实也是合理的，毕竟我是 P6，高级开发哎。按理说，招我进来可以从 0 开始搭建架构的。我的能力也就是 curd 了，甚至可能 curd 还做不太好，也就说不上怎么能硬气的跟他说明。 比如上面 id 的问题，那我可能就要每个服启动时，去 mysql 查一批id存放在每个子服务上面，设一个警戒值，不够了再取。但是这样吧，对我来说就很难，这就要考虑到警戒值不够用了怎么办，各服务启动时要把id拿到才能对外服务，还有 id 如果实在没有了，可能要进行同步阻塞去查询，但是同步怎么写？不会写同步~~ 另外再举例子，如果是加好友功能，这种单用mysql，而且还弄出一个 dbserver 的服务，什么都要写个异步的协议过去，那加好友原来是： addFriend {各种条件判断，不合条件返回个tips执行加好友} 现在可能变成这样了：addFriend { 异步去查数据库了} gameserver -&gt; dbserver ，当dbserver-&gt;gameserver返回时，又是另一个协议，handler什么的又得另写，执行判断，再返回，等等。 当然写得好的人，这些问题都不存在，而我只会直肠子写Java，就会个 List.add if else for循环。 这基本上是我的全部本领了。就在这框架里有很多难处。还有个问题是怎么写gate与game的玩家session对应，想了N久才想出个办法，包装了个protobuf二层协议，，哦问题多了去了。应该都是开发者该在工作中解决的基本问题，而我一步一个坎。 再者公司的氛围也是头疼的紧，一整天也没人说话，除了要甩锅的时候，根本没人会沟通。交待任务啥的，给我压力也特别大，比如主程今天说，docker了解一样。然后明天让我搭 dokcer 自动化部署流程了。今天说git flow了解一下，明天就要严格执行 git 工作流了。 还是那句话，可能这是一个 P6 真正要掌握的本领，就是有个关键词，然后就能自己看外文文档，然后就能搭建出一个看上去很像样的工程化产品。好吧，这样来看我离真实的 P6 的实力，至少得差 5 个档次。 自己特别的低迷，心脏堵的难受，每天早上一醒来就感觉自己活不起了。有天晚上梦中，看见一堆代码，却怎么看都不懂，又醒不了，难过，懊丧了一整夜，连睡觉的时间都不放过我，自己的痛苦多了就经常跟朋友家人说，到后来反倒让我认清了，什么狗鸡巴朋友，哪有朋友，没人会care你一丁点，各自有自己的烦心事不说吧，没有共同经历的也难为互相理解。 总之，在朋友对我的反应上，基本就是你想多了;你不干得挺好的吗;程序员一个拿那么多钱你还瞎苦恼个什么;不光你，谁没困难;其中特别好的一个也差不多最多宽慰两句，你行，你可以挺过去之类的。之后就再无信息。 当时也是苦恼了好一阵，认识你们有个什么用，你说我最想听什么，我联系你们的目的是什么，哈哈，算了算了，都是故事，你们并没有那么好。但回头吧，仔细想想不禁就明了了这件事。 30多岁了，这是关乎你自己生存的问题，这个问题不是靠什么运气和神迹才能改善的，它积累在你多年生活的每一天里，你的理解是什么，你对工作的态度如何，你怎么利用你的时间的。 这一切的一切都是你自己该解决该思考的问题，别人帮不上任何忙。然而这些年我都是养生过来的，一直都没学会如何去思考，这应该是与有所成就的人最大的区别了。 有人说做职业规划，而我脑中也只有这四个字的浅层意思。也许有的人对这个就比较上心，有着深刻理解也说不定。 也就是说别人怎么决定你的人生，别人怎么决定你的想法，都得自己去选择，自己去承担，指望着别人给你的，只能是「放松心情了解一下努力了解一下」这样看似没用实际也没用的东西。 今天先写到这吧，写得乱糟糟。 无论怎么写也写不出你真的在痛苦时那种无助与万念俱焚，你很难再去回想，你是怎么失眠一个月的，你很难想你在公司楼下对着镜子，颤抖着害怕着不敢回办公桌时的心情。 然而这一切都没意义，生活不会因为你痛苦就突然变好了，别人不会因为你痛苦就能放过你了，这些对任何人都没意义。 我还将继续下去，这家干不了了，还要找下家，还要每天学习「虽然效果不怎么样」。然后等待着，这些迟早该发生的事。 你再想想，今天虽然这么痛苦，是不是可能是你接下来生活的最好的一天了。毕竟你就坐在那里十几个小时，就有人几百上千的送给你。然后我干不下去这行了去做什么，销售？开个麻辣烫店？去工地真正的搬砖？ hi，哈哈哈哈哈，外人看叫矫情，自己看属实是活不起。 话说你有怎样的经历，欢迎留言分享~ 作者：春天花会开foryouoschina.net/question/3465562_2281392","categories":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/categories/java/"}]},{"title":"sql server复制表数据到另一个表","slug":"sql server复制表数据到另一个表","date":"2019-05-13T07:39:50.000Z","updated":"2019-05-21T07:03:00.290Z","comments":true,"path":"2019/05/13/sql-server-fu-zhi-biao-shu-ju-dao-ling-yi-ge-biao/","link":"","permalink":"http://chenguoji.com/2019/05/13/sql-server-fu-zhi-biao-shu-ju-dao-ling-yi-ge-biao/","excerpt":"","text":"SQL Server中，如果目标表存在： insert into 目标表 select * from 原表; SQL Server中,如果目标表不存在： select * into 目标表 from 原表; Oracle中，如果目标表存在： insert into 目标表 select * from 原表;commit; Oracle中，如果目标表不存在： create table 目标表 as select * from 原表;commit;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"Java 中的 SPI 机制是什么鬼？高级 Java 必须掌握！","slug":"Java 中的 SPI 机制是什么鬼？高级 Java 必须掌握！","date":"2019-05-12T02:39:50.000Z","updated":"2019-05-14T01:19:04.580Z","comments":true,"path":"2019/05/12/java-zhong-de-spi-ji-zhi-shi-shi-me-gui-gao-ji-java-bi-xu-zhang-wo/","link":"","permalink":"http://chenguoji.com/2019/05/12/java-zhong-de-spi-ji-zhi-shi-shi-me-gui-gao-ji-java-bi-xu-zhang-wo/","excerpt":"","text":"SPI的全名为：Service Provider Interface，大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。 简单的总结下 Java SPI 机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。 一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 Java SPI 就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。 Java SPI 的具体约定为:当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。 而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader。 1.common-loggingapache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现， 发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提工商实现类。 只要我们的日志实现里包含了这个文件，并在文件里制定 LogFactory工厂接口的实现类即可。 2.jdbc jdbc4.0以前， 开发人员还需要基于Class.forName(“xxx”)的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。 一个内容管理系统有一个搜索模块。是基于接口编程的。搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索 接口定义如下： package my.xyz.spi; import java.util.List; public interface Search { public List serch(String keyword); } A公司采用文件系统搜索的方式实现了 Search接口，B公司采用了数据库系统的方式实现了Search接口。 A公司实现的类：com.A.spi.impl.FileSearchB公司实现的类：com.B.spi.impl.DatabaseSearch 那么A公司发布 实现jar包时，则要在jar包中META-INF/services/my.xyz.spi.Search文件中写下如下内容： com.A.spi.impl.FileSearch 那么B公司发布 实现jar包时，则要在jar包中META-INF/services/my.xyz.spi.Search文件中写下如下内容： com.B.spi.impl.DatabaseSearch 下面是 SPI 测试代码： package com.xyz.factory; import java.util.Iterator; import java.util.ServiceLoader; import my.xyz.spi.Search; public class SearchFactory { private SearchFactory() { } public static Search newSearch() { Search search = null; ServiceLoader&lt;Search&gt; serviceLoader = ServiceLoader.load(Search.class); Iterator&lt;Search&gt; searchs = serviceLoader.iterator(); if (searchs.hasNext()) { search = searchs.next(); } return search; } } 作者：sigangjunblog.csdn.net/sigangjun/article/details/79071850","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"作为字节跳动的面试官，有些话我不得不说！","slug":"作为字节跳动的面试官，有些话我不得不说！","date":"2019-05-11T02:39:50.000Z","updated":"2019-05-13T05:31:17.778Z","comments":true,"path":"2019/05/11/zuo-wei-zi-jie-tiao-dong-de-mian-shi-guan-you-xie-hua-wo-bu-de-bu-shuo/","link":"","permalink":"http://chenguoji.com/2019/05/11/zuo-wei-zi-jie-tiao-dong-de-mian-shi-guan-you-xie-hua-wo-bu-de-bu-shuo/","excerpt":"","text":"大家好，我是字节跳动的一名研发面试官。 2019春招过半，面试也进行了两场，在整个面试过程中，我不断被同学问到各式花样问题： “什么才是研发面试考察的核心？” “考前究竟要不要刷题？” “如果跨专业面试要怎么办？” “如何更好地描述项目经历？” “面试中有哪些面试雷区？” ...... 眼看新的一轮面试即将开始，那些在心中憋了很久的话，今天我不得不说！ 01 代码能力 是研发面试考察的核心！其实说句老实话，研发面试所考察的最核心的能力就是……代码能力！ 代码能力是计算机专业的基础。能否在有限时间内写出清晰简洁、逻辑清晰的代码，不仅可以考察出候选人是否有扎实的基本功，也可以让面试官对候选人在未来是否能够胜任相应的岗位工作有一个基础判断。 面试两场之后我发现，有的候选人刚开始聊项目聊得非常开心，一些细节问题回答得都挺不错的，可一旦到了手写代码这一关，连二分查找都写不出来的大有人在。 平时写的代码多不多，面试之前有没有做过准备，有经验的面试官一眼就可以判断出来。所以这里给大家分享三点建议： 1、加强基本功，增加代码量 多看优秀的源代码，认真从效率、逻辑等方面分析他人如何简洁明晰地实现一个函数，这对提升自己的基本代码能力有很大的帮助。 2、面试前多做题，保持手感很重要 面试之前多做些练习，这不仅可以加快答题速度，也会让自己养成较为规范的答题习惯。 3、复盘笔试答案，思考更优解 最后，不少面试官喜欢在面试的时候复盘笔试题目，与候选人讨论题目的更优解，从而考察考生是否具备主动思考能力。 02 我们不反对刷题 不过更希望大家举一反三在面试过程中，经常会有同学非常骄傲地坦白道：“我没有刷题。” 而在这里我想代表广大面试官表个态：我们不反对刷题，甚至希望同学们在大量做题之后，能够灵活运用、举一反三。 大量做题不仅可以在短时间内提高同学们的解题速度，也会在一定程度上帮助你拓展自己的答题思路。 当然，如果发现同学刷题，面试官也会变种问题，从侧面考察同学是否死记硬背答案。作为春招的面试官、你未来的潜在同事，我们更希望同学们能够灵活贯通。 所以说，该准备准备，该刷题刷题，临时抱佛脚至少体现了你对面试重视是不是？等你题目刷到一定程度，你就会发现自己的能力有了一个量变到质变的提升。关注Java技术栈微信公众号，回复：面试，获取大量Java面试经验。 03 项目描述切忌花哨 突出项目重点，表述逻辑要清晰参与面试的同学们大多都有实习经历。在公司的大环境下，你会在实践中不断夯实代码基础，也会有更多机会接触到最新的技术。面试时如何介绍自己的项目经验？这篇文章参考下。 我们希望大家对过往的实习经历做更深入的思考，不是简简单单描述你在哪里做了什么。毕竟面试官需要在短时间内看到你的个人能力。发挥主观能动性，多在几种不同方法之间做比较，给出在思考之后得出的最优解，会显得你格外与众不同。 除此之外，思考的逻辑性和表达能力也是面试时考察的重点。在面试时切记要简化答案，能表达清楚想法就好，项目描述时只需要简单介绍项目背景，并着重突出项目亮点就可以啦！千万不要过度包装，要知道坦诚清晰可是「字节范儿」中很重要的一点哦～ 04 跨专业面试不会受到区别对待 技术实力最重要面试官们常常会被问到：非计算机专业的同学跨专业面试会不会受到区别对待？ 在这里我想强调：完全不会！ 不同岗位对具体的专业能力要求不同，拿算法岗位举例，只要你代码基础功底过硬，数理能力够强，又对所面试岗位是发自内心的热爱，就算你是学挖掘机技术的，面试官们也是想给你发offer的。这 8 大排序算法，你必须要了解。 算法行业的通用能力就是代码硬实力。如果不具备这种能力，在实际工作中就总会感觉不自信，受人制肘。所以非科班出身的同学们不用受自己的专业所限，但一定要多多锻炼，努力提升自己。 不过这里也想真心地提醒大家几句，千万不要盲从跟风选择自己的职业方向，每个领域都有自己广阔的发展空间，适合自己的才是最好的。越热门的岗位对基础的要求越高，面试官在面试的时候是看得到笔试成绩的，所以还希望大家在面试过程中诚实一点，不懂装懂可是会减分的哦！ 05 哪些行为一定是减分项？除了上述几点，我还想多嘱咐几句： 虽然面试考察最多的是技术基础和代码能力，但是从心理学的角度分析，第一印象也是相当重要的啊喂！ 为了这场面试，逗比的我收敛了表情包，穿上了帅气的格子衫，还把头发梳成了面试官的模样，你说你穿着拖鞋、脸都不洗就来面试是不是有点伤我心了。 如果同学们选择的是视频面试，希望大家在面试前做好充分的准备工作。面试开始之后，如果遇到候选人迟到、没有调试设备、网络不畅通、麦克风关掉、面试环境嘈杂等情况，面试官会给一定时间调试，但是面试体验会受到一定影响，心理上可能会减分的哦！ 诚实守信是做人第一要务，也是字节跳动用人的底线。你们要知道，即使是视频面试，面试官也是可以看到考生行为的！答应我，像类似「一边考试一边用ipad查答案」这种事情千万不要干好嘛！作为考官的我在摄像头另一边看到了也是很尴尬的…… 写在最后的话：不过在面试的过程中同学们也不用紧张，咱们就用专业的语言唠唠嗑，来一场纯技术领域battle，把面试官当朋友，以合作的角度看待这场面试就好啦～ 最后祝大家都能轻松沉稳地应对面试，通过努力离自己的梦想更近一点，加油！ 本文转自公众号：字节跳动招聘","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"以我的亲身经历，告诉大家写简历和面试的技巧！","slug":"以我的亲身经历，告诉大家写简历和面试的技巧！","date":"2019-05-10T07:39:50.000Z","updated":"2019-05-14T03:06:26.847Z","comments":true,"path":"2019/05/10/yi-wo-de-qin-shen-jing-li-gao-su-da-jia-xie-jian-li-he-mian-shi-de-ji-qiao/","link":"","permalink":"http://chenguoji.com/2019/05/10/yi-wo-de-qin-shen-jing-li-gao-su-da-jia-xie-jian-li-he-mian-shi-de-ji-qiao/","excerpt":"","text":"之前我也写过不少介绍面试相关的博文，有些文章的点击量还不低，这些面试相关的经验大多都是从我面试别人的过程中提炼出来了。 在18年底到19年3月，陆续面试了几家公司，有成有不成的，最终进了一家比较满意的知名外企。在本文里，我将介绍我这段时间里更新简历和面试的相关经历。可能面试相关的一些方法，大家能从我之前的博文里看到，但在本文里，大家更能从相关实战性的例子中进一步体会到面试技巧的使用方法。 一、刚开始一定得通过一些小公司练手我打算要换工作，就更新了简历，这时就有不少猎头来找我，刚开始，我不敢面大公司，只是去些规模小的互联网公司。因为一方面，当时我很久不面试了，面试实战技能难免有些荒废，另一方面，离我之前的面试毕竟过了一阵，我不知道当前市面上哪些技术比较值钱。 而且，我在面试前会准备一些针对项目和值钱技术的说辞，这些说辞总要经过实战来演练下。事实上，在和小公司沟通的过程中，进一步提升了我的相关表述能力和相关话术，相当于用小公司来踩坑。相反，如果用大公司的面试失败来换得这些进步，就未免有些可惜了。 所以，我和猎头明说，我想去大公司，但之前，你得让我到一些小公司去练练手，同时，我面试好以后，会告诉你这些小公司的面试题和相关技巧。这样一些猎头就肯先推荐我去小公司了。 二、投简历前，微调简历描述的技巧 公司A在职位介绍里，提到对分布式组件有要求，尤其是负载均衡集群。这块技术我在通用版简历中只是笼统写了下，有nginx+lvs实际经验，既然这个公司有类似要求，我就在简历中细化了这块：用到了lvs+keepalive集群和nginx，它们分别工作在4层和7层，（后省略相关技术使用点描述），最后介绍下效果：用了这个负载均衡组件外，我们系统承受住了xx的并发量。 在公司B的职位介绍里，提到了高并发的需求，那么我就着重写了我压测的相关经验，包括压测环境怎么部署，用到哪些组件，再同时列了些压测后改善系统性能的若干方法。 公司C比较小，需要一位比较资深的能带团队的架构师，那么我在简历中除了介绍技术外，还着重写了带团队的若干经验。 对大家来说，其实面试任何一家公司，它们的职位要求绝对不可能一样。这时大家最好是微调下简历。这种微调，绝对不是胡乱编写，比如上个项目干的是测试，简历中改成开发。而是挖掘下侧重点。 就像我之前给出的案例，对于分布式技术，我上个项目确实用过，但简历中篇幅有限，我不可能面面俱到地写，但既然你们公司有要求，那么我就针对性地详细介绍。 其实这块谈不上是面试技巧，而是语文技巧。首先是审题，理解职位介绍的主要内容，然后再像写作文那样，详细扩展下上个项目里相关技术点。甚至这只是中考语文的考点而不是高考的，但我自己的体会是，在这段时间里针对每份职位介绍我都做了微调，所以基本上是投一份简历就能得到一次面试机会。 三、在换工作前，需要定下预期目标，同时要观察公司的情况我见过不少人，面试成了就进去了，结果虽然钱达到预期，但工作环境和行业背景都不是自己想要的，对自己未来发展很不利。 目前不少公司的情况，比如行业背景（比如金融保险电商等）还有工作强度（加班情况）在网上都能查到，用什么技术（比如分布式技术还是云还是AI）通过打听也能问到。互联网是万能的，甚至如果仔细些，一些离职率，每年工资的增长幅度，甚至这个公司是第几轮融资，一般也能看到。 而且，大家在面试的时候，可以通过现场观察以及和面试官交流，旁敲侧击地打探到上述情况。在这个基础上，大家需要结合自己当前的需求和未来3到5年的发展方向，找若干类适合自己的公司，下面就给些我个人的和我所见到的例子。 比如我不大愿意进创业型公司，也比较排斥长时间的996，所以这类公司我只是拿来练手。（这是我个人的观点） 有段时间，不少P2P金融公司踩雷，所以哪怕面试时，这类公司的面试官会说得天花乱坠（很少有说自己不好的），但这类公司得慎重。 有次我到一个现场去面试，发现公司规模不大，是在一个园区里占1个楼层，且大多是业务人员，开发的不多，而且人事总会说自己公司正在融资，那么这个公司就有可能不稳定，在有其它选项时，我就没去。 我认识一个人，他想在Java分布式这块有所发展，他5年后的目标是架构师，在面试过程中，他就详细问了未来新进组的技术栈，等确定可以了再入职。 换工作是个折腾人的事情，虽然没有十全十美的事情，进新公司后一定会发现和当初的预期有所不同，但如果事先不调查，那么入职后后悔这还是小事，耽搁自己的发展才是大事。 四、面试前，我总要查看职位介绍，以此准备项目介绍在上文里，我一直介绍的是准备简历和定目标，从这部分开始，将介绍准备面试。在之前的博文里，我一直强调项目介绍的重要性，所以当我自己出去面试的时候，这块绝对重视。在准备项目介绍前，我还是会通读应聘职位的技术介绍，然后按如下的步骤来准备。 介绍项目的基本情况，比如这个项目是干嘛的，有哪些模块流程是什么，自己做了哪些，持续了多久，有多少个人参与。这块切记，可以谈下业务，但别深入，因为面试官不熟悉，也不想熟悉候选人的业务，这块时间控制在1分钟之内。 通过介绍项目用到的软件，以及项目的管理方式，来进一步验证项目的真实性，否则很难和培训班给出的项目有差别。 我介绍的时候，就说，项目管理用Maven，部署用jenkins，静态扫描用Sonar，任务管理和bug管理用jira，平时采用敏捷的项目迭代方式，每天有站会，大约1月一个迭代版本。这块大家可以根据自己的情况来介绍，时间也别太长，估计用1分钟也就够了。 这块最重要，是结合业务，抛出项目用到的技术，但别展开。 比如我见过一个职位介绍，里面写到需要有数据库优化的经验，那么我就说，项目里我用过MyCat作为分库分表，（不展开技术），结果上线后，我们数据库能承受住每秒2000个并发请求（说下用好的结果）。 又如一个JD里说要用到微服务技术，那么我就说，项目里用到了Spring Cloud框架，用到了Ribbon，Eureka等组件，容器是Docker。用好以后，在发布时会发现，各模块之间的调用耦合性大大降低。 这块为什么不用展开？第一，当前还在介绍项目，如果展开技术，就会主次不分，面试官会对你的逻辑思路产生质疑。第二，由于在JD里有要求，面试官一定会深入来问，别人问你说总比自己自吹自擂要好。 第三，就好比之前考文科内容，当前在介绍项目时，先应当把所有的点说出来，面上自有机会发挥。 五、准备项目介绍时，我是如何准备值钱技术的这块其实和介绍项目经验时密不可分，这里就拿我介绍过的Netty组件来说明。 准备如何过渡到相关技术的说辞。 这里一定别让面试官感觉你在自说自话。比如我准备的方案1是，在介绍好项目背景后，如果面试官没打断，我就询问，能否介绍其中的Netty细节？得到允许后再说。方案2是把这些技术关联到面试官可能会问的问题上，比如问及网络通讯时介绍Netty，这个事先我会整理一个问题列表，遇到此类问题，我会抛出Netty说辞。对于其他技术也可以照此准备。 结合业务需求点，说下为什么要用这个技术，以及用了有什么好处。 比如为了优化网络通讯协议，所以用基于TCP协议的Netty，我业务模块里的xxx功能是用到netty，再稍微结合业务和Netty展开下。这样的话，面试官就会感觉这个技术你不是仅仅在学习中用到，而且在项目业务里用到。 准备下这个技术里我踩过的坑。 比如通讯过程中我遇到了半包和粘包问题，对此我更是深入了底层代码说明，还有Netty里的堆外内存管理问题，我准备了一个由于管理不善而导致的OOM问题的排查和解决过程（这类问题网上相关的也很多）。 我再准备了用了这个技术后对项目的帮助。 比如Netty是基于TCP协议的，它要比Http协议要轻，所以通讯性能高，且Netty内部的Reactor线程模型对系统的IO帮助很大。 其实准备到这个程度，一般的面试官就不怎么再问了，哪怕面试官再问了一个我不知道的问题，我也可以理直气壮地说不知道了，毕竟我之前已经介绍了不少底层代码，再精通Netty的人也未必能面面俱到地在脱稿的情况下回答出任何问题。 但为了以防万一，我更准备了“源于项目但高于项目”的说辞，一方面证明我平时还会不断专研，另一方面进一步证明我熟悉并能合理使用Netty的底层代码。这方面我准备了如下的内容： Netty的重要组件以及一个请求过来时各模块工作的时序图。 Netty内部零拷贝的原理和好处，对此还专门准备了代码。 Netty读写索引的工作方式。 Netty异步处理的机制。 大家可以想象下，如果在面试中，大家很自信地边写底层代码边解释问题，面试官会对大家有什么评价？其实这些都是可以准备的，我一直没明白，为什么有些人面试前不做任何准备？这些准备的素材又不是找不到~ 下面我再略讲下我MyCAT的准备要点： 还是讲下业务背景，为什么要用？ 如何使用，无非是设置分库规则，改写SQL语句等。 准备下踩到的坑，比如自增长主键在每台机器上都要保证唯一。 然后再结合些底层代码，准备下一条SQL语句是如何分发到对应的分库上的，然后执行好以后又如何返回的。 基本上我面试时说到这个程度后，面试官就不怎么问了。 六、事前评估好自己的薄弱点，想办法让面试官忽略哪怕事先再准备，我们也不能保证自己一定能达到职位介绍里的要求，这时候就得准备一个自己薄弱技术的列表，然后想办法在面试中绕过去，如果绕不过去，就找些替代方案。 比如我对消息通讯组件不熟悉，在面试前我哪怕看代码看文档也无法进一步理解，我就在面试中，故意不提这个环节，抛出其它值钱技术，引诱面试官来问，一般交流一个技术点大约耗时10分钟（边画图边介绍再提问），所以面试过程中详细交流到的最多也就5个点，少的话就3个，在不少面试里就根本没涉及到这块。 有两场面试，技术面试官问及到了，我就说项目里用过，同时多介绍些使用场景，比如用Kafka进行异步消息通知，通过消息中间件来保证交易的幂等性。这样面试官听到我介绍了应用场景，就至少会认为我用过。只有一场面试，面试官在kafka方面问得很细，问到如何集群内防止消息重发的细节，我就没回答上。 也就是说，我通过刻意回避外加介绍业务应用场景，很大程度上隐藏了我了解不深的技术。相反，如果我在简历中大大咧咧地写上用过kafka，那么可能每场面试都会被问到，毕竟在面试中被问倒不是件好事。 又如，我对分布式集群里的失效转移底层细节始终没理解透彻，那么在相关问题上就得非常小心。 有一场面试里，我被问到dubbo+zk集群，这块如果细问，一定会问到失效转移的选举算法，我对此不熟，那么我就先说dubbo的通讯协议，序列化方式以及通过设置超时时间实现服务降级的思路，然后再说zk的部署。最终面试官果然问到选举算法，但之前我已经结合业务谈了dubbo底层代码和zk的相关部署，所以不理解选举算法并没有产生太大的影响。 这里用到的技巧是“偷换概念”，一个问题有多个回答方向，你先让面试官感觉到你在很多领域非常熟悉，那么在个别领域不熟悉就无伤大雅了。 七、和猎头和人事的沟通要点 猎头和我们是一伙的，我们成了猎头也能拿到提成，所以和猎头谈时一定得坦诚，把你优点和弱点都说，猎头会帮忙想办法（比如问面试题）或者是帮忙优化简历。 面试前，一定和猎头谈次，或者问下对这家公司该说什么话，以及之前人的成功失败经验，如果问题，去问下面试题（包括笔试题和口头技术问题）。 面试后，一定第一时间和猎头沟通，这时个人直接去问不合适。而且还可以通过猎头说，哪怕这个岗位没面上，还可以尝试这个公司的其它岗位。 谈工资时一定得先听猎头的建议，不少人对当前行情不了解，或者信心不足，工资没要足，这时让猎头谈是比较合适的，因为猎头就干这个的。一般来说，跳槽后，工资大约有20%到50%的涨幅，有些公司会要前家公司的收入证明，相关问题也可以问猎头。 但和人事谈，就要小心了，毕竟人事是公司开工资的。 人事会问之前公司的离职原因，这时千万别让人事感觉出你不稳定，你可以说为了进一步提升自己的能力，此类问题网上太多，大家可以自己查。 在谈发展方向时，别和JD上的背离。比如JD上是招个技术开发人才，你却和人事说，干了1年后想转Team leader管理岗位，或者说同时想做测试，那么人事就会感觉到，你未来的发展规划和公司想要的不匹配。 总之，面试时人事会非常nice地和你交流，有时候甚至是套话，看你是否稳定，是否能很好地和团队协作，能否加班，我就见过有人卡在人事这关，甚至还不知道为啥被拒。 而且一般你在和人事谈工资前，最好向猎头打探下这个职位的工资范围，在此基础上，如果你感觉面试非常好，或者他们着急要人，或者你感觉加班会很多，可以适当多要些，相反如果你非常想进这个公司，那么就自己斟酌。 八、总结：不能常跳槽，但得经常更新自己的技能在上文里，我通过最近换工作的经历，向大家介绍了相关经验，自认为本文介绍的技巧更有实战性。 我不推荐经常换工作，比如一年换个两家，那么公司会质疑稳定性，但对于我们做IT的人来说，如果手头技术停滞不前，那么自己的竞争高工资的能力也会大大降低。 那么目前该了解哪些技术？以及在这个技术方面我当前掌握得如何？这固然可以通过工作来检验，但工作中接触到的技术毕竟是有限的，这时就可以通过面试来检验自己当前的学习情况，同时也可以通过面试题去了解自己的努力方向。 来源：cnblogs.com/JavaArchitect/p/10720897.html","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"数据库怎么分库分表，垂直？水平？","slug":"数据库怎么分库分表，垂直？水平？","date":"2019-05-09T02:39:50.000Z","updated":"2019-05-14T03:06:17.782Z","comments":true,"path":"2019/05/09/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/","link":"","permalink":"http://chenguoji.com/2019/05/09/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/","excerpt":"","text":"一、数据库瓶颈不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。 1、IO瓶颈第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。 2、CPU瓶颈第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。 第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，增加CPU运算的操作 -&gt; 水平分表。 二、分库分表1、水平分库 1、概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。 2、结果： 每个库的结构都一样； 每个库的数据都不一样，没有交集； 所有库的并集是全量数据； 3、场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。 4、分析：库多了，io和cpu的压力自然可以成倍缓解。 2、水平分表 1、概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。 2、结果： 每个表的结构都一样； 每个表的数据都不一样，没有交集； 所有表的并集是全量数据； 3、场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。 4、分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。 3、垂直分库 1、概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。 2、结果： 每个库的结构都不一样； 每个库的数据也不一样，没有交集； 所有库的并集是全量数据； 3、场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。 4、分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。 4、垂直分表 1、概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。 2、结果： 2.1、每个表的结构都不一样； 2.2、每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据； 2.3、所有表的并集是全量数据； 3、场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。 4、分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。 但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。 三、分库分表工具1、sharding-sphere：jar，前身是sharding-jdbc；2、TDDL：jar，Taobao Distribute Data Layer；3、Mycat：中间件。 注：工具的利弊，请自行调研，官网和社区优先。 四、分库分表步骤根据容量（当前容量和增长量）评估分库或分表个数 -&gt; 选key（均匀）-&gt; 分表规则（hash或range等）-&gt; 执行（一般双写）-&gt; 扩容问题（尽量减少数据的移动）。 五、分库分表问题1、非partition key的查询问题（水平分库分表，拆分策略为常用的hash法）1、端上除了partition key只有一个非partition key作为条件查询 映射法 基因法 注：写入时，基因法生成userid，如图。关于xbit基因，例如要分8张表，23=8，故x取3，即3bit基因。根据userid查询时可直接取模路由到对应的分库或分表。根据username查询时，先通过usernamecode生成函数生成username_code再对其取模路由到对应的分库或分表。id生成常用snowflake算法。 2、端上除了partition key不止一个非partition key作为条件查询 映射法 冗余法 注：按照orderid或buyerid查询时路由到dbobuyer库中，按照sellerid查询时路由到dbo_seller库中。感觉有点本末倒置！有其他好的办法吗？改变技术栈呢？ 3、后台除了partition key还有各种非partition key组合条件查询 NoSQL法 冗余法 2、非partition key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）注：用NoSQL法解决（ES等）。 3、扩容问题（水平分库分表，拆分策略为常用的hash法）1、水平扩容库（升级从库法） 注：扩容是成倍的。 2、水平扩容表（双写迁移法） 第一步：（同步双写）应用配置双写，部署； 第二步：（同步双写）将老库中的老数据复制到新库中； 第三步：（同步双写）以老库为准校对新库中的老数据；第四步：（同步双写）应用去掉双写，部署； 注：双写是通用方案。 六、分库分表总结1、分库分表，首先得知道瓶颈在哪里，然后才能合理地拆分（分库还是分表？水平还是垂直？分几个？）。且不可为了分库分表而拆分。 2、选key很重要，既要考虑到拆分均匀，也要考虑到非partition key的查询。 3、只要能满足需求，拆分规则越简单越好。 作者：尜尜人物https://www.cnblogs.com/littlecharacter/","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"Spring Boot + MyBatis + Maven论坛内容管理系统源码","slug":"Spring Boot + MyBatis + Maven论坛内容管理系统源码","date":"2019-05-08T03:39:50.000Z","updated":"2019-05-08T02:50:58.331Z","comments":true,"path":"2019/05/08/spring-boot-mybatis-maven-lun-tan-nei-rong-guan-li-xi-tong-yuan-ma/","link":"","permalink":"http://chenguoji.com/2019/05/08/spring-boot-mybatis-maven-lun-tan-nei-rong-guan-li-xi-tong-yuan-ma/","excerpt":"","text":"毕设描述xxxForum是一个基于Spring Boot + MyBatis + Maven开发的一个论坛内容管理系统，主要实现了的功能有： 前台页面展示数据、广告展示 内容模块：发帖、评论、帖子分类、分页、回帖统计、访问统计、表单验证 用户模块：权限、资料、头像、邮箱验证 管理：后台管理、统计图表、帖子/分类管理 #开发环境（运行环境） windows 7 , jdk 1.8 #项目采用技术 后端Spring Boot 1.5.5Spring Security 4Mybatis(mybatis-spring-boot-starter 1.3.1)Maven 3.X 前端ThymeleafBootstrapjQueryChart.jsbootstrap-selectdaterangepicker 数据库文件在项目文件里面 项目截图 登录地址http://localhost:8080/ 登录用户名和密码 admin / admin 是否免费收费写码不易，付费后给代码并且提供对应的技术服务支持。 联系我们QQ 搜索我们的群号：814637551 注意事项1.头像如何配置？在电脑选一个盘，新建一个文件夹 例如：在C盘新建一个avatar文件夹，里面存放你的头像图片。找到 application.properties 配置文件 # ============================== # avator location # ============================== resource.staticResourceLocation=C:/avatar/ 写好配置，找到 StaticResourceConfig 类 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //这里也要和之前的对应起来 registry.addResourceHandler(&quot;/avatar/**&quot;).addResourceLocations(&quot;file:C:/avatar/&quot;); } 数据库里面和这对应就可以了！","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/tags/毕业设计/"}],"keywords":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}]},{"title":"SpringMVC方法四种类型返回值总结，你用过几种？","slug":"SpringMVC方法四种类型返回值总结，你用过几种？","date":"2019-05-07T02:39:50.000Z","updated":"2019-05-07T02:29:54.698Z","comments":true,"path":"2019/05/07/springmvc-fang-fa-si-chong-lei-xing-fan-hui-zhi-zong-jie-ni-yong-guo-ji-chong/","link":"","permalink":"http://chenguoji.com/2019/05/07/springmvc-fang-fa-si-chong-lei-xing-fan-hui-zhi-zong-jie-ni-yong-guo-ji-chong/","excerpt":"","text":"SpringMVC 现在算是 Java 领域的一个基础性框架了，很多人天天用，可是对于 SpringMVC 方法的返回值，你又是否完全清楚呢？今天我就来和大家聊一聊 SpringMVC 中四种不同类型的返回值，看看有没有 get 到你的知识盲点？ 1. ModelAndView以前前后端不分的情况下，ModelAndView 应该是最最常见的返回值类型了，现在前后端分离后，后端都是以返回 JSON 数据为主了。后端返回 ModelAndView 这个比较容易理解，开发者可以在 ModelAndView 对象中指定视图名称，然后也可以绑定数据，像下面这样： @RequestMapping(&quot;/test1&quot;) public ModelAndView getAllTest1() { ModelAndView mv = new ModelAndView(); List&lt;Book&gt; books = new ArrayList&lt;&gt;(); Book b1 = new Book(); b1.setId(1); b1.setName(&quot;三国演义&quot;); b1.setAuthor(&quot;罗贯中&quot;); books.add(b1); Book b2 = new Book(); b2.setId(2); b2.setName(&quot;红楼梦&quot;); b2.setAuthor(&quot;曹雪芹&quot;); books.add(b2); // 指定数据模型 mv.addObject(&quot;bs&quot;, books); mv.setViewName(&quot;book&quot;); // 指定视图名 return mv; } 返回 ModelAndView ，最常见的两个操作就是指定数据模型+指定视图名 。 2. Void返回值为 void 时，可能是你真的没有值要返回，也可能是你有其他办法，我将之归为如下四类，大伙来看下。 2.1 没有值如果确实没有返回值，那就返回 void ，但是一定要注意，此时，方法上需要添加 @ResponseBody 注解，像下面这样： @RequestMapping(&quot;/test2&quot;) @ResponseBody public void test2() { // 你的代码 } 2.2 重定向由于 SpringMVC 中的方法默认都具备 HttpServletResponse 参数，因此可以重拾 Servlet/Jsp 中的技能，可以实现重定向，像下面这样手动设置响应头： @RequestMapping(&quot;/test3&quot;) @ResponseBody public void test3(HttpServletResponse resp) { resp.setStatus(302); resp.addHeader(&quot;Location&quot;, &quot;/html/index&quot;); } 也可以像下面这样直接调用重定向的方法： @RequestMapping(&quot;/test3&quot;) @ResponseBody public void test3(HttpServletResponse resp) { resp.sendRedirect(&quot;/html/index&quot;); } 当然，重定向无论你怎么写，都是 Servlet/Jsp 中的知识点，上面两种写法都相当于是重回远古时代。 2.3 服务端跳转既然可以重定向，当然也可以服务端跳转，像下面这样： @GetMapping(&quot;/test4&quot;) public void test4(HttpServletRequest req, HttpServletResponse resp) { req.getRequestDispatcher(&quot;/WEB-INF/jsp/index.jsp&quot;).forward(req, resp); } 2.4 返回字符串当然也可以利用 HttpServletResponse 返回其他字符串数据，包括但不局限于 JSON，像下面这样： @RequestMapping(&quot;/test5&quot;) @ResponseBody public void test5(HttpServletResponse resp) throws IOException { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); List&lt;Book&gt; books = new ArrayList&lt;&gt;(); Book b1 = new Book(); b1.setId(1); b1.setName(&quot;三国演义&quot;); b1.setAuthor(&quot;罗贯中&quot;); books.add(b1); Book b2 = new Book(); b2.setId(2); b2.setName(&quot;红楼梦&quot;); b2.setAuthor(&quot;曹雪芹&quot;); books.add(b2); String s = new Gson().toJson(books); out.write(s); out.flush(); out.close(); } 这是返回值为 void 时候的情况，方法返回值为 void ，不一定就真的不返回了，可能还有其他的方式给前端数据。 3. String当 SpringMVC 方法的返回值为 String 类型时，也有几种不同情况。 3.1 逻辑视图名返回String 最常见的是逻辑视图名， 这种时候一般利用默认的参数 Model 来传递数据，像下面这样： @RequestMapping(&quot;/hello&quot;) public String aaa(Model model) { model.addAttribute(&quot;username&quot;, &quot;张三&quot;); return &quot;hello&quot;; } 此时返回的 hello 就是逻辑视图名， 需要携带的数据放在 model 中。 3.2 重定向也可以重定向，事实上， 如果在 SpringMVC 中有重定向的需求，一般采用这种方式： @RequestMapping(&quot;/test6&quot;) public String test6() { return &quot;redirect:/html/index&quot;; } 3.3 forward 转发也可以 forward 转发，事实上，如果在 SpringMVC 中有 forward 转发的需求，一般采用这种方式： @RequestMapping(&quot;/test7&quot;) public String test7() { return &quot;forward:/WEB-INF/jsp/order.jsp&quot;; } 3.4 真的是 String当然，也有一种情况，就是你真的想返回一个 String ，此时，只要在方法上加上 @ResponseBody 注解即可，或者 Controller 上本身添加的是组合注解 @RestController，像下面这样： @RestController public class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello provider!&quot;; } } 也可以像下面这样： @Controller public class HelloController { @GetMapping(&quot;/hello&quot;) @ResponseBody public String hello() { return &quot;hello provider!&quot;; } } 这是返回值为 String 的几种情况。 4.JSON返回 JSON 算是最最常见的了，现在前后端分离的趋势下，大部分后端只需要返回 JSON 即可，那么常见的 List 集合、Map，实体类等都可以返回，这些数据由 HttpMessageConverter 自动转为 JSON ，如果大家用了 Jackson 或者 Gson ，不需要额外配置就可以自动返回 JSON 了，因为框架帮我们提供了对应的 HttpMessageConverter ，如果大家使用了 Alibaba 的 Fastjson 的话，则需要自己手动提供一个相应的 HttpMessageConverter 的实例，方法的返回值像下面这样： @GetMapping(&quot;/user&quot;) @ResponseBody public User getUser() { User user = new User(); List&lt;String&gt; favorites = new ArrayList&lt;&gt;(); favorites.add(&quot;足球&quot;); favorites.add(&quot;篮球&quot;); user.setFavorites(favorites); user.setUsername(&quot;chenguoji&quot;); user.setPassword(&quot;123&quot;); return user; } @GetMapping(&quot;/users&quot;) @ResponseBody public List&lt;User&gt; getALlUser() { List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { User e = new User(); e.setUsername(&quot;username:&quot; + i); e.setPassword(&quot;pwd:&quot; + i); users.add(e); } return users; } 总结好了，这是我为大伙总结的 SpringMVC 方法四种不同类型的返回值，难倒是不难！有问题欢迎大伙留言讨论。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"965 是一种生活态度，996 也是","slug":"965 是一种生活态度，996 也是","date":"2019-05-07T02:39:50.000Z","updated":"2019-05-07T05:16:13.220Z","comments":true,"path":"2019/05/07/965-shi-yi-chong-sheng-huo-tai-du-996-ye-shi/","link":"","permalink":"http://chenguoji.com/2019/05/07/965-shi-yi-chong-sheng-huo-tai-du-996-ye-shi/","excerpt":"","text":"996 的苦，我大抵是不懂得的。我工作快 5 年了，在这 5 年的时光里，都是以 965 的形式度过的。说是幸运，那倒也是，没有遇到过加班的项目。说是不幸，那也只能说是，也没有遇到有挑战的项目。在今天的大多数看来，在一家公司里待满 5 年，可能不是件有意思的事——生活总会有各种的无奈。 5 年的时间，不长也不短。朋友变成了同事，网友变成了同事，同事变成了前同事，前同事变成了同事（笑~）。人呢，都是有自己的想法： 1.965 的工作太『安逸』——赚不了多少钱。 2.996 的生活太『辛苦』——没时间去花钱。 矛盾之下，有人选择将 965 的生活，变成了 996；有些则是选择将 996 的生活，变成了 965。 生活总是这么有趣。有光的一画，自然而然地，也就有阴影的一面；被某些人喜欢着，也必然意味着被某些人讨厌着；有很多的粉丝， 也同时意味着有很多的黑粉。 没有对与错，只有自己的选择与利益。 965作为一个农村里出来的穷孩子，我在今年里存款才突破 100,000——2018 年存下的，相当于现在大部分程序员一年的存款。以前的钱呢，都在帮家里还钱。你要是说呢，钱对于我也很重要，但是还有很多事情也很重要——生活、爱情、自我。所以，选择 965，对于我来说是一种平衡。 编程是一种兴趣。编程说是我的兴趣吧，倒也不是，我只是喜欢创造，就好比是个手工艺人一样。 生活是一种平衡。人是有生活的，机器人才没有。 家庭是一个归属。你有男朋友/老婆/儿子/女儿，你需要花时间在他/她们身上。 从这等角度来看，我到底是那种喜欢马拉松式生活的人，缓慢而又持久（笑）。所以我喜欢制定一个长期的计划，然后慢慢去执行，每天总能收获一点点。从长期来看，养成了一个好的习惯，就能构建长久的职业生涯。哪怕是有一天出去创业了，好的习惯也会带来一定的助力。 说是 965，但是这并不意味着不加班，只是很多工作可以回家里完成。如果从这等角度上来看，我到底也是加班过的： 1、深入研究项目上的技术栈 2、调研项目要使用的新技术栈 只是呢，这算是加班吗？哈哈~，我回家也是研究技术。若是自己能力不足，这种加班倒是也 996所以呢，为了钱去选择 996 也是一种生活态度。赚够钱了呢，就可以过退休般的生活，每天花很多时间去写想写的代码。前期呢，累是累了点，但是总是值得的。 赚钱是一种需求。总有那么一些人，就喜欢赚钱，赚钱是一种快感，比如唐老鸭的叔叔——最有钱的虚拟人物。 证明自己是一种需求。有的人，选择 996 的大公司，出自于自我实现的需要。在大的平台上，去创造一系列的精彩，而自己便是优秀的那个人。 在不了解自己想要什么，迷茫的时候，选择 996 是一种更有效的方式。对于你而言，965 带给你反而是一种时间上的浪费。6 点多回到了家里，却也不知道做些什么。那还不如，在公司混混沌沌地把钱赚了。 也因此呢，还有一种情况是： 在公司加班是一种享受。令人津津乐道的是，对于如我一样来大城市 “务工” 的程序员来说，回到住的地方反而更无聊。在公司里，还有同事可以聊天 ，还有零食可以吃，还有帅哥和靓妹可以看，何乐而不为。加班时，有免费的晚饭吃，到了 9 点回家还可以打车报销。 我们在说 996 的时候，指的是强制性的加班，而不是这种自主性的加班。 965 与 996 徘徊者在 TWU 的时候，我的人生有过一次的转变。那时是在 2014 年 10 月，我第一次了解到除了男性、女性，还有其 x 的性别。然后，性别在我的眼里，就变成了五种选项。从现象上来看，他/她们可能是 996 的人，又或者是 965 的人，但是实际上可能是： 965 的人 996 的人 995 但是认为自己是 996 的人 996 但是认为自己是 995 的人 即不是 995 也不是 996 的人 可是呢，生活是一种选择。选择了 965，可能就没有 996 的工资；选择了 996，可能就没有 965 的工资。 让我们来做个简单的自述，把你的 996 的工作变成了 965，算算你的时薪，看看你还能在现在拿多少钱？以一个月四周来看： 965 意味着，一天 8 小时，一周 40 小时，一个月 160 小时。 996 意味着，一天 10 小时，一周 60 小时，一个月 240 小时。 所以，如果把你的 965 的工作时间换成了 996，那么你的工资应该至少要涨 50%（不包含加班费）。把你的 996 的工作时间换成了 965，那么你的工资应该减少 1/3。 最后，问题也就来了，你现在的工资少 1/3，你干吗？——你可能马上骂娘了。 你，可能会立马变成那个吐槽为什么不 996 的人呢？所以，生活并不会有太多的选择。你既要 996，又想要保持现在的工资和绩效，有点难——站着，还把钱赚了，不是一件容易的事。 生活就是这么需要一些同理心，人呢，有时要站在别人的角度来考虑问题。 那么，你呢？当然了，这些道理，我们都是知道的。 你呢，若是你，你会选择 965，又或者是 996，为什么呢？ 来源：mp.weixin.qq.com/s/x8d4yRY6o_HISn4fqwx-Ig","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"宁南山：说下996","slug":"宁南山：说下996","date":"2019-05-07T02:39:50.000Z","updated":"2019-05-07T08:03:18.670Z","comments":true,"path":"2019/05/07/ning-nan-shan-shuo-xia-996/","link":"","permalink":"http://chenguoji.com/2019/05/07/ning-nan-shan-shuo-xia-996/","excerpt":"","text":"作者：宁南山 一个国家，少数优秀人士和少数头部企业拼命干活就可以了， 一个是因为这个世界的经济竞争还是很残酷，中国要在不同行业赶超欧美，如果连精英人物和龙头企业都下午五点就下班，赶超不知道什么时候才能完成，甚至说永远不能完成。 你技术不如人，管理不如人，资本不如人，也不比其他国家的精英聪明，你还不愿比别人多干活，怎么赶超呢？ 欧美的精英是非常拼的，不止一个国外公司的高管告诉我，他一天只睡四小时，五小时，有的是早上五点就起床。 另外一个是优秀分子一般都高度自律，同时具备很高的个人野心，对工作很有热情，也很热爱自己从事的事业，你眼中996是负担，其实他们中很多人可能会觉得比较快乐，996对他们并不一定是负担。 说句不好听的话，如果一个国家，连精英分子和精英企业，追求的都是懒散闲适的生活，不能适应高强度的工作，没有奋发向上的野心，这个国家肯定没希望。 事实上这样的国家在地球上一大把，非洲，中东，拉美，东南亚，你可以找出很多。 但是对于大部分人和大部分企业，996没有必要，40小时工作制，顶多偶尔有适量加班就可以了。 原因不复杂， 一个是和精英分子和顶尖企业相比， 普通人和普通企业的996是极为低效的，会极大的降低全社会的投入产出比。 精英企业的效率远远高于普通企业， 华为18万人一拼命工作，就可以在多个领域（通信网络，智能手机，企业IT）收割全世界的利润； 腾讯四万多人拼命工作，就可以成为全球最大的游戏公司，收割全球最多的游戏收入。 阿里八万多人拼命工作，就可以成为全球最大的电商公司，全球最大的云计算公司之一。 大疆几千人拼命工作，就可以成为全球最大的消费无人机公司，获取全球同行业70%以上的收入。 我在之前的文章里面写过，一个行业存在马太效应，最终三四家甚至两三家大公司获取行业大部分的收入和利润，但是这几家大公司雇佣的员工人数可以说远远低于其收入利润在同行业的占比，这也是阿里，腾讯，华为，VIVO, OPPO,大疆等同行业的大公司的员工收入非常高的原因。而对于广大的非头部企业来说，不管是收入份额还是利润份额，还是员工收入都远远不如了，搞996效率非常低，产生的边际效益很少，也没有必要。 对精英人物也是一样，他们本身能力出众，工作认真，同时对工作抱有热情，因此工作效率远远高于普通人。 我自己感受很多，同样一份报表，优秀的员工交上来的基本上不会有任何错误，我都不用检查就可以直接用；能力平庸的员工，交上来的永远有各种错误，我必须要耗费时间一个字一个字的检查，发现错误还要打回去重新搞，然后交上来你还会继续发现错误，效率非常低。你让普通员工搞996，总体边际效益并不高，但是他却会付出很多时间，投入产出效率进一步降低。 一个是不要忘记了发展经济的最终意义，就是为了让广大中国老百姓活的更轻松。 我自己在不同的企业工作过，我就想说，下午五点半就下班，和晚上九点十点才下班，整个世界都是不一样的。 下午五点半下班，可以去看电影，可以去探索城市里面有趣的餐厅，可以去深圳湾跑步骑自行车，可以去夜游莲花山，可以跨越半个城市去找朋友聚会，可以陪孩子出去散步，人可以得到生活，也刺激了消费。 晚上九点多十点才下班，人就成了一部机器，吃饭就是吃外卖，没有时间陪伴家人，拖着疲惫的身体回到家，洗完澡就是十一二点，一天就这样过去了，偶尔如此还好，天天如此的意义在哪里呢？ 就算中国十年后迈入发达国家收入的门槛，一个国家90%都是社畜，每天工作十几个小时，晚上十点之后下班，没有个人生活，社会无法发展出更多的个性，变成一个纯粹的“工作社会”，整个社会低效率的运转，就算成为了发达国家，这样又有什么意义？ 这样的例子在世界上不是没有，韩国日本就是典型。 让精英分子和精英企业去996，去拼命奋斗，然后国家和政府帮助这些企业去收割全世界的超额利润，然后政府通过制度安排，做好头部企业创造的收入和利润合理分配到全社会，让大多数人过上轻松愉快的生活，这才是理想中的生活。中国的体量足够大，10%的优秀分子和优秀企业去拼命搞，一样可以干翻发达国家同行，收割全世界。 马云那个讲话，在阿里内部讲就可以了，不要流到社会上，让大批的普通企业也集体仿效就不好了，因为阿里是头部企业，相对于普通企业，投入和产出都是高效的，人家996，论产出可以收割世界的利润，论收入阿里员工动不动就年薪一两百万，就算累，也就影响八万人。 另外就是，头部企业承担了代表中国在全球残酷经济竞争的任务，必须要保持高度的战斗性。某种意义上就跟一个国家的军队一样，必须严格纪律和训练保持战斗力。 而头部企业之外，大批的普通企业搞996的边际效益很低，但是却拉高了全社会的痛苦值，生育率一路走低，没时间陪孩子，孩子缺少家庭教育，全社会可持续发展能力降低，毫无必要。 当然，要实现头部企业赚钱收割全球，同时做好利润分配，让大多数人实现愉快生活这个目标，还是需要努力的。 比如说需要国家独立，对外国资本有控制力，韩国第一大企业三星电子，日本第一大半导体企业东芝半导体，台湾第一大集成电路企业台积电，外资股权比例都奇高无比，超过本土资本股权，这就很难搞好头部企业的收入分配了。 中国互联网企业早期也存在这个问题，不过最近几年新崛起的互联网公司股权结构内外资比例相对好多了。 另外就是政府对本土大资本也要有控制力， 美国在收割全球方面做的很好，头部企业在全球大赚特赚， 2000年到2018年，经济总量从10万亿美元到20万亿美元几乎翻了一倍，但是家庭收入中位数却基本没有变化，只增长了10%不到，新增长的财富都到少数精英富人那里去了。 说白了也是美国政府收入分配没搞好，占领华尔街和特朗普上台，都是普通人也开始不满意的结果。 来源：https://weibo.com/6120483044/HpsIShcl5?type=comment","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"花了 2 亿多，等了近 2 年，结果连个可用的网站都没有","slug":"花了 2 亿多，等了近 2 年，结果连个可用的网站都没有","date":"2019-05-06T08:39:50.000Z","updated":"2019-05-06T09:30:25.526Z","comments":true,"path":"2019/05/06/hua-liao-2-yi-duo-deng-liao-jin-2-nian-jie-guo-lian-ge-ke-yong-de-wang-zhan-du-mei-you/","link":"","permalink":"http://chenguoji.com/2019/05/06/hua-liao-2-yi-duo-deng-liao-jin-2-nian-jie-guo-lian-ge-ke-yong-de-wang-zhan-du-mei-you/","excerpt":"","text":"有个国外匿名吐槽网站，名字叫 Clients From Hell，意思就是来自地狱的客户。程序员和设计师们纷纷晒出自己经历过的奇葩客户。我们以前翻过上面的一些案例，比如： 今天推文，还是和地狱设计有关。不过这回是角色互换了，是来自地狱的开发商。 4 月 23 日，外媒 The Register 发了一篇报道，愤怒的汽车租赁巨头 Hertz 已经向纽约法庭起诉埃森哲了。 Hertz 在起诉书称，尽管支付了 3200 万美元（折合人民币 2.1 亿多）费用，但埃森哲从未交付过一个可用的网站或移动应用。 这到底是怎么一回事呢？ 在 2016 年，美国汽车租赁巨头 Hertz 有一个雄心勃勃的计划，想转变其数字身份。该计划的目标是想重新设计 Hertz 数字平台，重新开发做一个市场领先的网站 Hertz.com 和一套互补的移动应用程序。新网站不仅可用于 Hertz 品牌，也要适用于旗下其他租赁品牌 Dollar 和 Thrifty。 为此，Hertz 花费数月，为这个计划评估电商现状，确定数字业务的目标和战略，规划实现愿景的路线图等等。 但是，Hertz 自家内部没有专业知识或资源来执行如此大规模的任务。所以需要和一家世界级的技术服务公司来合作。筛选潜在合作方后，Hertz 把选择缩小到埃森哲和另外一家。 在埃森哲为 Hertz 做了一次令人印象深刻的为期一天演示后，Hertz 选择埃森哲来设计、构建、测试和部署 Hertz 的新网站和移动应用程序。( 敲黑板：PPT 真是一门学问 ) 于是在 2016 年 8 月，Hertz 和埃森哲愉快地签合同了。按最初计划，新网站上线时间定在 2017 年 12 月。 但由于多种原因，上线时间推迟到了 2018 年 1 月，然后又推迟到了 2018 年 4 月。 接二连三的延迟，Hertz 都忍了，但后来发现了一个让人吐血的事情：新网站进展居然没有达到最初整体要求的一半！ 这下忍不了了！对埃森哲是否能顺利完成项目，Hertz 没有任何信心。于是在 2018 年 5 月终止合作。 随后，Hert 起诉埃森哲，要求赔偿 3200 万美元以及相应损失。 起诉书： https://regmedia.co.uk/2019/04/23/hertz-accenture-website.pdf Hertz 在起诉书中，列出了埃森哲在很多方面的「罪状」： 1、不完全支持响应式布局在签署的合同中，Hertz 明确要求埃森哲做 3 种网站布局：小型（支持手机访问）、中型（支持平板电脑）、大型（支持桌面电脑）。 埃森哲只做了小型和大型布局。想支持平板电脑访问？Hertz 需再另外交钱！ 2、无视可扩展性在架构规范中，Hertz 明确要求埃森哲设计开发的网站要有可扩展性。即：设计一个公共的核心库，可以扩展到整个网站和移动应用程序，从而支持 Hertz 旗下所有品牌。 但是，埃森哲完全忽视这个要求，只针对 Hertz 北美站，无法用于 Hertz 全球站、Heartz 旗下 Dollar 和 Thrift 网站。 Hertz 向埃森哲提出这个问题后，项目负责人曾回应称，「我们认为创建一个通用代码库，Hertz 从其扩展，这样可用性更低，效率也更低。」 3、前端代码烂透顶了！后端 Java 代码也不遵循规范Hertz 方面表示，埃森哲写的前端代码很糟糕，有着严重的安全问题和性能问题。 后来 Hertz 做了评测，发现埃森哲的前端代码问题太多了，无法补救，不得不放弃。系统的其他部分，部分代码也是不可用的。 2018 年 1 月，埃森哲曾在项目进展会议中的演示中承认了失败，并表示「前端技术（Angular2）对我们交付项目是一大挑战。」 埃森哲的 Java 代码，并没有遵循 Java 规范，逻辑差，并且难以维护。 4、没有合理的测试埃森哲未能对其开发的软件进行适当的测试，对系统许多组件压根没有测试。 而他们做测试时，又大都采用「Happy Path 测试法」。换句话说，在假设客户按照预期使用的场景下，测试查看网站或移动应用程序是否执行。 很显然，「Happy Path 测试法」是不够的，因为它没有评估真实场景下的性能，也无法测试错误处理。 5、其他控诉还有好多瓜，比如： 推荐买不会用的技术 埃森哲推荐 Hertz 购买 RAPID 许可。Hertz 买了后，但埃森哲又不会用，花了很多时间用于整合 RAPID 。 失败的项目管理，加剧了技术难题 埃森哲失败的项目管理，加剧了技术难题。比如：项目进行到第二阶段中期时，埃森哲调走（remove)一批重要的团队成员，包括产品负责人和微服务架构师。而新来者没有前任同等水平，人员替换过程中无形丢失了很多项目知识。埃森哲也向 Hertz 承认过项目延期部分原因是「重要资源」的流失。 内容管理系统存在严重问题 埃森哲开发的 AEM 模块（内容管理系统）存在严重缺陷。其代码和文件结构，没有基于 Adobe AEM 原型，导致程序不可靠，并且难以维护。 违背承诺，另收费用 埃森哲曾答应 Hertz 不会因项目延期而另外再收取费用，后来出尔发尔，要求 Hertz 支付额外费用。 【说明】：以上都是基于 Hertz 起诉书摘译，仅代表 Hertz 的观点，不代表我们的看法。对于 Hertz 的指控，埃森哲方面回应 Register 称「起诉毫无根据」，并没有过多置评。 这个案子后续会如何发展，我们会持续关注。 网友评论 @老码农的自留地 : 咨询公司江河日下，除了高大上的规划PPT，连做网站这种搬砖钱也挣[允悲] @ayumi_0213：accenture除了咨询，还有另外两个bu，其中一个是it 外包，这个业务十几年前就已经有了。而现在除了accenture，普华永道和安永等四大会计师事务所也有it外包的业务喔～ @Sansiro_Santon：可能是转外包给印度学生做的[doge] @冰箱里的小怪兽：美国还是竞争小啊，2016年8月立项，上线时间居然定到1年零4个月以后，而且还能容忍再推迟4个月。这玩意儿要是搁国内，竞品早把你打得啥都不认识了 @巴扎嗨嘿嘿嘿嘿：学好PPT，鬼都能忽悠来给你推磨[笑而不语] @爱吃萝卜叶叶的毛毛虫：给中国公司两个亿，你想要啥样子的网站都可以 原创：程序员的那些事（id：iProgrammer）来源：https://mp.weixin.qq.com/s/KR8yk64426civfA0fyHBTQ","categories":[{"name":"网站","slug":"网站","permalink":"http://chenguoji.com/categories/网站/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://chenguoji.com/tags/网站/"}],"keywords":[{"name":"网站","slug":"网站","permalink":"http://chenguoji.com/categories/网站/"}]},{"title":"趣图：外包的真相","slug":"趣图：外包的真相","date":"2019-05-06T02:39:50.000Z","updated":"2019-05-06T08:42:03.079Z","comments":true,"path":"2019/05/06/qu-tu-wai-bao-de-zhen-xiang/","link":"","permalink":"http://chenguoji.com/2019/05/06/qu-tu-wai-bao-de-zhen-xiang/","excerpt":"","text":"","categories":[{"name":"趣图","slug":"趣图","permalink":"http://chenguoji.com/categories/趣图/"}],"tags":[{"name":"趣图","slug":"趣图","permalink":"http://chenguoji.com/tags/趣图/"}],"keywords":[{"name":"趣图","slug":"趣图","permalink":"http://chenguoji.com/categories/趣图/"}]},{"title":"程序员的眼界真的不要，也不能只局限于技术","slug":"程序员的眼界真的不要，也不能只局限于技术","date":"2019-05-05T02:39:50.000Z","updated":"2019-05-08T02:39:22.838Z","comments":true,"path":"2019/05/05/cheng-xu-yuan-de-yan-jie-zhen-de-bu-yao-ye-bu-neng-zhi-ju-xian-yu-ji-zhu/","link":"","permalink":"http://chenguoji.com/2019/05/05/cheng-xu-yuan-de-yan-jie-zhen-de-bu-yao-ye-bu-neng-zhi-ju-xian-yu-ji-zhu/","excerpt":"","text":"前几天在读《极客时间》专栏的时候，看到这么一段话： 对客户来讲，真正有价值的是业务，技术是为业务服务的；对于团队生产力来说，管理起关键作用，否则技术实力发挥不出来。 对于资深的业务和管理人员，也有很“技术”的部分，更有很“艺术”的部分。懂得业务和管理的技术人员，才能把技术能力最大化地发挥出来。 作为一个创业者，正在经历着”创业”这个冰与火的淬炼与锻炼，深知作为一个技术人员来讲，什么才是最重要的，所以看到上面那段话，感同身受，感觉说的非常对，而且真的是非常重要：懂得业务和管理的技术人员，才能把技术能力最大化地发挥出来。 关注我的读者可能都知道，其实我都一直在跟大家强调一个问题：程序员的眼界真的不要，也不能只局限于技术。 程序员既然是技术出身，不只局限于技术，那又该如何提升自己在企业中的价值，该关注除了技术之外的哪些方面呢？ 一、懂产品和业务就像上面那段话说的，技术是工具，它只有服务于具体的业务才能产生价值。只有懂产品和业务才能把客户服务好，才能把产品做到最好。 很多人可能会说：这不应该是产品经理的活么？我们工程师为什么要关注呢？ 这是误区，而且是巨大的误区。眼界局限于自己的活，你的前途和前景，发展空间就是局限的，微小的。跳出来看看这个世界，你可能会发现，身边的技术管理者(技术 leader)，越往上走，是不是对产品和业务的逻辑要求越高？ 如果你只会技术，每次在团队之间沟通，都用技术语言，那么团队之间非技术人员就会很那听懂，而你如果能够把复杂的业务逻辑非常简单的描述清楚，那么你就会使团队之间沟通的更有效率。可能在不知不觉间，就在推动着团队前进，等你对产品和业务逻辑也来越熟悉的时候，你会发现，团队之间的沟通正在以我为核心，我在团队中正变得越来越重要。 从而，你可能会更上升一步，成为团队负责人，如果团队负责的好，决策权就来了，再上升一步，就是管理层！ 你想想，如果你只关注你的一亩三分地好不好？你再努力，再牛逼，地就那么大，你的发展空间就受限，你种地技术再牛，产量也不会太高。 而且，我告诉你，每个行业，每个产品可能都有着自己独特的业务逻辑，如果你深谙或者熟悉某一个行业的业务逻辑，你可能就会成为这个行业的专家，从而说话和做事就会越来越有分量！如果你经常做 ERP 系统，你就知道了。 二、懂管理和创新技术人要想懂管理，可能需要一个缓慢的过程，比如我：在创业，深知管理真的是一门很大的学问，每个人都有着自己不同的心理。你可能会想：我应该如何提高员工的效率？如何凝聚团队的战斗力？如何能够让大家都非常的努力？如何保证团队的稳定性，不会有人员流失？如何……等等。 但是，这些问题对于一个技术人员刚转管理可能会很难，我们可以从技术领导力方面入手，先从自己最擅长的地方切入，慢慢学会管理。强迫，军事化管理，绝对服从等是很难都根上解决管理问题，而技术领导力就会给我们一个方向，就是靠自己的能力来征服他们。你解决不了的问题，我帮你解决了？他能不服你？ 所以，管理就是这样，管理靠的是正确的引导！ 技术人要懂创新，具有批判性思维。很多人都感觉程序员是逻辑严密，但是一根筋，在业务逻辑的处理上是一条路走到黑。其实，我们更应该跳出来，要敏锐的去发现问题，去寻求业务逻辑不好的地方，去改进这些问题，更要大胆的拥抱新技术，新工具，以及新流程，去带动整个团队进行产品升级，技术升级，提升企业的 ROI 。 所以，我们程序员应该经常跳出来，看看外面的世界，看看身边其他的牛人，都在干什么？不要只想着技术，即使你的目标是技术专家，技术专家也是需要懂产品，懂业务的，如果你是架构师？如果你不懂业务逻辑，不深谙一个行业的操作流程和业务流程，你能设计出一个非常好的架构来么，更别提一个好的产品来了！ 来源:mp.weixin.qq.com/s/qg8AzGQQbTU86PlkJihsow","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"我们搞开发的为什么会感觉到累","slug":"我们搞开发的为什么会感觉到累","date":"2019-05-05T02:39:50.000Z","updated":"2019-05-06T08:09:31.127Z","comments":true,"path":"2019/05/05/wo-men-gao-kai-fa-de-wei-shi-me-hui-gan-jue-dao-lei/","link":"","permalink":"http://chenguoji.com/2019/05/05/wo-men-gao-kai-fa-de-wei-shi-me-hui-gan-jue-dao-lei/","excerpt":"","text":"引题昨天下班坐公车，听到一个和我年纪相仿的哥们儿打电话，隐约听到电话那边好像是他女朋友问他现在饿不饿，他说“我已经饿的不饿啦”。 饿的不饿了，听起来很幽默，对我很有触动，我在思考，我此时站在公车中部，手扶着杆有点酸，你问我手有多酸，借用打电话的那个哥们的话，随着日复一日这样的酸痛感受的反复刺激，已经酸的不酸了，你问我饿不饿，我也说不上来，飘飘渺渺，因为做编程这行几年下来，我自己的感受是，虽到了吃饭时间，但是感觉似饿非饿，吃饭感觉只是个形式。 以上都是是大多数在一线城市奋斗的人们所经历的可以忽略不计的一些事，我这里想聊聊为什么我们做IT的大多数都很累？ 什么叫累，古代私塾先生教书的时候解释说，累字拆分意义是田系在头上，白话文讲就是“头上有田方知累也”。这是上古时代“累”的含义，当然现在还有大多数人为了我们国家的发展在辛勤劳累的种田，他们很辛苦。 我们的累回到标题，我觉得我门做编程的大多数人都很累，为什么累呢？ 到一个新公司上班，公司预先说要做一个项目或产品，你不知道到底有多复杂或简单，心里些许担心或不安，因为这些东西有可能在你预想的基础上会变的。 准备启动项目或产品，开始做需求，由于老板把时间压得紧，需求可能有些粗糙，开发时间也被压很短，因为这样，担心和紧张感铺面而来，需求会不会变，会不会遇到技术障碍，都是可变的。 开发过程中，由于需求做的不够精细（这太正常了，客户或老板都不知道他要什么），接二连三的变动和更改，紧张万分，不知道哪一会儿会又变动。 累死累活做完了，开始测试了，啊，XXX这里点击没反应，邮件怎么没发送成功，怎么发送成功了没收到，又报黄页，js错误……时刻有可能出bug。 终于上线了，客户出了个error，你帮忙看看吧（测试阶段都没有这问题哦）；日志记录了不少错误哦，你给定位下；客户投单没成功，肯定他妈的第三方接口问题；客户IE6下按钮点不了，下拉框出不来；oh shit …… 又开始新的项目了，新的一轮紧张挑战拉开帷幕……之前上线的项目或产品还会时不时给你来些心跳，下一秒未可知，明天未可知。 循环ing…… 大伙可能要说担心或不安是多余的，那是你技术水平太垃圾吧，我之前的技术leader技术很好，很牛逼，平常他说的最多的是未雨绸缪，居安思危，人无远虑必有近忧这些句话。他时常会研究新东西，新技术，给我们安排好书去读让我们保持进步，说实话过程中有点反感但从中受益。 有时候我们自己需要被迫去变，因为现在大的背景变化非常大，PC向移动的迁移，时刻在变，我们也时刻因为这些变而被动变，或被这些变影响我们的生活，苹果开发初级10k左右起，直接秒了我们大部分搞了3年左右.net或java的人，听过好多身边做pc开发的都呐喊过说想变，但是真正主动承受痛苦去变成功的没多少人。 有的人可能会说了，赶紧努力吧，做管理，当领导，呵呵，我发现那些大部分位置越高的人头发越稀落，医学上说头发稀落和肾功能衰弱有关，常言道，恐伤肾，可想是担受了多少惊恐与变数，过几年你很有可能就成了他们。中层领导有来自高层的压力，高层来自boss的压力，boss来自生存的压力和股东投资者的压力等……有时候麻雀没有变成凤凰未尝不是一种解脱啊，我说这话你可以说我是个loser思维，我也诚然。我想告诉大家的是珍惜当下吧！我现在特别怀念刚参加工作那会儿，激情，敢说敢做，敢表现神经质…… 所以说，我们累是因为我们所从事的事情变数很多，人最恐惧未来，因为未来不可知，上至诸侯王下至编户百姓无一幸免，我们就活在这样变化无常的区域里面，紧张嘻嘻，正是这样，久而久之变得抑郁，神经衰弱，麻木不仁，懒得动，懒得说话……恶性循环。 我们现在就是忙于应付这些变，所以搞的自己紧张忙碌，最终却没多大所获。这是我们大多数人的现状。 新生 希望2019大伙都少些加班，把有限的业余时间拿来好好放松自己，勤跑步，多看书，充实自己，做到可持续发展，主动改变自己，无论您今年多大了都应该充满理想，因为中国历史上历来不缺少枯木逢春、老来发迹的例子。大器晚成的人他没有年少轻狂，没有少不更事；年轮的重叠使他们更加珍视机遇，岁月的磨砺让他们事事洞明、人情练达。我希望大伙都能达到自己的理想，并且在很嫩的时候。 最后，关于加班我讲个小故事，希望能影响到一点点正在加班的同胞们，故事名字叫奴性是怎样练成的：第1天抽他100鞭子，他很愤怒但没敢说；第2天抽他80鞭子，他看到了生活的希望；第3天抽他50鞭子，他夸抽他的人进步了；第4天抽了他30鞭子，他跪下感动流涕；第5天抽他了20鞭子，他感恩戴德；第6天7天他已习惯了在感动中挨鞭子。并开始用鞭子抽那些同情他的人。 来源：施瓦小辛格www.cnblogs.com/wenyang-rio/p/4261987.html","categories":[{"name":"开发","slug":"开发","permalink":"http://chenguoji.com/categories/开发/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://chenguoji.com/tags/开发/"}],"keywords":[{"name":"开发","slug":"开发","permalink":"http://chenguoji.com/categories/开发/"}]},{"title":"程序猿，你该为自己加薪--用钱生钱","slug":"程序猿，你该为自己加薪--用钱生钱","date":"2019-05-04T03:39:50.000Z","updated":"2019-05-07T05:52:31.642Z","comments":true,"path":"2019/05/04/cheng-xu-yuan-ni-gai-wei-zi-ji-jia-xin-yong-qian-sheng-qian/","link":"","permalink":"http://chenguoji.com/2019/05/04/cheng-xu-yuan-ni-gai-wei-zi-ji-jia-xin-yong-qian-sheng-qian/","excerpt":"","text":"“如果你没找到一个当你睡觉时还能挣钱的方法，你将工作到死。” ——巴菲特 前言唯金钱与技术不可辜负。 作为智商比较高的程序员，这么难的程序都能学会，投资理财就更不用说啦。 金钱是有规律的，只要掌握了一定的规律，虽说不能一夜暴富，但是把掌握的规律用于生活中，至少是可以让挣钱变得轻松一些。 不知道他们有没有想过：生活中，单靠增加工时获得的收入永远无法让你摆脱贫穷。用青春来换钱的交易也绝对不可取。 绝大多数的人，都是非常勤奋的，不然也不能坚持每天定时去上班，但又是懒惰的，从来没有想过学习掌握金钱的规律。 要点最近笔者在看作者博多·令费尔写的一篇小作《小狗钱钱》，这本《小狗钱钱》是根据作者根据他写的《财务自由之路》，把其中的方法与策略编成这么一个小故事的。《小狗钱钱》讲的是一个 11 岁的小女孩捡到一条会说人话的狗（名为 钱钱），然后钱钱教会了这个小女孩与钱打交道的方法，怎样理解钱与一步步轻松地挣钱，最后小姑娘不仅自己掌提了钱的使用方法，而且还帮助自己的父母走出了财务危机的故事。 看完这篇小作，做点笔记与写自己下看完后的一些感悟。 里面讲到一个故事： “从前有一个农家小伙儿，他每天的愿望就是从鹅笼里拣一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。一开始他当然不敢相信自己的眼睛。 他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠辨别，可是金匠向他保证说，这只蛋完完全全是金子铸成的。于是，这个农家小伙儿就卖了这只金蛋，举行了一个盛大的庆祝会。” “第二天清晨，他起了一个大早，赶到鹅笼里一看，那里果真又放着一个金蛋，这样的情况延续了好几天。可是这个农家小伙儿是一个贪婪的人，他抱怨自己的鹅， 因为鹅没法向他解释是怎么下出这个蛋的，否则他也许自己就可以制造金蛋了。他还气乎乎地想，这只懒惰的鹅每天至少应该下两只金蛋。他觉得现在这样的速度太慢了。 他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出笼子劈成了两半。自那以后，他再也得不到金蛋了。” 假如我没有了我的“鹅”，我就总是得为了赚钱而工作，但是一旦我有了属于自己的“鹅”，我的钱就会自动为我工作了。 金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望。 必须真的有这个愿望的意义在于，如果足够的动力，没有足够的决心去做某些事情，终究很难成事。 如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好退路了。不能试验。你只有两个选择: 做，或者不做。 你是否能挣到钱，最关键的因素并不在于你是不是有一个好点子。你有多聪明也不是主要原因，决定因素是你的自信程度。 一个人把精力集中在自己所能做的，知道的和拥有的东西上的那一天起，他的成功就已经拉开了序幕。 你最好想清楚，你喜欢做什么，然后再考虑你怎么用它来挣钱。 你要每天不间断地去做对称的未来意义重大的事情。你为此花费的时间不会超过 10 分钟，但是就是这 10 分钟会让一切变得不同。 当你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力。 公式72 定理: 用 72 除以你们投资的年收益率的百分比， 得出的数字就是这笔钱翻一倍所要的年数。 72 小时规定: 当你决定做一件事情的时候，你必须在 72 小时之内去做这件事情，否则你很可能 就永远不会再做了。 72 公式 也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。我上网查了一下，我国目前的通货膨胀率大概是 3% ，用 72 除以 3% ，得到 24，就是说 24 年以后，你的钱只值现在的一半。” 买基金为自己加薪学习一门技能时，尽量选择积累性很强的技能，随着时间的推移，这个技能越来越厉害，那这个技能就很值得去学习。毫无疑问，投资理财，这个技能积累性就很强，最重要的是，这个技能适用于任何人、任何行业，因为投资理财 的本质，是用钱来帮你赚钱，这是最高级别的赚钱方式，除非你不想赚钱，否则每个想赚钱的人，都该重视投资理财。越是有钱人，越是懂得投资理财。 银行一年期定存利率大概是 1.5% 左右，而这利率是跑不赢通货膨胀的。一般的年轻人都是把钱放到一些收益稍高一点的理财产品里面，比如：余额宝、微信理财通里。但这也只是比银行还是要好一点而已。 定投十年挣十倍。我建议年轻人应该把部分钱（除去这部分钱，不会对你的生活产生任何影响的，比如你每月工资的 5% - 10% ）用来买基金比较好，通过 买基金为自己加薪，每月定投。 当然买基金也是有风险的，建议是了解基金之后再买。往后的时间里面，笔者会读更多关于挣钱的书箱，对买基金的策略有了更深的了解后，会再分享。 本质在笔者看来，故事里面的小姑娘，在后期可以轻松获取金钱的本质：改变了自己。 这和《大学》里面说的：“修身、齐家、治国、平天下” 的道理是一样的， 一切从改变自身做起。 最后如果想获取更多的财富，就从读如何实现财富自由类的书籍开始吧，从书中获取金钱的规律，从而使自己获取财富变得更轻松一些。 来源:https://segmentfault.com/a/1190000018808895","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"JavaScript 闭包指南","slug":"JavaScript 闭包指南","date":"2019-05-04T02:39:50.000Z","updated":"2019-05-06T07:04:15.699Z","comments":true,"path":"2019/05/04/javascript-bi-bao-zhi-nan/","link":"","permalink":"http://chenguoji.com/2019/05/04/javascript-bi-bao-zhi-nan/","excerpt":"","text":"闭包是函数创建时作用域内所有变量的集合。要使用闭包，需要在另一个函数中创建一个函数，这种函数被称为嵌套函数。内部函数可以访问外部函数作用域中的变量（依靠闭包可以访问外部函数作用域），即使在返回外部函数之后也是如此。每次创建嵌套函数时都会创建闭包。 在继续了解闭包之前，首先了解一下JavaScript中的作用域链。 通常，有两种类型的作用域： 全局作用域 局部作用域 在JavaScript中，函数内部的变量在外部是不可见的。但是在块内的变量（if 或 while 之类）是可见的。 因此，JavaScript有函数作用域。没有块作用域。 var a = 10; function app(){ var b = 2; console.log(a); // 10 console.log(b); // 2 } console.log(b); // ReferenceError: b is not defined app(); 正像我们已知的那样，a 是一个全局变量并且 b 是一个局部变量，它是app函数独有的。 我们无法从局部作用域之外获取局部变量的值。 使用嵌套函数 —— 函数内部的函数 var a = 10; function app(){ var b = 2; var d = 3; function add(){ var c = a + b; } return add; } var x = app(); console.dir(x); 在这里app是父函数，add函数是子函数。 1.代码中没有用 console.log 而是用了console.dir 来输出指定JavaScript对象的所有属性，这有助于开发人员获取对象的属性 2.变量 x 被分配给app函数，app函数返回add函数。因此我们可以看到add函数的所有对象属性。 如果在浏览器中查看控制台，可以在Scopes数组中看到Closure对象。 由于内部函数add访问外部函数变量b 和 d，因此这2个变量将被添加到Closure对象中以供引用。 让我们看看下一个例子： var a = 10; var startFunc; function app(){ var b = 2; function add(){ var c = a + b; console.log(c); } startFunc = add(); } app(); // 调用app函数 startFunc; // 上面调用的app函数会将add函数赋值给startFunc并输出c的值 1.一个名为 startFunc 的全局函数被分配给add函数，该函数是 app 函数的子函数。2.这只有在调用 app 函数后才有可能，否则 startFunc 将作为全局变量而不被分配任何值 在JavaScript中使用闭包 很多人在编码时会用到闭包，但是不明白用它的原因。 JavaScript没有像其他面向对象语言一样的访问修饰符，例如 private，public，protected。不过我们可以利用函数来保护命名空间免受外部代码使用的影响。 特别是在函数中，立即执行函数表达式（IIFE）是在声明之后会立即执行的函数表达式。在声明函数之后，你不需要去调用该函数。 IIFE的语法定义是： (function(){ //函数内部的变量和作用域 })(); 举个例子： var studnetEnrollment = (function () { //私有变量，任何人都无法改变 //除了下面声明的函数 var count = 0; var prefix = &quot;S&quot;; // 返回一个命名函数表达式 function innerFunc() { count = count + 1; return prefix + count; }; return innerFunc; })(); var x = studnetEnrollment(); // S1 console.log(x); var y = studnetEnrollment(); // S2 console.log(y); count和prefix是两个私有变量，任何人都无法进行更改，只能访问内部函数（即代码中的innerFunc）。只有名为闭包的功能才能对此进行访问。 1.第一次调用studentEnrollment函数时，函数内的count变量由innerFunc函数递增加1。2.第二次，增加上一个计数值，即 1 增加到 23.Closure功能可以实现这些功能。 结论 闭包是外部函数中的变量集合，它提供对内部函数作用域的访问以保护全局命名空间。 闭包使开发人员能够编写像面向对象语言那样的干净代码，这些代码不会混淆全局和局部变量的名称。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chenguoji.com/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"真正理解Mysql的四种隔离级别","slug":"真正理解Mysql的四种隔离级别","date":"2019-05-03T02:39:50.000Z","updated":"2019-05-06T06:53:59.709Z","comments":true,"path":"2019/05/03/zhen-zheng-li-jie-mysql-de-si-chong-ge-chi-ji-bie/","link":"","permalink":"http://chenguoji.com/2019/05/03/zhen-zheng-li-jie-mysql-de-si-chong-ge-chi-ji-bie/","excerpt":"","text":"什么是事务事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。 事务的 ACID事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 Mysql的四种隔离级别SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 Read Uncommitted（读取未提交内容） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如： 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示： 作者：游泳的石头链接：https://www.jianshu.com/p/8d735db9c2c0","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"北冥乘海生：996其实没什么卵用","slug":"北冥乘海生：996其实没什么卵用","date":"2019-05-02T03:39:50.000Z","updated":"2019-05-07T05:45:09.115Z","comments":true,"path":"2019/05/02/bei-ming-cheng-hai-sheng-996-qi-shi-mei-shi-me-luan-yong/","link":"","permalink":"http://chenguoji.com/2019/05/02/bei-ming-cheng-hai-sheng-996-qi-shi-mei-shi-me-luan-yong/","excerpt":"","text":"996一词，是某巨头的一个中层提出来的，最初只是个忽悠老板的口号，哪知道如今应者云集，简直成了创业精神的代名词。007一词，则是我提出来的(《江湖丛谈》与互联网三不要)，虽说是直钩钓鱼，居然也有人信以为真，还打算试试。 注意，不要把这些词恶毒地解读为“加班”：除了睡觉都在工作，哪还有时间加班？ 把码畜(大数据码畜生存指南（一）)们像蝈蝈一样圈起来，三餐加零食饲养着，让他们在戒除健身、聚会和性生活三大恶习的状态下，以公司为家，以下班为耻，这样就能够让打工的开好车，老板们发大财么？其实，在大公司里，先不说对不对，996这事真的没什么卵用。 先声明，凡是拿*.布斯们一天睡几个小时来理论的，我都直接拉黑：合伙人们博的是无限未来，007都是天经地义；而打工仔们是按劳取酬，推一辈子石头也不会拥有自己的金字塔。 工作分两类：一类主要看执行力，一类主要看创造力。如果是前沿研究、艺术创作之类的工作，显然要以激发创造力为主，要求工作时间不啻是南辕北辙。设想下，假如比尔盖茨让麾下的科学家们都集中住宿，统一制服，每天早汇报晚总结，按代码行数和paper字数发奖金，这不是微软研究院，这是衡水研究院。 诚然，大多数公司不大需要创造力。他们得稳准狠地叼住几根骨头，先吃饱了才是王道，这需要的是野狗一样的执行力。 对于交付型项目，执行力还真就是靠睡得少：甲方爸爸啥时候临幸你，你就得啥时候舔上去，比鸡起得早，比鸡睡得晚，以迅雷不及掩耳盗铃之势把活干完。所以，2B项目紧的时候996是必要的，不过并不需要、也不能常态化。 为什么不能常态化？从生理规律上看，脑力劳动者如果不以进ICU为目标，那么每天能够认真投入的时间，八小时也就到极限了。人毕竟不是机器，老板又不是女友，怎么瞧都瞧不烦。长期996耗下去，只是浪费方便面和卫生纸而已。当然，如果你的工作只是客服那样的机械劳动，拉长时间肯定有效，可是别忘了，人家客服是按件计酬的。 不信您看看大洋彼岸，Google一年收一千亿刀，苹果利润就几百亿刀，还甭说996，加班的都没几个，隔三岔五还能在家办公。显然，以厂为家和商业成功、个人成就之间，并没有必然联系。 唯有中国2C的互联网公司们，个个都说自己是躺着挣钱的科技企业，可明知常态化996没意义，为什么还乐此不疲呢？面对如此深邃的哲学问题，我就着同事吐出的烟圈，思考了好几个不眠的中午，才发现，原来我国流行的996，有几种成因各异然并卵的情形。 神仙打架 凡人遭殃说得明白点儿，你加的那些班，其实是公司政治斗争的牺牲品。读过《怎样在大公司混成中层干部？》的都知道，中层干部最爱做的，就是拼命扩大团队。怎么扩大呢？简单说就是狗揽八泡屎，喝不喝老端着：兄弟部门做了个好产品，我改头换面也做一个；中台明明有基础服务，我就要嘴硬强调部门需求，自己重新造个轮子。 这种内部竞争，才是赤裸裸的仇恨。既然你夸了海口，就得抢在别的团队前面把轮子造出来，所以只好加班加点，搞起了996。996的结果，无非是成王败寇：要是你在一个明星团队，干掉内部对手，就可以拿到大把股票；可要在一个失败的团队，干了半天被PK掉了，只好黯然离场。 倘若你加入的是阿里巴巴，就算是项目失败，回报也不会太差，996可以算是你的福报；可是还有更多的其他码畜，加入了阿里二大爷、阿里小姨子，同样在暗无天日的996以后，连公司都黄了，只好收拾起青春岁月，付了二分尘土一分流水。对他们来说，996还是福报么？ 把成功和失败的996er们拢在一块，平均来看大家不过是吃了些行业红利。而996，只不过是囚徒困境带来的超额付出罢了。如果你不幸是个失败的奋斗者，那么除了升高的尿酸和血脂，并不会留下什么无悔的青春。 表演作秀 骑虎难下大公司里，人员过剩是常态化的。人多就一定能出成绩么？显然不是！于是，一个合格的leader，一定要向老板撒娇：我们没功劳也有苦劳，没苦劳还有疲劳呢！怎么撒娇呢，干不干活老板不知道，晚上都在这儿耗着还能看不见么？于是，老板四点去打高尔夫，副总就五点去健身，总监就六点去喝茶，经理就七点去吃饭，组长就八点叫外卖，员工就九点往外冲。长此以往，干脆形成了996的潜规则，以及打车报销、晚上管饭之类的“福利”。乃至有的老板，也沉迷于这种男耕女织的火热场景，把平均工作时间作为一项重要的考核指标，谁耗得长才能多招人。 有人说了，这样做至少有甄别作用，不接受996的人一定也是不肯努力的。这话没错，可是您想过没有，不肯努力的人，就算是996也还是出工不出力不是？ 实际上，生活在996中的码畜们，大多是用空洞的会议填满整个白天，午饭晚饭后都安排漫长的行军式遛食，然后在华灯初上之时，才慵懒地开始一天的编码。我问过不同公司的几个码畜，他们告诉我：听说公司准备实行996，长长地松了一口气——这下可以心安理得地磨洋工了！ 有时，公司也要作秀。只有多掏点电费，晚上把大楼点得灯火通明，或者时不时分享几个加班改变人生的正能量案例，你的公司才被认为没有丢失创业精神，才能在中国互联网立足。 什么？你敢说自己就是不喜欢加班？你敢说自己的团队生活工作平衡？在当今中国互联网的政治正确里，光那几个自媒体鸡汤号儿，就能把你喷得生活不能自理了。 一将无能 累死三军忘了是曾子还是贝索斯说过：对一个项目来说，两个披萨还喂不饱的团队就太大了。这里有个血淋淋的事实：几乎没有一个明星产品，是靠堆人头做出来的。 而天天996的团队，往往有这样一个老板：他随大王起事多年，靠拍马屁和无底线成了封疆大吏。有一天，像印度军队为了给尼赫鲁庆生向中国军队开火一样，他深情地向团队发问：”大老板如此英明神武，我们为何不做个“牛逼”号飞船，登上牛郎星去吹牛逼呢？” 干部们当然是赞成之声一片。一地鸡毛之后，留下一群懵逼的产品经理，没日没夜地设计“牛逼”号。煞有介事地论证一番之后，大家给出了结论：”您的思路太完美，无奈团队能力不足，还是先把火箭做出来吧！” 老板轻蔑地瞧着火箭工程师：”这个火箭啊，我认为得烧煤，煤还得选蜂窝煤，水洗煤不好。”于是，在团队痛哭流涕地誓师之后，在“大干快上、早日升天”的标语下，五百人热火朝天地996了半年，终于造出了全球唯一的蜂窝煤动力火箭。上线那天，这玩意还真争气，嘭的一声就炸了！ 这下，老板可急眼了：“就是你们这些人不拼命！从明天开始，给我改007！……” 遇上这样的老板，怎么能不996呢？就算是996了，又有个屁用呢？ 总结起来，如果摒弃了生产关系领域那些龌龊的杯葛，你的团队真能做到目标清晰、决心坚定、兵精将勇、赏罚分明，为了完成阶段性的产品业务目标，996是确实是有战术意义的。不过，在千人以上的大公司里，这样的状态是可遇不可求的。而且，自驱力这么强的团队，还用得着把996当口号喊出来么？ 天真的码畜码农们，别以为你的高工资是996换来的，那更多是行业红利。当互联网风光不再之时，你就算997也不过像今天的的哥那样维持温饱。如果不能从做事转入治人，那么经年的螺丝钉岁月，会让你既无暇提高自己，也无法积累资源，在锈迹斑斑以后被新的螺丝钉换掉。 天真的中层干部们，也不要以为996彰显了你的执行力，其实那只是暴露了你的内斗为纲和业务无能。如果不改变生产关系第一性的协作态度，不以尊重科学规律的方法组织研发，996也没什么卵用。那么什么才有用呢，当然是007啦！ 作者：北冥乘海生来源：https://zhuanlan.zhihu.com/p/62765114","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"金三银四铜五铁六","slug":"金三银四铜五铁六","date":"2019-05-02T02:39:50.000Z","updated":"2019-05-07T07:59:52.255Z","comments":true,"path":"2019/05/02/jin-san-yin-si-tong-wu-tie-liu/","link":"","permalink":"http://chenguoji.com/2019/05/02/jin-san-yin-si-tong-wu-tie-liu/","excerpt":"","text":"鲁班简称LB 据说，金三银四，截止今天为止面试黄金时间已经过去十之八九，而LB恰逢是这批面试大军其中的一名小兵，很不幸今年恰逢遇上了互联网寒冬（即各大公司都在裁员，对外提供岗位相对较少的，这意味着很多猿即将面临着更多的竞争对手和相对较少的岗位困境），LB求职过程种种被虐，尸体趟过召唤师峡谷每个角落，如今历历在目，终究，当初的一名无名小卒如今已是一名超级兵哈哈，但是从这个事情上却学到了不少的东西，LB不亏。 经验也总是用来交流用的，于是LB觉得有必要记录下来，也许对猿们会有一丝帮助。 首先，找工作得有一份体面的简历，这里就会衍生一个如何书写简历的问题，LB将从如下角度总结： 关于简历 如何书写简历 HR角度较为关注信息 1.个人信息（年龄，联系方式等） 2.求职意向（工作年限，工作地，岗位） 3.教育经历（专业，学校，毕业时间） 证书（如ACM，软证，外语水平） 面试官角度较为关注信息 1.专业技能 4-5项熟悉2-3项了解，建议层次分明，逻辑有序，建议别写精通，除非很NB，不然被问到不是很深的问题你答不出，面试官认为你不真实。 2.自我评价 是否有博客（文章数太少不写，减分），是否有GITHUB（提交数和STRA太少不写，减分），是否有积极学网课（如极客时间星球，虚假减分）。 3.项目难点 队列和缓存高可用，分布式应用衍生问题解决方案，JVM的排查技能，数据库层面优化和分库分表等，这些东西都需要你嵌入到你的项目中。 那么什么是‘’优秀‘’的简历（网图） 看图 哈哈哈，我大佬说，看到这种简历直接扔垃圾桶吧，原因很简单，你既然那么牛逼还特么需要自己投简历找工作么，早就被挖了，这种一看就是啥经验都没有培训生或者不懂行规的应届生简历写的东西，那么合格的简历刚刚上面已经说了，专业技能模块不能写太多，层次分明就可以，大概这样： 暂不评价技术如何，光从这个专业技能在简历的书写规则上是很符合层次分明的，而且一行代表一个领域，总体上来看就是一个标准的JAVA后台开发路线的技术栈，而且从内容上来看，也有一定的侧重点，这样给面试官的感觉就会比较友好，提问方便。与人方便自己方便。 如何投递简历 拉钩，公司官方网 这种看RP了，有时候投出去也大概率不会被看到，称之为海投，收到面试邀请不管怎么样，去了再说，毕竟是一种经历，总能学到东西的，但如果是你比较想去的公司，没有很大得取胜信心，建议别投先，毕竟如果被刷，那就得含泪在等一年了。 BOSS直聘，脉脉 搜索你想去的公司，然后加HR或者技术官后给他们发简历，本质和BOSS直聘差不多，他们看到你的简历，并且觉得OK，一般都非常愿意帮你内推的，因为内推录用了，是有推荐金的。 朋友内推，猎头内推 这种获得面试机会几率较高，因为是直推的。 关于面试 面试需要准备3个部分的东西 算法智力题笔试 项目技术面试 HR跪舔与防坑宝典 首先是算法编程题 这个没办法的，会就会不会的话，短时间之内也是做不出来的，有些公司硬性规定必须要你写出来，否则免谈，LB遇到个一个很奇葩的一次面试就是，笔试题出了编程题目，没想到一面后面完了，还让你去做一道编程题，二面也是，估计HR面也是。。无可厚非，因为他们认为动手能力才是最重要的，所以对于猿们唯一的办法就是提前刷题，如果不是面试对算法有较高要求的公司，一般的公司只要把LeetCode简单的题目刷了就能做出来大部分的题目，甚至会遇到一模一样的题目，连标点符号也一样哦。 然后就是智力题 其实也不是什么智力题，网上一搜程序员面试智力题一大推，看来看去也就是那几类问题，头脑比较聪明的猿基本不需要准备。 这里重点讲讲技术面 面试官：能写出一段能体现你水平的代码~ LB:好的~ 几秒后~ 1 while{2 Scanner scan = new Scanner(System.in);3 String question = scan.nextLine();4 String answer =question.replace (‘你’, ‘我’). replace (‘吗’, ‘ ‘). replace (‘?’, ‘!’) )；5 Sysem.out.println (answer );6 } 面试官：呀，这难道就是….. LB：没错，是失传已久的Artificial Intelligence 面试官：你究竟是什么人？ LB：阁下莫问出处，这个程序我示范给您看下 面试官：好的 LB：在吗？ 电脑：在！ LB：你可以人机对话吗？ 电脑：我可以人机对话！ LB：你会自己思考吗？ 电脑：我会自己思考！ 面试官也跃跃欲试：你可以滚出去吗？ 电脑：我可以滚出去！ 寒冷的冬天，外出的农夫，看见一条冻僵的蛇，于是把蛇带回了家，解冻之后，泡进酒里，蛇终于醒了，看到如此场景，蛇说:我也是醉了。 emmm~ 言归正传，技术面就是看你的技术栈，然后结合项目去提问，并根据项目遇到的问题，要求回答出解决方案，并且根据遇到的问题会继续问深一层或者变形，考察你是否真的对问题进行了仔细的思考和深入的研究，以及问题对应的技术功底是否深厚，所以这里提到的重点是项目结合技术栈，如果你的项目没有用到你写的技术，那么就是扯蛋，那么面试官就会认为这个候选人只是停留在理论基础或者是初学，并没有实践，如果是应届生还说的过去，否则多半会被PASS。 那什么基础功底 比如问你某些关键字的作用如static 如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，满意的原因是能看出你确实非常热衷研究技术。这比你在自我评价写一万句本人热爱研究技术，学习能力强之类的废话更有说服力。 又如问你对锁部分的了解 1.一般人回答出Synchronized具有多线程的同步作用，能防止多个线性同时访问同一临界资源。 2.但是却很少人提到 Synchronized的局限性（无法解決业务层面并发）。 3.可以说明锁的用法，如可以创建 Reentrantlock类的可重入锁，而且可以通过其中的lock和unlock方法行加锁和解锁的操作。 4.说出可重入锁、公平锁和读写锁，如词锁的含义、公平数的含义，以及在创建 Reentrantlock和 Semaphore时如何通过参数强它是否是公平锁，也可以说明在读写锁中加读锁和写锁的条件，由此介绍通过读写线程吞吐量的做法。 5.在协调多个线程处理临界资源时，可以使用锁，但这不是唯一的解决方法，还可以用 Condition和 Semaphore管理多线程竟争的方法。首先，说明这两个类的基本用法如可以通过 Reentrantlock来创建 Condition，过 Condition的awat和 signal来实现类似加锁和解锁的功能，可以通过 Semaphore acquire和 release方法来申请和释放资源。另外，说明用 Condition和 Semaphore的特点（在哪些场景下用它们比较合适）通过 Condition类的相关方法，可以在不同的线程中创建多个阻塞队列，从而能精准的控制唤醒某个阻塞队列的线程，而不是只唤醒默认的阻塞队列的线程，而 Semaphore可以用在多个线程竞争少量资源的场合中。如10张票，20个线程的抢购场景。 再如问你对框架里的了解 因为一般的候选人，大多仅仅是能“山寨”别人的代码，也就是说能在现有框架的基础上，照着别人写的流程，扩展出新的功能模块。比如要写个股票挂单的功能模块，是会模仿现有的下单流程，然后从前端到后端再到数据库，依样画葫芦写一遍，最多把功能相关的代码点改掉。其实我们每个人都这样过来的，但在面试时，如果你仅仅表现出这样的能力，就和大多数人的水平差不多了，在这点就没法体现出你的优势了。 我们知道，如果单纯使用SSM框架，大多数项目都会有痛点。比如数据库性能差，或者业务模块比较复杂，并发量比较高，用Spring MVC里的Controller无法满足跳转的需求。所以一般还会被问：你除了依照现有框架写业务代码时，还做了哪些改动？ 对于这个问题，不在乎听到什么回答，只关心回答符不符逻辑。一般只要答对，面试官就会给出“在框架层面有自己的体会，有一定的了解”，否则，就只会给出“只能在项目经理带领下编写框架代码，对框架本身了解不多”。 回答例如有：增加了Redis缓存，以避免频繁调用一些不变的数据。或者，在MyBitas的xml里，select语句where条件有isnull，即这个值有就增加一个where条件，对此，会对任何一个where增加一个不带isnull的查询条件，以免该语句当传入参数都是null时，做全表扫描。或者对返回信息做了压缩处理，以增加网络传输性能。 小结： 技术面试非常重要，这里说的重要不是说对于整个求职过程重要，因为在求职过程哪怕是HR面都有权利决定不要你，所以说没有重不重要的，这里说的重要的是指这是检验你自身水平的能力的考察，通过面试其实可以反映出你的自身很多问题，比如，知识面有了，但是不够全面，或者知识面全了但是不够深入，或者把需求转化为实际产品的能力不足等等，这些东西才是对于你来说是重要的，如果你的能力有了，还会害怕找不到工作吗？这里最怕的就是明知自己能力不足，又不愿意专研学习，还想着高新，只能说你不适合当一名程序员。 那么问题来了，我知道自己的情况，但是又不知道努力的方向，或者不知道怎么提升自己，怎么办？如果你能提出这样的问题，LB只能说，你独立解决问题能力确实也是挺差的，因为在我们开发当中，经常会遇到一些需求，都不知道怎么去做，或者用一些完全没接触过用的框架，如果团队中有人熟悉那还好，但是也别指望别人教你太多，所以这个时候就只能靠自己了，无它，需要你通过网上找教学资料（视频，博客，官方网）的方式快速学习，这些资料花几块钱随手可得，然后一步一个脚印慢慢的把产品做出来。 HR跪舔与防坑宝典（LB总结了一些） 自我介绍 您好，很荣幸有机会来参加公司的面试 1.个人经历（我是谁，我来自哪里，年龄，学历，从业经历）实习加上正职 2.公司为什么要选你（应聘岗位中最重要的3个技能点，说清楚相关经验）我能做好我要做的事情，我相信自己 3.你为什么要选这家公司（就公司的产品，文化，影响力等）着重说出你选择的理由如贵公司的高技术开发环境很吸引我，贵公司在近年来市场上很有竞争力，贵公司能够提供一个与众不同的发展道理 高频问题 1.上一家公司，你为什么会离职？ 1.公司很好，但是公司调整了业务，接下来的发展路线和自己的目标不一致，所以要换工作 2.工作太清闲，学不到知识，我不怕累，就是想多锻炼自己，想找具有挑战力工作 3.公司的管理制度不也是很完善，没有晋升机会，我比较想进步，找一个更好的平台 4.我想去优秀的公司，让自己变得更好 2.为什么来我们这里？ 1.对原单位充满感恩，这是我人生中非常重要的经历，我认同原单位领导和文化 2.两份工作的本质是一致的，行业和工作性质都有紧密联系 3.选择一份新的工作不代表背叛过去，发扬原公司魅力，同时为了寻求更大的成长和突破 4.不承诺一份工作干一辈子，保证在我的任期内尽职尽责 3.你怎么看待自己以后的职涯？（包括工作和家庭的分配，怎么平衡家庭和工作的关系、加班、选择一家公司时的考量、地点等）（离职稳定性） 我准备在技术领域有所作为，我希望在我3到5年内，具备什么样的素质，在行业内达到什么样的水平，产出什么样的工作成果，将规划量化，具体化 4.对薪资期望（不要直接说数，绝不能表现出没到多少钱或者什么层级我就不去） 薪资应该基于你求职行业的市场价格和自身的价值，例如目前这个岗位的平均工资是8K，虽然我刚毕业，但是在我工作期间已经有过两份的相关经验而且都是作为核心成员参与项目，因此可以很快上手这份工作，所以我希望能够在转正后的工资能达到10K等等 5.可以接受降薪吗？（先了解公司薪酬体系，根据行业和自身能力来定位） 如果候选人的调性符合（足够官方），可以这么回答：我也了解咋们公司现在的薪资架构，我相信公司会根据我的能力给出一个合理的薪水方案，我相信只要把事情做好，该有的一定会有的对于这样的部门，“ 毕竟贵公司在做一个从来没有人做的这么好的事情，所以肯定是有难度的，肯定是要付出大量努力的 ” 6自己觉得自己工作上的短板/优点是什么？ 1.不能避而不谈， 2.不能变相夸自己， 3.不能暴露重大缺陷， 4.可以将一些能接受能改进的缺点 综上：缺点加说明加改进 7.说说自己性格上的优缺点（描述一下自己的性格） 我不懂得如何拒绝他人，我拉不下面子去指出别人的问题，我做事的时候希望马上就能看到成效，有时候会比较贪心，想同时做好几项工作，我比较慢热，不善于和陌生人打交道，我有意识的让自己在改正，让自己更加有亲和力，我非常在意别人对自己的工作评价，得不到好评就会焦虑，其实我也在开导自己别太功利心了。沉着冷静，条例清楚，立场坚定，顽强向上，乐于助人和关心他人，适应能力等等 8.怎么看待加班（你能接受996、997、007吗）？ 可以接受版本 如果候选人的调性符合（足够官方），可以这么回答：我觉得我们要实现梦想，一定是要付出比较多努力的，所以我已经做好了准备，也愿意和小伙伴们一起战斗我是可以加班的，我现在加班强度就是比较大的。因为我喜欢这个事情，我想把这个事情做好。项目忙的时候可能一个月都没有休息日，我觉得要应对这么忙的工作，光有心理准备其实还不够，还要有特别好的身体素质，所以我准备把健身的习惯一直坚持下去 不接受版本 加班是应该的，不加班也是应该的，没有把事情做完是不应该的，因为能力低完成工作慢造成的加班，并不是一件好事，不加班是能力，加班是态度，能力不够的情况下，态度去补。 9.你谈恋爱了没？（状态是否稳定，会不会因为感情影响工作，很快结婚，休婚假产假） 我还没有谈恋爱，目前不考虑恋爱问题，我希望自己变得更优秀以后，在谈一场稳定的恋爱，所以现在想把主要的精力放在工作上。 我已经有男朋友或女朋友，我们都在这个城市工作，目前准备先工作几年，有精力能力了在考虑结婚。 10.是否还面试其他公司（HR确认求职意向与诚信度） 实话实说，选择名声较大较好的公司来说，职位和现在的求职相思相近，表是自己求职意向专一，还在等候结果 11.项目中遇到的最大挑战是什么？怎么解决的？ 因人而已，需要描述问题产生的原因，查找解决问题的方式，对比那种更加好，遇到什么问题，最终怎么一步一步解决的 12.最有成就感的事情是? 做有挑战性的事情，并且能够做好，或者是坚持一个习惯很久，如坚持写博客，坚持看书 13.你有什么问题想问的？ 1.你作为一个资深的CODER，我想知道，你平时是怎么学习技术，有什么好的学习途径，怎么才能做到像你一样强呢？ 2.公司的业务和技术栈是什么呢？ 3.技术难点怎么解决，有什么技术支持 4.每天有多少时间花在写代码上 14.收到OFFER该问的5个问题 1.试用期工资和时间（正常来说合同是3年，试用期是3个月） 2.转正考核的方式，转正工资 3.工作时间以及加班计算（一周五天工作制，一天8小时） 4.培训晋升机制 5.福利情况（五险一金，餐补，其他补贴如电脑补贴） 作者：卓庆森出处：https://www.cnblogs.com/zhuoqingsen/","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"产品经理如何让程序员放下手中的刀？","slug":"产品经理如何让程序员放下手中的刀？","date":"2019-05-02T02:39:50.000Z","updated":"2019-05-07T08:06:14.491Z","comments":true,"path":"2019/05/02/chan-pin-jing-li-ru-he-rang-cheng-xu-yuan-fang-xia-shou-zhong-de-dao/","link":"","permalink":"http://chenguoji.com/2019/05/02/chan-pin-jing-li-ru-he-rang-cheng-xu-yuan-fang-xia-shou-zhong-de-dao/","excerpt":"","text":"摘要： 友好合作是一门艺术。 原文：如何让程序员放下手中的刀？作者：VickyFundebug经授权转载，版权归原作者所有。 产品经理和程序员似乎是天生的一对死对头，在面对产品经理不断更改的需求时，脾气再好的程序员也会情绪暴走，如何巧妙地避免这种情况的发生呢？ 众所周知，产品经理跟程序员属于死对头岗位，程序员跟产品经理因为需求打起来的新闻更是屡见不鲜，甚至还出现过程序员暴力砍人的事件，因此一干产品甚至开玩笑说产品这个行业属于高危行业，随时面临着被砍，被套麻袋，被群殴等各种问题。 虽说没有到描述的这么可怕，但是在面对不断更新需求即将爆发的程序，如何让他们放下手中的刀，确实尤为重要。 这里主要分析的场是面对需求频繁更改已经处于暴走边缘的程序员如何安抚的场景。 造成需求不断更改的原因有很多： 客户突然更改的想法并且要求必须实现。 领导突然又看到了一个app并要求按照此app做出更改。 之前由于考虑不周后期需要填坑。 技术之前就没理解需求，出现了问题需要大改。 ……面对一改再改的需求，脾气再好的程序员也会变身暴躁龙，身为产品狗的我们为了需求能尽快落地，先稳住开发是非常重要的。 稳住开发是关键 1. 解释需求更改的原因，该认错认错，不是自己的错也先背着（毕竟产品背锅侠）。需要更改一个需求之前，先让技术知道更改的原因，所有的需求调整都是有理有据，不是灵光一闪。 产品经理作为贯穿整个产品研发周期的责任人，不管产品出现什么问题，首当其冲站出来，能提高团队的信赖感。 2. 怀柔政策，可以跟技术表现同仇敌忾，一致对外。这个让技术产生共情心理，告诉他们我们其实是一个战线的，让他们产生一种是自己人的感觉，在后续更好的去说服技术人员进行调整。 3. 肯定技术的能力。技术是需要认同的，之前工作的心血因为一个调整可能就全部付诸流水了，心理难免要炸。所以一定要先肯定技术的能力，每个技术都是需要夸奖的，适当并且到位的夸奖能降低技术对需求更改的抵触心理。 4. 调整需求的时候，更多的让技术参与这个过程，让他们产生认同感。我们在确认某个功能需求调整之后，可以先试探的性的跟技术沟通，对于这个功能是否觉得有不合理的地方，是不是应该进行一下调整会更好，让技术发表自己的意见然后慢慢引导，最终导向我们希望的结果，这个过程技术参与进来，会让他们产生一种认同感，这个能更好的让技术接受需求调整这个结果。 一个产品开发的生命周期会收到来自各个相关方的意见反馈，作为产品经理，除了不可抗力的更改因素外，更多的是要考虑产品的完善性，减少因为前期准备不足导致的后期修补性的更改，这些更改会造成人力成本的提高，以及项目团队的不和谐。 除了不可抗力因素外，产品能把控的就是在产品规划前期对产品需求的描述，这里会决定开发最终交付的成果是否能达到产品的要求。 我们分析一下产品跟技术对立对需求想法不一致的源头，两者所占的角度不同，看问题的点也不一样，所以我们最常听到的两者争吵的语句就是以下： 双方都有自己的立足点，看问题的角度不一样，开始可能是讨论，后面就可能演变为争论。 产品的立点： 产品定位； 需求场景； 用户体验； 业务目标。 技术的立点： 功能实现； 开发难易； 后期维护； 改动成本。 前期做好准备双方站在自己的领域范围下，都是有理有据，但是放到一起，产品的开发过程就会举步维艰，产品要这个功能明天实现，技术考虑这个功能起码一个星期甚至说这个需求根本不可能实现，要么砍需求要么改需求，产品也不会答应，你来我往，双方就此展开撕逼。 这里总结了几点产品经理在前期做好可以减少很多不必要的争吵经验。 1. 需求明确，逻辑清晰，思维缜密，不要让程序猜。我们在制作产品原型以及编写PRD文档的时候，一定要清晰准确的描述需求目的，所有的需求都是从合理的角度出发，有理有据，减少带个人主观性的语言描述（比如我觉得，我认为），这样的描述会给开发留下一种产品没有从实际出发，所有功能都是拍脑袋想出来的，团队会存在不信任感，也会给开发留下一种能力不行的印象，会导致后面的需求更难落地。 在对功能做描述的时候，尽可能详细的考虑到多种场景，减少程序的想象空间，我们想的越多，考虑的越全，程序在开发的过程中才能更贴近我们的原本需求。 比如对一个输入框做说明，我们要考虑的首先是字符长度边界、可支持输入的字符类型（比如手机号码输入就是数字型，但是备注输入就是没有限制）、是否必填、是否有默认值、是否有提示语、错误输入的状态提示等常规性的描述。但是还有一些特殊场景，比如输入文本时，需要自动带出之前输入过的字符，支持直接快速选中快速录入，是否支持粘贴等这些也是要考虑进去的。总之产品前期考虑的越全，程序开发才会更容易，后期也不会因为产品漏了一些场景而产生不要的变更。 2. 尊重并理解技术人员。调查了一下身边的程序员，最烦听到的来自产品的话语：“这个需求很简单……”荣登榜首，反思一下，主要是因为一部分产品不懂技术，仅通过主观臆断就决定开发周期的长短。 举个例子：需求是去超市买瓶水；技术要考虑的可能就是路程有多远，走路合适还是需要坐车；一共有几条路可以到超市；水是只有一种还是有多种；如果有很多人一起买水是需要排队还是可以多线程……. 所以我们再给出需求之后，可以多听听程序的意见，不要通过主观想法开口就是“这个需求很简单……”。同时我们也要多学习一点的技术，不懂就问，平时可以多去一些技术论坛逛逛，也是为了避免一个需求评审完，技术报了3天，结果两小时就做完了这种情况。 3. 小事线上沟通，大事当面沟通，所有的调整都要做好书面记录。程序在开发的过程中是需要大量进行思考，所以中途被打断，可能前面的准备就前功尽弃了，所有没有什么特别重要的通知的时候，可以通过线上交流，等技术忙完自然会去看。 对于很重要的事情，一定要当面沟通，不要因为害怕冲突就发邮件通知。书面内容每个人在理解的时候很可能产生误差，最后造成更大的问题。积极主动，加上真诚，和善的态度，是避免冲突的良好开始。 最重要的一点，所有的调整在通知并确定方案后一定要书面记录，程序每天要接收很多讯息，很多需求我们在沟通后他们不一定会及时去处理，甚至小一点的变动可能会漏掉，所以在沟通清楚后，一定要记录在便于程序查看的位置，也方便后面测试可以了解。 一般我们可以在原型前增加一页，专门用来记录调整的需求，并且对每个调整的页面后放置快速跳转链接，便于程序快速定位。如下图： 4. 私下交流，合理套路。人都是有感情的动物，关系亲近也会有利于冲突的减少。很多人喜欢把工作和生活区分对待，但实际上我们的生活大部分时间都在工作，工作中的程序和产品私底下也可能是很好的朋友，了解每个人的工作方式和沟通喜好，更有利于对症下药，当对每个程序进行性格的个体分析后，就可以合理套路了。 产品跟程序没有职属关系，但是在推动研发按时交付时，就只能靠人格魅力了，平时大家关系很好点点滴滴都看在眼里，程序自然也不想产品为难，能做的就做了，做不完的可能加班也给做了。 产品经理负责产品各项事物的协调和推进，需要有强大的心脏以及很高的情商，多站在对方的角度看待问题，做出正确的判断，专业素质越强，程序才能越信服，沟通才会更加顺畅。 作者: Fundebug来源：https://blog.fundebug.com/2019/04/28/how-does-product-manager-cooperate-with-programmer/","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}],"tags":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/tags/程序猿/"}],"keywords":[{"name":"程序猿","slug":"程序猿","permalink":"http://chenguoji.com/categories/程序猿/"}]},{"title":"2018秋招面经","slug":"2018秋招面经","date":"2019-05-01T02:39:50.000Z","updated":"2019-05-06T02:18:39.943Z","comments":true,"path":"2019/05/01/2018-qiu-zhao-mian-jing/","link":"","permalink":"http://chenguoji.com/2019/05/01/2018-qiu-zhao-mian-jing/","excerpt":"","text":"秋招已经结束很久了，终于有时间给自己的秋招进行一个简单的总结。自己在找工作的每一天上午做的第一件事就是打开牛客，看看上面的最新动态（了解一些招聘信息、别人发的面经），从中受益良多，有幸拿到了华为、贝壳、百度、阿里巴巴……等公司的offer，所以现在把自己的经历简单的总结一下，希望可以帮到有需要的朋友。 一、阿里巴巴阿里巴巴面试了两个部门，说多了都是眼泪…… 一面（8.9）http协议2.0和1.1的区别什么时候发生stackOverflow、一个线程的工作栈是多大？哪些区域会发生OOMJvm的线程和操作系统线程的关系hashmap的实现，怎么解决冲突，其他解决冲突的方法，使用过哪些线程安全的集合，优先队列的实现（怎么实现排序）TreeMap的实现，红黑树的优点，介绍一下其他的平衡树，数据库索引为什么采用B+树 二面（8.16）自我介绍，实验室的研究方向，自己的研究方向。详细讲一下项目，自己的贡献，当前怎么改进项目，还有那些可以改进的地方。github上的贡献。 三面（8.23）自我介绍讲一件印象最深刻的事项目是怎么改进的，别人如何访问你的后台代码tomcat的一次访问过程，怎么实现文件断点续传如何实现手机通讯录排行的功能，treemap的实现，插入节点的时间复杂度，hashmap的插入时间复杂度。 四面（8.24）自己的详细介绍（家庭情况），大学生活，最成功的一件事。高考分数，大学、研究生学习情况等等。 一面（9.4）晚上九点多接到了阿里的面试电话，因为之前已经面试过，所以这次就聊了大概二十分钟。介绍项目，消息队列的使用，多线程怎么使用消息队列，生产者消费者模型的实现。Java中的并发，synchronize关键字的作用，修饰方法、变量和类的区别。最后问了一下部门的主要业务，面试官很耐心的讲解了五分钟。 二面（9.5）第二天上午又接到了面试官的面试电话。这次是一个leader，上来让讲述一下项目中的流程，实现上的细节，改进方案。最后问了一个场景题目：题目太复杂了不好描述，在这就不赘述了，总之需要看一下大数据量下高并发的场景题目，然后才可以游刃有余的回答这类问题。 三面（9.6）HR这次面试约定的时间是中午，但是由于上午的网易面试拖到了中午12点多才开始，所以一点的时候正在面试网易，无奈阿里的电话一点准时过来了，在向网易的面试官解释了情况后就暂停了网易的面试。自我介绍，平时怎么学习，有发表过论文吗？介绍一下项目中的难点（HR小姐姐说了不要使用太复杂的专业术语，她可能听不懂），然后针对项目问了几个问题，你们之前产品的用户量是多少？项目还可以改进吗，是你们的技术问题，还是其他问题导致项目存在bug，如何提升项目的效果。最后让我提问一个问题。 四面（9.8）约定的面试时间是12点（居然是晚上12点），难怪中午12点一直没有等到面试电话。讲述一下项目的难点，自己怎么改进的，面试官对改进方案感到困惑，说这方案效果上会存在问题吗？只好给面试官具体介绍了一下。你们的项目和其他的项目有什么区别，跟其他的公司的技术相比呢？用到了哪些技术栈？（这在华为面试的时候问到了，所以自己就补了补该知识）自己未来的发展规划，自然语言领域未来的发展和和可能遇到的问题。 二、CVTE一面（8.7）介绍项目，怎么分词的redis在哪儿使用，怎么更新缓存，redis的数据类型用过哪些关系数据库？索引的好处，索引是否是越多越好hasmap的原理服务器访问量大的时候怎么处理，有没有了解负载均衡Spring框架， 动态代理的实现方式及比较自己的研究方向，为什么选择后台开发 二面（8.13）自我介绍介绍一下项目，自己负责哪一部分，最难的地方在哪儿用过那种数据库，写个sql语句，存储引擎的区别，为什么用Innodb索引的用途，越多越好吗？为什么可以加快查询的速度，索引失效的场景，联合索引的使用悲观锁、乐观锁的区别和应用场景，哪些框架使用了悲观锁和乐观锁java的五个运行时异常，String为什么用final修饰 三、猿辅导一面自我介绍，介绍自己的项目。简单问了之前的项目，然后问对游戏开发有没有了解。知道并发吗，如何实现，如何检测死锁。jvm了解吗，垃圾回收的四种引用介绍一下；如何通过jdk自带的工具判断程序发生死锁的位置。haspmap为什么是线程不安全的jdk 1.7 和1.8的区别 二面介绍项目，自己主要负责哪一块。对游戏有没有了解并发（线程池及实现原理）jvm中的类的加载，什么时候触发fullGCJava集合类，list、arrayList的实现，初始大小，空间不够的时候如何扩容；hashmap除了线程不安全造成数据不一致之外，有没有可能造成程序异常判断单链表中有没有环。为什么选择游戏开发这个行业。 三面职业规划，毕业之后愿意来这边工作吗？为什么选择Java服务端开发这个岗位？为什么选择我们公司？有什么问题问我的吗？ 作者：greenbird链接：https://www.nowcoder.com/discuss/151562来源：牛客网","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://chenguoji.com/tags/Java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"面试中常问的Linux命令","slug":"面试中常问的Linux命令","date":"2019-04-30T02:39:50.000Z","updated":"2019-05-06T02:13:26.411Z","comments":true,"path":"2019/04/30/mian-shi-zhong-chang-wen-de-linux-ming-ling/","link":"","permalink":"http://chenguoji.com/2019/04/30/mian-shi-zhong-chang-wen-de-linux-ming-ling/","excerpt":"","text":"Linux常用命令一、文件和目录1. cd命令（它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径）cd /home 进入 &apos;/ home&apos; 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 2. pwd命令pwd 显示工作路径 3. ls命令 （查看文件与目录的命令，list之意）ls 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 列出全部文件，包含隐藏文件 ls -R 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 ls *[0-9]* 显示包含数字的文件名和目录名 4. cp 命令（用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下）-a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 5. mv命令（用于移动文件、目录或更名，move之意） -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 6. rm 命令（用于删除文件或目录，remove之意） -f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 二、查看文件内容7. cat命令（用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用）cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 cat -n file1 标示文件的行数 more file1 查看一个长文件的内容 head -n 2 file1 查看一个文件的前两行 tail -n 2 file1 查看一个文件的最后两行 tail -n +1000 file1 从1000行开始显示，显示1000行以后的 cat filename | head -n 3000 | tail -n +1000 显示1000行到3000行 cat filename | tail -n +3000 | head -n 1000 从第3000行开始，显示1000(即显示3000~3999行) 三、文件搜索8. find命令（）find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 删除大于50M的文件： find /var/mail/ -size +50M -exec rm {} ＼; 四、文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消9. chmod 命令ls -lh 显示权限 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r，4 ）、写(w，2)和执行(x，1)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 10. chown 命令（改变文件的所有者）chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chown user1:group1 file1 改变一个文件的所有人和群组属性 11. chgrp 命令（改变文件所属用户组）chgrp group1 file1 改变文件的群组 五、文本处理12. grep 命令（分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等）grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 13. paste 命令paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 14. sort 命令sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) 15. comm 命令comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 六、打包和压缩文件16. tar 命令（对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压）-c ：新建打包文件 -t ：查看打包文件的内容含有哪些文件名 -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j ：通过bzip2的支持进行压缩/解压缩 -z ：通过gzip的支持进行压缩/解压缩 -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来 -f filename ：filename为要处理的文件 -C dir ：指定压缩/解压缩的目录dir 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 zip file1.zip file1 创建一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 七、系统和关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 time 测算一个命令（即程序）的执行时间 八、进程相关的命令jps命令 （显示当前系统的java进程情况，及其id号）jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 ps命令 （用于将某个时间点的进程运行情况选取下来并输出，process之意）-A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出 ps aux # 查看系统所有的进程数据ps ax # 查看不与terminal有关的所有进程ps -lA # 查看系统所有的进程数据ps axjf # 查看连同一部分进程树状态 kill命令 （用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用）killall命令 （向一个命令启动的进程发送一个信号） top命令 是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 如何杀死进程：（1）图形化界面的方式（2）kill -9 pid （-9表示强制关闭）（3）killall -9 程序的名字（4）pkill 程序的名字 查看进程端口号：netstat -tunlp|grep 端口号 九、普通文件和目录文件的区别9.1 文件的类型Linux下面一切皆文件，配置是文件，设备是文件，目录也是特殊的文件，文件有如下几种： d：目录文件的标识是，-：普通文件标识，l：软连接文件，亦称符号链接文件；b，块文件，是设备文件的一种（还有另一种），b是block的简写。c，字符文件，也是设备文件的一种，c是character的文件。 9.2 普通文件和目录文件普通文件：存储普通数据，一般就是字符串。 目录文件：存储了一张表，该表就是该目录文件下，所有文件名和inode的映射关系。 9.3 权限的区别对于普通文件来说，rwx的意义是： r：可以获得这个普通文件的名字和内容。 w：可以修改这个文件的内容和文件名。可以删除该文件。 x：该文件是否具有被执行的权限。 对于目录文件来说，rwx的意义是： r：表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名。 就可以利用 ls 这个命令将该目录的内容列表显示出来， 必须这个目录有x的权限，才可以进入这个目录。 w：移动该目录结构列表的权限（建立新的文件与目录、删除已经存在的文件与目录、更名、移动位置）。 x：目录不可以被执行，目录的x代表的是用户能否进入该目录成为工作目录。 来源: http://t.cn/EqTIhES","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://chenguoji.com/tags/Linux/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"MySQL 查询优化","slug":"MySQL 查询优化","date":"2019-04-29T02:39:50.000Z","updated":"2019-05-06T02:12:15.756Z","comments":true,"path":"2019/04/29/mysql-cha-xun-you-hua/","link":"","permalink":"http://chenguoji.com/2019/04/29/mysql-cha-xun-you-hua/","excerpt":"","text":"一、什么影响了数据库查询速度1.1 影响数据库查询速度的四个因素1.2 风险分析QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。 Tips：最好不要在主库上数据库备份，大型活动前取消这样的计划。 1、效率低下的sql：超高的QPS与TPS。 2、大量的并发：数据连接数被占满（max_connection默认100，一般把连接数设置得大一些）。 3、并发量:同一时刻数据库服务器处理的请求数量 4、超高的CPU使用率：CPU资源耗尽出现宕机。 5、磁盘IO：磁盘IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。 1.3 网卡流量：如何避免无法连接数据库的情况1、减少从服务器的数量（从服务器会从主服务器复制日志） 2、进行分级缓存（避免前端大量缓存失效） 3、避免使用select * 进行查询 4、分离业务网络和服务器网络 1.4 大表带来的问题（重要）1.4.1 大表的特点1、记录行数巨大，单表超千万 2、表数据文件巨大，超过10个G 1.4.2 大表的危害1.慢查询：很难在短时间内过滤出需要的数据 查询字区分度低 -&gt; 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘io -&gt; 降低磁盘效率 2.对DDL影响： 建立索引需要很长时间： MySQL -v&lt;5.5 建立索引会锁表 MySQL -v&gt;=5.5 建立索引会造成主从延迟（mysql建立索引，先在组上执行，再在库上执行） 修改表结构需要长时间的锁表：会造成长时间的主从延迟(‘480秒延迟’) 1.4.3 如何处理数据库上的大表分库分表把一张大表分成多个小表 难点： 1.分表主键的选择 2.分表后跨分区数据的查询和统计 1.5 大事务带来的问题（重要）1.5.1 什么是事务1.事务是数据库系统区别于其他一切文件系统的重要特性之一 2.事务是一组具有原子性的SQL语句，或是一个独立的工作单元 1.5.2事务的ACID属性1、原子性（atomicity)：全部成功，全部回滚失败。银行存取款。2、一致性（consistent)：银行转账的总金额不变。3、隔离性（isolation)： 隔离性等级： 未提交读(READ UNCOMMITED) 脏读,两个事务之间互相可见； 已提交读(READ COMMITED)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据。 可重复读(REPEATABLE READ) InnoDB的默认隔离等级。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的！ 可串行化（SERIALIZABLE） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。 查看系统的事务隔离级别：show variables like ‘%iso%’;开启一个新事务：begin;提交一个事务：commit;修改事物的隔离级别：set session tx_isolation=’read-committed’; 4、持久性(DURABILITY)：从数据库的角度的持久性，磁盘损坏就不行了 redo log机制保证事务更新的一致性和持久性 1.5.3 大事务运行时间长，操作数据比较多的事务； 风险：锁定数据太多，回滚时间长，执行时间长。 1.锁定太多数据，造成大量阻塞和锁超时； 2.回滚时所需时间比较长，且数据仍然会处于锁定； 3.如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。 解决思路： 1.避免一次处理太多数据，可以分批次处理； 2.移出不必要的SELECT操作，保证事务中只有必要的写操作。 二、什么影响了MySQL性能（非常重要）2.1 影响性能的几个方面1.服务器硬件。 2.服务器系统（系统参数优化）。 3.存储引擎。 MyISAM： 不支持事务，表级锁。 InnoDB: 支持事务，支持行级锁，事务ACID。 4.数据库参数配置。 5.数据库结构设计和SQL语句。（重点优化） 2.2 MySQL体系结构分三层：客户端-&gt;服务层-&gt;存储引擎 1.MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!2.所有跨存储引擎的功能都是在服务层实现的。3.MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。 2.3 InnoDB存储引擎MySQL5.5及之后版本默认的存储引擎：InnoDB。 2.3.1 InnoDB使用表空间进行数据存储。show variables like ‘innodb_file_per_table 如果innodb_file_per_table 为 ON 将建立独立的表空间，文件为tablename.ibd； 如果innodb_file_per_table 为 OFF 将数据存储到系统的共享表空间，文件为ibdataX（X为从1开始的整数）； .frm ：是服务器层面产生的文件，类似服务器层的数据字典，记录表结构。 2.3.2 (MySQL5.5默认)系统表空间与(MySQL5.6及以后默认)独立表空间1.1 系统表空间无法简单的收缩文件大小，造成空间浪费，并会产生大量的磁盘碎片。 1.2 独立表空间可以通过optimeze table 收缩系统文件，不需要重启服务器也不会影响对表的正常访问。 2.1 如果对多个表进行刷新时，实际上是顺序进行的，会产生IO瓶颈。 2.2 独立表空间可以同时向多个文件刷新数据。 强烈建立对Innodb 使用独立表空间，优化什么的更方便，可控。 2.3.3 系统表空间的表转移到独立表空间中的方法1、使用mysqldump 导出所有数据库数据（存储过程、触发器、计划任务一起都要导出 ）可以在从服务器上操作。 2、停止MYsql 服务器，修改参数（my.cnf加入innodb_file_per_table），并删除Inoodb相关文件（可以重建Data目录）。 3、重启MYSQL，并重建Innodb系统表空间。 4、 重新导入数据。 或者 Alter table 同样可以的转移，但是无法回收系统表空间中占用的空间。 2.4 InnoDB存储引擎的特性2.4.1 特性一：事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log1.Innodb 是一种事务性存储引擎。 2.完全支持事务的ACID特性。 3.支持事务所需要的两个特殊日志类型：Redo Log 和Undo Log Redo Log：实现事务的持久性(已提交的事务)。 Undo Log：未提交的事务，独立于表空间，需要随机访问，可以存储在高性能io设备上。 Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。 2.4.2 特性二：支持行级锁1.InnoDB支持行级锁。 2.行级锁可以最大程度地支持并发。 3.行级锁是由存储引擎层实现的。 2.5 什么是锁2.5.1 锁1.锁对主要作用是管理共享资源的并发访问 2.锁用于实现事务的隔离性 2.5.2 锁类型 2.5.3 锁的粒度MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关 将table_name加表级锁命令：lock table table_name write; 写锁会阻塞其它用户对该表的‘读写’操作，直到写锁被释放：unlock tables； 1.锁的开销越大，粒度越小，并发度越高。 2.表级锁通常是在服务器层实现的。 3.行级锁是存储引擎层实现的。innodb的锁机制，服务器层是不知道的 2.5.4 阻塞和死锁（1）阻塞是由于资源不足引起的排队等待现象。 （2）死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两对象正持有的，导致两对象无法完成操作，且所持资源无法释放。 2.6 如何选择正确的存储引擎参考条件： 1.事务 2.备份(Innobd免费在线备份) 3.崩溃恢复 4.存储引擎的特有特性 总结:Innodb大法好。 注意:尽量别使用混合存储引擎，比如回滚会出问题在线热备问题。 2.7 配置参数2.7.1 内存配置相关参数确定可以使用的内存上限。 内存的使用上限不能超过物理内存，否则容易造成内存溢出；（对于32位操作系统，MySQL只能试用3G以下的内存。） 确定MySQL的每个连接单独使用的内存。 sort_buffer_size #定义了每个线程排序缓存区的大小，MySQL在有查询、需要做排序操作时才会为每个缓冲区分配内存（直接分配该参数的全部内存）；join_buffer_size #定义了每个线程所使用的连接缓冲区的大小，如果一个查询关联了多张表，MySQL会为每张表分配一个连接缓冲，导致一个查询产生了多个连接缓冲；read_buffer_size #定义了当对一张MyISAM进行全表扫描时所分配读缓冲池大小，MySQL有查询需要时会为其分配内存，其必须是4k的倍数；read_rnd_buffer_size #索引缓冲区大小，MySQL有查询需要时会为其分配内存，只会分配需要的大小。 注意：以上四个参数是为一个线程分配的，如果有100个连接，那么需要×100。 MySQL数据库实例： ①MySQL是单进程多线程（而oracle是多进程），也就是说MySQL实例在系统上表现就是一个服务进程，即进程； ②MySQL实例是线程和内存组成，实例才是真正用于操作数据库文件的； 一般情况下一个实例操作一个或多个数据库；集群情况下多个实例操作一个或多个数据库。 如何为缓存池分配内存： Innodb_buffer_pool_size，定义了Innodb所使用缓存池的大小，对其性能十分重要，必须足够大，但是过大时，使得Innodb 关闭时候需要更多时间把脏页从缓冲池中刷新到磁盘中； 总内存-（每个线程所需要的内存*连接数）-系统保留内存 key_buffer_size，定义了MyISAM所使用的缓存池的大小，由于数据是依赖存储操作系统缓存的，所以要为操作系统预留更大的内存空间； select sum(index_length) from information_schema.talbes where engine=’myisam’ 注意：即使开发使用的表全部是Innodb表，也要为MyISAM预留内存，因为MySQL系统使用的表仍然是MyISAM表。 max_connections 控制允许的最大连接数， 一般2000更大。 不要使用外键约束保证数据的完整性。 2.8 性能优化顺序从上到下： 数据库结构设计和SQL语句。 数据库存储引擎的选择和参数配置 系统选择及优化 硬件升级 来源：https://segmentfault.com/a/1190000013672421","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/tags/数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"【漫画】996对程序员的伤害，一看你就懂","slug":"【漫画】996对程序员的伤害，一看你就懂","date":"2019-04-26T05:41:34.000Z","updated":"2019-04-26T05:23:05.460Z","comments":true,"path":"2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/","link":"","permalink":"http://chenguoji.com/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/","excerpt":"","text":"我在一家互联网大厂上班，我很骄傲，有一天，上司递给我一张协议我知道公司的难处，想到自己还背着房贷，只能接受上司很赏识我，委派了重要项目给我不过因为家住的远，9点下班，加上1个半小时车程，回到家都接近晚上11点了以前下班，我会跟女朋友吃饭，玩一会游戏，然后才是睡觉现在直接睡觉以前星期六，我会和朋友爬山，或陪女友逛街现在周六没了，周日只想补觉1年过去，我少陪了女朋友264次晚饭（22*12）。 因为一起做的事情越来越少，我们之间好像慢慢少了一些默契。 朋友再没邀过我爬山了，因为每次我都回“加班中”。 PS4也早就挂闲鱼卖掉了，当然是女朋友卖的，我哪有时间。 我感觉自己像从没出过公司有一次做梦，我梦到自己变成哥斯拉，喷火把公司和老板烧了半夜梦醒，去完夜尿却赶紧打开电脑，看看老板有无回复邮件渐渐地，我胖了，看着自己2年前的照片，咦？原来我也瘦过有一天，我发现隔壁同事在哭，急忙安慰，问起原因，才知道他错过了母亲的葬礼。还好还好，我只是错过几次好友的婚礼。 我还年轻，身体壮的很，但奇怪的是最近小小感冒都会发烧，吃根辣条也能得肠胃炎。应该是天气原因，我安慰自己 我是父母逢人便夸的骄傲但这个骄傲，已经好几年没陪父母一起看电视了是不是，应该请个假回家看看父母？还是…等过了这段时间吧 女朋友想要小孩，说好可爱！小孩？我会有时间..照顾他么？还是… 女朋友说好久没去旅游了，我说等过了这段时间，她半天不说话，我回头一看，她在擦眼泪我们都是那种很乖的人，很少对人说不，很能忍，什么事都咬碎牙齿往肚子里吞，很少情绪外露，但今天.. 有人这样解释什么是生活，拿一台照相机，把每个开心的瞬间拍下来，贴到墙上，就组成了生活但最近这一年，好像没什么值得贴的应该是照相机也拿去闲鱼卖了 那么，我还在生活么，也许我只是活着这样的日子还要多久？可能用不了多久，也可能要一辈子我不想这样，我要找回我的生活照相机 … 996，想说爱你不容易！ 来源：挖数链接：https://mp.weixin.qq.com/s/50Z6wEs6lNUHCerLmV-vYQ","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"大公司的面试官是如何挑人的？","slug":"大公司的面试官是如何挑人的？","date":"2019-04-24T05:41:34.000Z","updated":"2019-04-24T09:05:15.713Z","comments":true,"path":"2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/","link":"","permalink":"http://chenguoji.com/2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/","excerpt":"","text":"又到一年一度的跳槽求职高峰季，很多人问我，你们公司还需要人么，你们用的技术栈是哪些，有哪些是你们比较关注技术重点？ 没错，作为负责技术面试的我，面对数十甚至上百封简历，肯定要做一轮筛选。究竟哪些技术点或方向在我筛选或面试时，留下深刻印象呢？ 我觉得优秀的，有潜质的程序员可以从下面几点体现。 1、性能调优几乎每个JAVA后端开发程序员，都会在面试时碰到诸如如何性能调优的问题，如何回答好这个问题，不仅仅是对JVM，内存模型等的理解，更重要的是碰到性能问题时，排查问题的方法论和思路。 典型的一个场景是：在压力测试时，发现FullGC频率很高，如何解决？ 此类问题一般从以下几点入手： 1. 观察GC日志，判断是否有内存泄漏，或者存在的内部不合理点。此处要求能熟悉各种linux命令，可以快速查看和定位。 2. 调整JVM 参数，如新生代，年老代大小，S0和S1大小比例，不同垃圾回收器的采用。并结合业务特点做进一步分析。这里不但要求扎实的JVM内存模型和理论，还要求对JVM的各种参数设置耳熟能详，并能实践操作。 3. Dump内存，做进一步的对象分析。 4. 压测脚本的编写，性能问题解决前可以发现问题，并能在问题解决后真实的验证。 此类优化不仅仅是照本宣科式的回答，面试官一定会喜欢问实际中操作的场景，和解决问题的思路。因为性能问题的原因是多种多样的，但是解决问题的思路和方法论是可以明确的。 2、网络框架的理解和使用大家一定都听过或使用过网络异步框架Netty，甚至使用netty框架开发过一些应用和功能。 但是大部分人仅限于对Netty的使用，甚至仅仅知道其他一些开源框架使用了Netty，但是在资深面试官眼里，Netty有很多值得学习和借鉴的地方，使用过Netty并且能对Netty的一些原理有一定的了解且能学以致用的Java程序员格外受欢迎。 一般来说，要求较高的面试官和技术经理喜欢从Netty的设计模式角度深入的考察技术人员对网络开发和相关理论的理解如： 1. Netty的Reactor模型如何设计，反应在应用里的模型是如何。 2. Netty的pipeline 责任链如何使用，业务场景中是否有类似的实践经验。 3. 项目中有无使用Netty，并利用Netty进行私有化协议设计。 同学们不仅要求能使用Netty，通过阅读其源码，理解其中的精髓，并能应用在自己的实践项目中，这个才是亮点和加分项。 3、开源服务化RPC框架的理解和使用互联网经过十几年的发展，早已经从单体应用发展为服务化应用，大厂里系统和服务尤其如此。 拿经典的dubbo 服务化框架举例，当前市面上有很多dubbo相关的文章和介绍，这里撇开不谈，从技术负责人的角度来，我会更关心下面有关几个dubbo相关的问题。 1. 技术选型：为什么选择dubbo，而不选择其他如spring cloud框架?我认为可以从如下考虑： A）业务的特点以及可预见的后续的发展。作为高级技术人员，必须需要对业务的的发展做预计和规划。 B）可用性要求，是否需要达到4个99（99.99%），需要支撑的峰值QPS，是否有业务的集中爆发点，如电商大促 C）团队的成熟度，一个成熟的团队可以很好的hold住复杂的开源框架，甚至做定制化开发。 D）技术选型这个话题虽然宽泛，但是最能体现更能体现技术人员的综合能力，尤其是结合业务特点后对技术深度和广度的驾驭能力。 2. Dubbo底层走的是什么协议，如何处理异步转同步？大部分的Java开发都会直接使用dubbo，而不会去关心其底层一些技术细节，但是一些细节，如dubbo如何对对象进行序列化，用了哪些序列化方式，这些在分布式项目中对提高应用的处理速度，减少网络开销，都很大帮助。 同时RPC框架里如何将异步转同步，也是需要技术人员非常关注的一面，里面相关的设计模式，多线程程高并发场景都是很多业务系统里真实需要和借鉴的。 3. Dubbo在高并发高可用等实践场景需要认真考虑的其他问题使用了dubbo后，很多人觉得万事大吉，其实并不是这样，下面几点还需要关心，并且这些就是体现你价值的地方 A) dubbo依赖了zooKeeper，但是万一ZooKeeper宕机了怎么办 B) 如果ZooKeeper假死，客户端对服务端的调用是否会全部下线，如果是该如何避免 C) 如何监控duubo的调用，并做到优雅的客户端无感发布 4、自身多年的面试体会1.项目中尽量多思考，迎难而上，如碰到复杂的性能，内存泄露等问题的问题，往往是提升自己的机会，千万要仔细研究解决，可以参考其他解决类似问题的文章和实践经验，对技术深度的提升是很大的，关键时候可以让你的面试官突然觉得面耳目一新。 2.重视解决问题的思路和方法，很多时候技术人员可以快速设计一个系统或解决一个问题，但是在资深工程师或面试官眼里可能并不是最优方案。如何解决？ 很多技术人员的项目和技术相对单一，长久以往，容易造成技术思路和视野的狭窄，接触不到行业最新思路和动态或者当前疑难问题的最佳解决方案。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"软件工程师生存指南：面试准备、工作经验和实用工具","slug":"软件工程师生存指南：面试准备、工作经验和实用工具","date":"2019-04-23T05:41:34.000Z","updated":"2019-04-23T06:03:15.618Z","comments":true,"path":"2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/","link":"","permalink":"http://chenguoji.com/2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/","excerpt":"","text":"编者按：软件工程师是令人羡慕的职业。但是如何才能拿到这份工作？又如何才能做好这份工作呢？拥有相关经验的 Valeri Alexiev 提供了相关建议和工具。其中包括了如何准备面试、如何以软件工程师的身份工作以及如何持续改进方面的经验之谈。 我刚开始工作的头几年是紧张学习的时间。 我得面对现实，成为软件工程师需要有很多技能，这些我之前都不知道。回顾过去，显然学会那些东西是很好的。 所以我就根据自己及其他人的经验写了这篇指南来帮助入行的新人。 本文将覆盖以下内容： 如何尽力做好面试 如何在软件工程师的角色中生存（及发展） 考虑持续改进时可以参考的资源 面试当你开始软件工程职业生涯时，你得面对一个无可争议的事实。面试很恶心。 参与其中的每个人都觉得很恶心。既被人面试过又面试过别人的我可以证明，面试是一项极其耗时、极其有压力的工作，并且面试其实并不是将来工作表现一个的好的指示器。但不管怎样，这都是一个必要之恶，你和你的简历最好还是做好准备为妥。 做好战斗准备如果你考虑做软件过程，确保了解一些最常见的编程面试问题，比如“FizzBuzz”： 写一个程序打印从 1 到 100 的数字。但是如果数字是 3 的倍数的话则打印“Fizz”，如果数字是 5 的倍数则打印“Buzz”。如果同时是 3 和 5 的倍数则打印“FizzBuzz”。 来自 Coding Horror 听起来很简单，是吧？ 好吧，但其实绝大部分面试者都没能通过这一简单的测试，且不说更复杂的变种了。 我个人曾经见过很多角逐资深岗位的候选人在拥有完全互联网访问的情况下没能通过这一测试。所以如果你的简历上面列有编程语言的话，确保你知道如何用它来编写实现 FizzBuzz 程序。否则的话，你只不过是在浪费所有人的时间，包括你自己的。 当然，为了在面试过后生存，你需要知道的不仅仅只有 FizzBuzz。你还需要确保你知道： 基础的数据结构和算法：比如链表、数组、树以及排序。要知道所选择语言的常见解决办法，比如字符串是否恒定，内存是如何管理的。类似类与对象，以及继承等面向对象编程的概念。在职业生涯开始时，你需要就这些问题做好准备，因为你并没有经历去证明自己能做好这份工作。在准备面试的时候有两个资源我会经常推荐： 《Cracking the Coding Interview（破解面试代码）》，这是一本非常好的书，里面介绍了很多的编码问题和解决方案，同时还总结了解决这些问题需要了解的东西。 CodeWars ，这个网站收集了大量的编程问题，你可以运用各种语言在浏览器里面去解决这些问题。最有用的部分是看看别的用户是如何解决同样问题的。这样你就可以看到解决相同问题的不同办法，并且学到你所选语言的新工具。 赋予自身额外优势为了让自己取得那点额外优势，有几件事情你可以去做。 首先，学会如何沟通你的经验。你应该进行一次电梯演讲来将你的简历总结成连贯的、打动人的个人介绍。 此外，要了解自己的简历！听起来很蠢是吧，但我就见过很多面试者连解释清楚自己简历上的特定事项都很困难。你应该能够回答任何有关你列上简历的经历方面的问题，并且解释清楚这一经历如何让你成为本工作更好的候选人。 接着，要在 GitHub（或者其他的公共代码库）上面有一些编码的例子。 眼见为实，面试官能够看到你的代码将创造奇迹。此外，这还证明了你对版本控制系统有了解。 你的代码例子不需要太复杂，但是一定要整洁，能够显示出好的编码实践。这是你展示自己在没有编码面试所带来的时间压力情况下代码写得如何的机会。 一旦你做完了上面的事情后，就得考虑参与一个开源项目了。参加开源项目能表明你能够在已有代码库基础上工作并且可以与其他程序员一些协作。 这是你在无需实际进入一个行业环境的情况下最接近在行业环境下编程的方式了。这也是目前为止最难最耗时的一项任务，所以等到你把前面我提到的比较容易取得的果实都摘完之后再干这件事。 面试你的面试官在找工作的匆忙与压力之下，很多候选人都忘了面试是一个双向的过程。在公司努力寻找这份工作的合适人选时，你也应该设法弄清楚这家公司适不适合你。 确保你也要提出以下一些问题，哪怕对方是以电子邮件的形式回复你。要意识到公司经常把不遵循最佳实践说成是一项技能，所以要体会其言外之意。 以下是一些你可以去提问的例子： “对我来说典型的工作日会是什么样的？”知道特定岗位预期的样子很重要，因为软件工程工作差别相当大。比方说你的工作既可能是维护服务器，也可能是直接跟客户沟通。 危险信号：“我不大肯定。” → 意味着面试你的那个人不在你的团队，或者他们对为什么要招你并没有明确的想法。 “你们是如何测试软件的？”理想情况下，验证代码质量应该是单元测试、人工测试以及自动化测试的结合。 危险信号：“我们都写不出 bug，哈哈。” → 那些人正是会写出 bug 的人。 “你们使用什么样的版本控制系统？”版本控制系统对于协作极其有用，在职业环境下没有理由不使用。 危险信号 #1：“额，版本控制系统？” → 快跑，跑得越远越好。 永远记得使用版本控制。 危险信号 #2：“&lt;插入不知名的或者定制的 VCS&gt;” → 这表明他们很有可能没有跟上时代并且很久没有升级自己的基础设施了。 “你们进行同行评审吗？”同行评审，或者让别人看看你的代码再把它放进代码库，这是识别愚蠢错误的极好办法，同时也是开始你的职业生涯时一个关键的培训机会。 危险信号：“我们相互信任！”→很有可能那些资深开发者对自己的代码非常警惕不想给人看也不擅长接受反馈。 “你们的继续教育计划是什么样的？”作为一名软件工程师意味着当新技术出现、成熟并以令人眼花缭乱的速度走向过时的时候要不断学习。因此，很多公司都有培训预算用来买大学和在线课程、会议或者内部交流。 危险信号：“你是说在闲暇时间读读网上的东西？” →这家公司要么资金紧张，要么把开发者视为可替代的，而不是长期投资。 “你们采用的软件开发流程是什么？”无论实际的细节是什么，流程对于软件工程都至关重要。至于哪些东西对于优化流程做出了贡献可能大家会有不同的看法，但仅就项目的工作方式达成一致就能将混乱最小化并且确保每个人都能达成共识。 危险信号：“我们的流程受到了自由风格的爵士的影响。” → 很有可能整个部门都处在救火模式，总是不断地从紧急跳到另一个紧急状态而缺乏任何明确的目标。 “你们是如何处理技术债务的？”技术债务是过时技术以及代码库中临时应急的解决方案的累积。处理好技术债务对于代码的长期健康很重要，这件事情应该持续地做。 危险信号：“我们只关注新功能。” → 他们的代码库一团糟或者很快就会一团糟。 “你们的公司文化是什么样的？”公司文化也许是个非常含糊的概念，但即便像开放办公室还是小隔间这样的小事情都会显著改变你与同事的日常互动。这方面没有普遍性的危险信号，但是要确保他们的答案是你可以按照每周 40+ 小时的节奏持续相处数年的东西。 以软件工程师的身份工作在这个阶段，如果你面试过程中表现不错并且喜欢面试官回答你问题的方式，你被录用的可能性就很高了。 祝贺，你正式成为一名工程师了！ 那现在又该如何呢？好吧，现在是时候重新学习大量编码和工作方面的东西了。既然我们是程序员，我们就从讨论代码开始。 好的行业代码好的行业代码有以下属性，依序是： 1.可读性，因为代码用来读和维护的频次要高于写。代码的意图必须清晰，让其他开发者在多年后依然理解。 2.防御性，就是要遵循防御性编码的最佳实践。防御性编码本身就是一个课题，不过其要义是：你必须确保自己所写的类和方法的不恰当使用不会导致你的代码搞得软件都崩溃。 3.优化，位列清单的最后未知，因为大多数时候你并不需要真正去担心这个。这并不意味着你应该编写糟糕代码，在存在线性解决方案的情况下以O(n³)的效率去做某个东西。但开发者通常渴望尝试并且会在不需要的情况下过度优化，却牺牲了代码的可读性和防御性。你永远都应该能够证明牺牲了这些属性的特定优化是值得的。 现在你了解了如何去编写良好的行业代码了。 编码的工作你不会干太多的说出来也许有点令人吃惊，但是大多数时候你都不用写新代码，而是相反，要做： 调试 读已有代码 开会或者写电子邮件 研究该怎么做以便不用写代码 因此编码以外的技能对你的职业一样关键。 调试和阅读代码调试远不仅仅是用打印语句。一切使用广泛的语言和技术栈都有各种强大的工具。学会使用它们，因为这些会让调试轻而易举，节省你无数的时间。 理解代码库。大多数技术栈都有某种代码图谱生成工具来帮助你理解代码库的结构。企业级的 IDE 通常都内置了那种功能。你还可以利用 ReSharper、grep 或者 Sourcegraph 之类的工具来探索代码。 理解产品。你会对居然有这么多开发者在试图“修复”软件前不知道软件应该是怎么工作的感到惊讶。先看看文档再说吧。 组织你的思路既然你的大量时间都是用在沟通、研究和多任务上，你需要一些工具来帮助一切井然有序。 TODO 清单/任务工具：你的公司应该已经有了某种任务管理软件了，但你自己也有类似的个人系统是有帮助的。使用便利贴或者像 Trello 或者 Todoist 之类的软件。 笔记：开会一定要记笔记，要致力于改进现有文档并且建立个人的知识库。使用 Evernote、OneNote 或者笔记本。使用这些工具似乎有用力过度之嫌，但日后在回顾这一耗掉了你 3 天时间才想清楚的晦涩的开发过程时你会感谢自己的。不做丰富笔记的好的软件开发者我一个都没见过。 图表/可视化：人是视觉动物，创建流程图和架构可帮助你和其他人理解复杂的话题。在跟非技术人员沟通时图解尤其有用。可使用 Lucidchart、 Visio 或者白板。 知道何时使用库简短回答：随时都要。 详细回答：99% 的时间内你都不应该重新发明轮子。在大多数的软件工程岗位，实现特定类型的东西都属于纯粹浪费时间。这并不意味着你不应该知道所使用的算法和数据结构是怎么工作的，因为这可以帮助你决定用什么以及什么时候用。 为了成为一名高效的软件工程师，你需要理解自己可以任意支配使用的那些库。大多数流行语言的标准库都是极其有用的，其规模比你想象的要大。此外，代码库也许也会利用了额外的特殊库。阅读其文档，知道什么使用去使用它们。 你还应该不要害怕去建议额外的库，如果它们将节省时间的话。然而，你需要确保自己选择了一个好的库供行业使用。好的库的标准是： 开源，这样你就可以验证自身代码的质量，并有可能修补对应用非常关键的 bug。 按照 MIT 和 BSD 等方式进行的授权，这样你的公司使用起来就不会遇到任何问题。要小心 GPL，因为它会让你不小心就将整个代码库都开源出去。 成熟，比方说出来已经有一段时间了，并且功能集非常丰富。 维护性强，新版本推出很密集。 别的公司或者项目也使用，这个可以充当品质认证确保有行业支持，能持续维护下去。 持续改进为了替自己创建新的职业机会，除了学习会让你更擅长日常工作的技能以外，你还需要持续改进自身技能并且学习新技能。 其实学习的机会有很多，而且其中很多都是你可以负担得起的： 在线课程：向领域内最好的教授学习的机会，而且方式灵活，不容错过。现有技能的补充性教程可以去可以看看 Coursera、 Udacity 以及 edX 等。 在线硕士学位：在线硕士学位是最近在顶级大学流行起来的一个趋势，这种方式可以灵活地继续你的正规教育。相比之下，这种继续教育方式费用没那么昂贵，修完整个学位大多数在 1 万美元左右。乔治亚理工大学、UT 以及加州大学圣地亚哥分校等大学均提供此类学位。我个人推荐乔治亚理工大学的在线硕士虚伪，我去年刚从这里毕业。 博客：博客是开发者社区的重要组成部分。诸如 Coding Horror、Joel on Software 等博客或者甚至更加诙谐的网站如 The Daily WTF 等都可以为你提供信息，了解到作为软件工程师该干什么不该干什么。浏览 Medium、r/programming, HackerNews 等新闻流也能让你找到好博客和好文章。 会议：最后但并非最不重要的一个，会议时令人赞叹的学习机会，你绝对应该利用公司的培训预算去参加会议。以下是不完全的好会议清单：GOTO（通用）， Strange Loop（通用）， PyCon （Pytho），CPPCon （C++），DEF CON （安全），Fluent （Web 开发）。上述所有的会议在 YouTube 上都有视频，所以你哪怕不出席也能学到东西！ 希望这篇文章能够用相关知识把你武装起来，让你了解到作为软件工程师的职业生涯伊始应该期待什么，并且提供合适的工具给你在开启这段令人兴奋的旅程中助你一臂之力！ 英文：Valeri Alexiev 译文：36kr36kr.com/p/5160742.html","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Tomcat相关面试题","slug":"Tomcat相关面试题","date":"2019-04-22T05:41:34.000Z","updated":"2019-04-22T08:34:44.922Z","comments":true,"path":"2019/04/22/tomcat-xiang-guan-mian-shi-ti/","link":"","permalink":"http://chenguoji.com/2019/04/22/tomcat-xiang-guan-mian-shi-ti/","excerpt":"","text":"Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，这次整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以再往Tomcat处理请求的这个过程去说的！掌握注Tomcat这些技能了，面试官一定会佩服你的！ 学了本节之后你应该明白的是： Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点； Tomcat执行的整体架构，请求是如何被一步步处理的； Engine、Host、Context、Wrapper相关的概念关系； Container是如何处理请求的； Tomcat用到的相关设计模式； 一、Tomcat顶层架构俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！ 先上一张Tomcat的顶层结构图（图A），如下： Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。 Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下： 1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; 2、Container用于封装和管理Servlet，以及具体处理Request请求； 一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）： 多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。 另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0） 详细的配置文件文件内容可以到Tomcat官网查看： http://tomcat.apache.org/tomcat-8.0-doc/index.html 上边的配置文件，还可以通过下边的一张结构图更清楚的理解： Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。 二、Tomcat顶层架构小结：（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；（2） Server掌管着整个Tomcat的生死大权；（4）Service 是对外提供服务的；（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；（6）Container用于封装和管理Servlet，以及具体处理request请求； 知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。 三、Connector和Container的微妙关系由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！ Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！ Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！ 四、Connector架构分析Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。 因此，我们可以把Connector分为四个方面进行理解： （1）Connector如何接受请求的？ （2）如何将请求封装成Request和Response的？ （3）封装完之后的Request和Response如何交给Container进行处理的？ （4）Container处理完之后如何交给Connector并返回给客户端的？ 首先看一下Connector的结构图（图B），如下所示： Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。 其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。 （1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。 （2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。 （3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。 至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？ 五、Container架构分析Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）： 4个子容器的作用分别是： （1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine； （2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点； （3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件； （4）Wrapper：每一Wrapper封装着一个Servlet； 下面找一个Tomcat的文件目录对照一下，如下图所示： Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。 我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。 看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！ 六、Container如何处理请求的Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意） Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。 https://img-blog.csdn.net/20180108212100441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点： （1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的； （2）在上层容器的管道的BaseValve中会调用下层容器的管道。 我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。 Pipeline的处理流程图如下（图D）： （1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）； （2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。 （3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！ （4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。 七、总结至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！ 原文：https://blog.csdn.net/u010870518/article/details/79006434","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://chenguoji.com/tags/Tomcat/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"数据库-操作符记录","slug":"SQL UNION 操作符","date":"2019-04-19T05:41:34.000Z","updated":"2019-04-22T08:26:33.569Z","comments":true,"path":"2019/04/19/sql-union-cao-zuo-fu/","link":"","permalink":"http://chenguoji.com/2019/04/19/sql-union-cao-zuo-fu/","excerpt":"","text":"SQL UNION 操作符UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。SQL UNION ALL 语法SELECT column_name(s) FROM table_name1UNION ALLSELECT column_name(s) FROM table_name2 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SQL JOIN 操作符下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。 JOIN: 如果表中有至少一个匹配，则返回行LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行FULL JOIN: 只要其中一个表中存在匹配，就返回行 注释：INNER JOIN 与 JOIN 是相同的。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://chenguoji.com/categories/数据库/"}]},{"title":"教你如何搞定面试官？","slug":"教你如何搞定面试官？","date":"2019-04-18T06:14:59.000Z","updated":"2019-05-06T06:56:39.656Z","comments":true,"path":"2019/04/18/jiao-ni-ru-he-gao-ding-mian-shi-guan/","link":"","permalink":"http://chenguoji.com/2019/04/18/jiao-ni-ru-he-gao-ding-mian-shi-guan/","excerpt":"","text":"“请做个自我介绍。”有的人，可以口若悬河、妙语连珠讲3分钟，有的人，可能磕磕巴巴，讲了30秒，前者一定能胜过后者，然则未必， 今天就来聊一聊，面试的经典问题——自我介绍。 为什么要做自我介绍通常说来，大大小小的面试，尤其是针对基础岗位，都会被问到这个问题，甚至有些面试技术还有些生硬的面试官， 屁股还没坐稳，就把这个问题抛给应聘人员了，那么作为求职者，要首先明白，面试官为什么要让你做自我介绍？ 简单说来，包括以下几个原因： 1、面试官的技巧还不是很娴熟，使用面试的惯常流程； 2、通过自我介绍，判断求职者的基本素质（比如口头语言表达能力、逻辑能力等）； 3、通过自我介绍，找到简历上缺失的或者不一致的细节，后续追问； 4、通过自我介绍，建立对应聘者的立体、整体的初步印象和概念。 简言之，自我介绍的意义和价值就在于，通过简短的口头语言陈述，让面试官初步了解你是一个什么样的面试候选人。 如何做好自我介绍1、先说核心内容：前面已经介绍了这一问题的考察点，那么接下来就对症下药，做一个高质量的自我介绍，给整场面试开一个好头。自我介绍过程就是人岗匹配度的核查与确认，这样描述有点抽象，举个例子来说： 应聘职位：招聘助理 应聘人员：有一定HR初级经验 假设自我介绍-1：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，招聘任务重的时候，也协助做一些招聘工作，比如面试的约谈，面试过程的记录以及相关数据的汇总等等”； 假设自我介绍-2：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，没怎么做过招聘，招聘任务重的时候，会给招聘小组的同事们帮帮忙……” 对比上面的两个自我介绍，也就不难看出质量的优劣，在做介绍的过程中，首要原则，多介绍以往工作经验中跟当前应聘岗位有交集的地方，而且尽可能描述到细节，切勿顾左右而言他。 有的人可能会说了，我正在寻求转行，没有相关经验怎么办？ 只要记住以下几点： 如果这家公司在看过你简历的情况下依然通知你面试，那么也就代表以往的工作经验并非是该岗位的必要要素。 此处还要多说一句，如果你是打算转行，收到心仪的职位时，先不要过于激动，而是要在面试电话中先冷静地跟通知你的人确认一下你要面试的职位，不排除当下有些公司会挂着羊头卖狗肉，打着文职的旗号招销售，专门诱骗小姑娘们，所以此类公司，要更加慎重，可以用该公司的名称到网络上去搜索一下他们家的招聘信息，如果铺天盖地都是销售岗位的招聘，那么，可能就只是个幌子而已了。其实非专业技术型的岗位，尤其是偏基础性质的职位，企业不会特别看重以往经验的对口与否，衡量工作的胜任能力，一方面是技能，一方面是态度， 技能培养如果可以在企业内部培训的基础上快速实现，往往更加看重你的个人态度层面，所以不必过分纠结经验问题。再举个例子来说： 应聘职位：销售支持 应聘人员：有一定的话务客服经验 自我介绍：“……在之前的工作中，我从事的是话务客服的工作，虽然跟贵公司招聘的销售支持职务有差别，但我详细阅读了贵公司的岗位介绍，销售支持的工作需要良好的服务意识，细心的工作态度以及对产品知识的了解，从事过客服工作，我的服务意识以及细心程度都没有问题，专业知识相信经过公司的培训之后，自己也能熟练掌握……” 也就是说，如果你是转行，应聘不需要专业的技能和知识的岗位，尽可能寻找以往工作中的软性能力与当前应聘职位之间的关系，多表现自己良好的职业素质层面的东西即可。 2、再说说辅助内容：上述内容针对的是自我介绍的核心内容，但自我介绍的内容不仅仅是这些，还需要有一些其他的内容作为辅助，才显得更加自然和饱满，简言之，一篇完成的自我介绍要涵盖以下内容： 自我基本情况； 以往工作经验与应聘岗位链接； 个人的职业发展设想； 对应聘企业的个人认同感； 至于个人的兴趣爱好之类的，可以简单带过即可。 上述的五个简单部分，2、3、4为主，前后两部分为辅助，再加上一些简单的寒暄的话语即可。 3、还有几个误区，需要大家绕开：自我介绍不是检查背诵能力，切勿千篇一律。有的人准备一套说辞，背的滚瓜烂熟，见谁都是这一套，这样是不稳妥的，要把自己的情况跟企业的职位做链接，这样方才更加吸引面试官； 做自我介绍的时候卡壳了，怎么办？不要紧张的手足无措，可以坦然地笑笑，跟面试官说，不好意思，我有点紧张，然后继续就好了； 做自我介绍的时候，两眼直勾勾看桌子或者天花板，没有跟面试官的眼神接触。如果有好几个面试官，不要盯着一个人，都扫几眼； 做自我介绍的时候，不要做小动作，落落大方，不要抖腿，掰手指头等等； 注意跟简历内容相一致，不要出现信息不对称。简单粗暴的给个模板 不给模板的干货都是伪干货，上面七七八八说了这么多，给个范本仅供参考： “面试官您好，非常荣幸参与贵公司**职位的应聘，下面我简单介绍一下我的个人情况，基本信息之类的简历上都有，就不再重复。 首先介绍一下之前的工作经验……（挑一些跟应聘岗位有链接的内容说，如果有工作荣誉，前往不要漏掉）…… 之所以离开上一家公司是出于……考虑（离职理由要争当，尽可能从职业发展的角度出发）…… 通过渠道关注到贵公司岗位的招聘信息，该职位跟我未来的职业发展相对契合，而且贵公司的业务（或者企业实力、行业口碑、企业文化等）对我都非常有吸引力，非常渴望能够进入贵公司发展…… 我个人的基本情况是（受教育情况、婚育、住所、家庭简单情况），闲暇之余，我一般会做些**事情（有意义的）…… 或许在所有的求职者当中，我不是最优秀的，但如果贵公司能够给我这个工作机会，我有信心，也有决心做好这份工作，以上是我的个人基本情况，希望今天自己面试有好的表现，未来有幸与诸位面试官共事，也预祝各位度过美好的一天。” 最后再做个总结：自我介绍是整个面试的开始，首因效应之下，第一印象还是很重要滴，在做介绍的过程中， 尽可能多去说有些跟岗位工作有关的过往经验，不要生搬硬套，注意灵活应对， 可以事先有针对性做一个草稿，但针对框架内容要了熟于心，针对企业岗位有的放矢，落落大方，注意条理。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java面试","slug":"java面试","permalink":"http://chenguoji.com/tags/java面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Java开发者必须要具备的专业技能","slug":"Java开发者必须要具备的专业技能","date":"2019-04-17T08:09:23.000Z","updated":"2019-04-17T08:30:04.539Z","comments":true,"path":"2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/","link":"","permalink":"http://chenguoji.com/2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/","excerpt":"","text":"想要成为合格的Java程序员或工程师到底需要具备哪些专业技能，面试者在面试之前到底需要准备哪些东西呢？ 本文陈列的这些内容既可以作为个人简历中的内容，也可以作为面试的时候跟面试官聊的东西，你可以把这些内容写到你的简历中，当然更需要的是你在面试的时候向面试官展示这些专业技能。 相信此文对正在寻觅Java程序员（Java工程师）职位的freshman以及希望成为中高级Java开发者的junior都会有所帮助。 专业技能 1.熟练的使用Java语言进行面向对象程序设计，有良好的编程习惯，熟悉常用的Java API，包括集合框架、多线程（并发编程）、I/O（NIO）、Socket、JDBC、XML、反射等。 2.熟悉基于JSP和Servlet的Java Web开发，对Servlet和JSP的工作原理和生命周期有深入了解，熟练的使用JSTL和EL编写无脚本动态页面，有使用监听器、过滤器等Web组件以及MVC架构模式进行Java Web项目开发的经验。 3.对Spring的IoC容器和AOP原理有深入了解，熟练的运用Spring框架管理各种Web组件及其依赖关系，熟练的使用Spring进行事务、日志、安全性等的管理，有使用Spring MVC作为表示层技术以及使用Spring提供的持久化支持进行Web项目开发的经验，熟悉Spring对其他框架的整合。 4.熟练的使用Hibernate、MyBatis等ORM框架，熟悉Hibernate和MyBatis的核心API，对Hibernate的关联映射、继承映射、组件映射、缓存机制、事务管理以及性能调优等有深入的理解。 5.熟练的使用HTML、CSS和JavaScript进行Web前端开发，熟悉jQuery和Bootstrap，对Ajax技术在Web项目中的应用有深入理解，有使用前端MVC框架（AngularJS）和JavaScript模板引擎（HandleBars）进行项目开发的经验。 6.熟悉常用的关系型数据库产品（MySQL、Oracle），熟练的使用SQL和PL/SQL进行数据库编程。 7.熟悉面向对象的设计原则，对GoF设计模式和企业应用架构模式有深入的了解和实际开发的相关经验，熟练的使用UML进行面向对象的分析和设计，有TDD（测试驱动开发）和DDD（领域驱动设计）的经验。 8.熟悉Apache、NginX、Tomcat、WildFly、Weblogic等Web服务器和应用服务器的使用，熟悉多种服务器整合、集群和负载均衡的配置。 9熟练的使用产品原型工具Axure，熟练的使用设计建模工具PowerDesigner和Enterprise Architect，熟练的使用Java开发环境Eclipse和IntelliJ，熟练的使用前端开发环境WebStorm，熟练的使用软件版本控制工具SVN和Git，熟练的使用项目构建和管理工具Maven和Gradle。 说明：上面罗列的这些东西并不是每一项你都要烂熟于心，根据企业招聘的具体要求可以做相应的有针对性的准备。 我个人觉得前6项应该是最低要求，是作为一个Java开发者必须要具备的专业技能。","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"基于springboot开发的java web网页版电子商城网站","slug":"基于springboot开发的java web网页版电子商城网站","date":"2019-04-16T08:01:31.000Z","updated":"2019-04-16T11:26:54.674Z","comments":true,"path":"2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/","link":"","permalink":"http://chenguoji.com/2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/","excerpt":"","text":"项目描述 基于spring boot与mybatis整合的java web网页版电子商城网站，采用maven构建，数据库用的是mysql 运行环境 jdk8+tomcat7+mysql+eclipse+maven 项目技术(必填) 后台使用：springboot+mybatis 前台使用：html+css+jquery+freemarker+layui+ 运行安装包文件 百度网盘：https://pan.baidu.com/s/1ZHGSul-JysWJ0xh7zeDzIg 密码: a354 项目截图(必填) 运行截图(必填) 1、登录页面 2、项目首页 3、商品详情 4、后台管理模块 5、商品管理模块 注意事项 系统是由maven构建的，必须要把所有jar包下载才能成功运行 如需项目代码请联系博主或者加Q群","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/tags/毕业设计/"}],"keywords":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://chenguoji.com/categories/毕业设计/"}]},{"title":"Java中的锁[原理、锁优化、CAS、AQS]","slug":"Java中的锁-原理、锁优化、CAS、AQS","date":"2019-04-10T01:38:52.000Z","updated":"2019-04-10T07:22:13.208Z","comments":true,"path":"2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/","link":"","permalink":"http://chenguoji.com/2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/","excerpt":"","text":"1、为什么要用锁？锁-是为了解决并发操作引起的脏读、数据不一致的问题。 2、锁实现的基本原理2.1、volatileJava编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 Java语言提供了volatile，在某些情况下比锁要更加方便。 volatile在多处理器开发中保证了共享变量的“ 可见性”。 可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。 2.2、synchronizedsynchronized通过锁机制实现同步。 先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 2.2.1 synchronized实现原理synchronized是基于Monitor来实现同步的。 Monitor从两个方面来支持线程之间的同步： 互斥执行 协作 1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。3、Class和Object都关联了一个Monitor。 Monitor 的工作机理 .线程进入同步方法中。.为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）.拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。.其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。.同步方法执行完毕了，线程退出临界区，并释放监视锁。 参考文档：https://www.ibm.com/developerworks/cn/java/j-lo-synchronized 2.2.2 synchronized具体实现1、同步代码块采用monitorenter、monitorexit指令显式的实现。 2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。 通过实例来看看具体实现： public class SynchronizedTest { public synchronized void method1(){ System.out.println(&quot;Hello World!&quot;); } public void method2(){ synchronized (this){ System.out.println(&quot;Hello World!&quot;); } } } javap编译后的字节码如下： monitorenter 每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下： .如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。 .如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。 .如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。 monitorexit 只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1， 当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。 2.2.3 锁存放的位置锁标记存放在Java对象头的Mark Word中。Java对象头长度32位JVM Mark Word 结构32位JVM Mark Word 状态变化64位JVM Mark Word 结构 2.2.4 synchronized的锁优化JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 偏向锁： 无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。 轻量级锁： 轻量级锁所适应的场景是线程交替执行同步块的情况。 锁粗化（Lock Coarsening）： 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除（Lock Elimination）： 锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。 适应性自旋（Adaptive Spinning）： 自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 2.2.5 锁的优缺点对比 2.3、CASCAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。 1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。 2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。优点： 竞争不大的时候系统开销小。 缺点： 循环时间长开销大。 ABA问题。 只能保证一个共享变量的原子操作。 3、Java中的锁实现3.1、队列同步器（AQS）队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。 3.1.1、它使用了一个int成员变量表示同步状态。 3.1.2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。 未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示： 首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示： 3.1.3、独占式/共享式锁获取独占式：有且只有一个线程能获取到锁，如：ReentrantLock。&lt;/pre&gt; 共享式：可以多个线程同时获取到锁，如：CountDownLatch 独占式 每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。 独占式锁获取流程： 共享式： 共享式与独占式的区别： 共享锁获取流程： 4、锁的使用用例4.1、ConcurrentHashMap的实现原理及使用 ConcurrentHashMap类图 ConcurrentHashMap数据结构 结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 来源：https://www.jianshu.com/p/e674ee68fd3f","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"高级程序员VS普通程序员，差距到底在哪？","slug":"高级程序员VS普通程序员，差距到底在哪？","date":"2019-04-03T09:02:45.000Z","updated":"2019-04-03T09:07:23.040Z","comments":true,"path":"2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/","link":"","permalink":"http://chenguoji.com/2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/","excerpt":"","text":"踏上了编程之路，也就意味着你选择了一种终身学习的生活方式。每一个程序员都要练就十八般武艺，而掌握数据结构与算法就像修炼了九阳神功。换句话说，掌握了数据结构与算法，你的内功修炼速度就会有质的飞跃。 “初级程序员才比招式，高级程序员只看内功”，数据结构与算法，对于一个程序员来说，至关重要。 无论你是从事业务开发，想要评估代码性能和资源消耗，还是从事架构设计，想要优化设计模式；或者想要快速玩转热门技术，都要先搞定数据结构与算法。因为，任凭新技术如何变化，只要掌握了这些计算机科学的核心“招式”，你就可以见招拆招，始终立于“不败之地”。 那怎样才能真正掌握它呢？是把常用的数据结构与算法背的滚瓜烂熟吗？即便如此，面对现实世界的千变万化，你也不太可能照搬某个算法解决即将遇到的下一个问题。因此，就像学习设计模式、架构模式一样，学习数据结构与算法的关键，在于掌握其中的思想和精髓，学会解决实际问题的方法。 来源：https://mp.weixin.qq.com/s/vL5gEfOfqE3airySe1FlBQ","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"11个简单的Java性能调优技巧","slug":"11个简单的Java性能调优技巧","date":"2019-03-28T02:35:17.000Z","updated":"2019-04-17T08:21:01.975Z","comments":true,"path":"2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/","link":"","permalink":"http://chenguoji.com/2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/","excerpt":"","text":"大多数开发人员理所当然地以为性能优化很复杂，需要大量的经验和知识。好吧，不能说这是完全错误的。优化应用程序以获得最佳性能不是一件容易的事情。但是，这并不意味着如果你不具备这些知识，就不能做任何事情。 这里有11个易于遵循的建议和最佳实践可以帮助你创建一个性能良好的应用程序。 大部分建议是针对Java的。但也有若干建议是与语言无关的，可以应用于所有应用程序和编程语言。在讨论专门针对Java的性能调优技巧之前，让我们先来看看通用技巧。 1.在你知道必要之前不要优化这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。 在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。 那么，你如何证明你需要优化一些东西呢？ 首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。 2.使用分析器查找真正的瓶颈在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？ 你可以用两种方法来解决问题： 查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。 或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。 希望不需要我解释为什么应该始终遵循第二种方法的原因。 很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。老实说，我第一次的猜测不止一次地导致我走错了方向。 3.为整个应用程序创建性能测试套件这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。 这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。 4.首先处理最大的瓶颈在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。Java 程序员必须清楚的 7 个性能指标，这个你也必须会。 速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。 但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。 5.使用StringBuilder以编程方式连接String有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。String 真的是不可变的吗？ 那么，你应该选择哪种方法？ 答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。StringBuffer 和 StringBuilder 的 3 个区别，这个你必须清楚。 你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。 下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。 StringBuilder sb = new StringBuilder(“This is a test”); for (int i=0; i&lt;10; i++) { sb.append(i); sb.append(” “); } log.info(sb.toString()); 正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。 如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。这进一步提高了效率，因为它不需要动态扩展其容量。 6.使用+连接一个语句中的String当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。 在这些情况下，你应该遵循技巧5并使用StringBuilder。 但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。 Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ” + “FROM Author a ” + “WHERE a.id = :id”); 在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。 7.尽可能使用基元避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。 8.试着避免BigInteger和BigDecimal既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。 BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。金融系统中正确的金额计算及存储方式，这个你了解下。 9.首先检查当前日志级别 这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。 这里有两个反面例子。 // don’t do this log.debug(“User [” + userName + “] called method X with [” + i + “]”); // or this log.debug(String.format(“User [%s] called method X with [%d]”, userName, i)); 在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。因此在创建调试消息之前，最好先检查当前的日志级别。 // do this if (log.isDebugEnabled()) { log.debug(“User [” + userName + “] called method X with [” + i + “]”); } 10.使用Apache Commons StringUtils.Replace而不是String.replace一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。 有一个备选答案是Apache Commons Lang的StringUtils.replace方法。正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。 而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。 // replace this test.replace(“test”, “simple test”); // with this StringUtils.replace(test, “test”, “simple test”); 11.缓存昂贵的资源，如数据库连接缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。 一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。 你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。 但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。 所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们。 总结正如你所看到的，有时不需要太多工作就可以提高应用程序的性能。本文中的大部分建议只需要你稍作努力就可以将它们应用于你的代码。 但是，最重要的还是那些与是什么编程语言无关的技巧： 在你知道必要之前不要优化 使用分析器查找真正的瓶颈 首先处理最大的瓶颈 来源：原文：11 Simple Java Performance Tuning Tips译文：http://www.codeceo.com/article/11-simple-java-performance-tips.html","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"面试不懂「微服务架构」原理？不怕被pass了？","slug":"面试不懂「微服务架构」原理？不怕被pass了？","date":"2019-03-26T05:49:37.000Z","updated":"2019-04-17T08:20:51.280Z","comments":true,"path":"2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/","link":"","permalink":"http://chenguoji.com/2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/","excerpt":"","text":"近几年，微服务架构迅速在整个技术社区窜红，被认为是 IT 软件架构的未来方向。 一线互联网公司由于具有大量的业务体量和业务场景，比如阿里、百度、网易，很早就开始入坑微服务架构。 但说起微服务，不少人还是有这样的困惑：“作为一个开发，微服务架构是不是和我关系不大？那不都是架构师的事吗？” 关于这个问题，我来谈谈自己的看法。 微服务是当下最火热的后端架构之一。不管你是一个什么级别的程序员，也不论你在一个什么体量的公司， 服务化都是你迟早会遇到的难题。实践微服务的过程本身也是一个升级打怪的过程，这中间你会遇到基本上所有后端架构的问题。解决了这些问题，你自然也就理解了那些高深的概念，也就成为了一名架构师，成长和能力提升都是这个过程的附属品。 并且，你了解微服务架构之后，能知道领导为什么让你这么做，也更容易站在系统角度思考公司技术的进程，这对于你的大局观构建来说非常有帮助。 再者，微服务这技术在面试的时候总有人提，尤其对于头部互联网企业，微服务架构更是面试考核必备，所以“进大厂必须掌握的50个微服务面试问题”等一些文章备受欢迎。 如何设计高可用高并发的微服务架构 1.微服务架构如何拆分 2.微服务架构应用场合 3.微服务架构与Docker容器化 4.微服务架构如何达到99.999%的高可用 5.微服务架构性能怎么满足千亿次请求调用 6.微服务架构开源框架对比（Spring boot,Spring Cloud,Dubbo等） 来源：https://mp.weixin.qq.com/s/jqR6CxeJidvT9IrRplU98Q","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://chenguoji.com/tags/微服务/"},{"name":"原理","slug":"原理","permalink":"http://chenguoji.com/tags/原理/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"面试官必问的8道volatile关键字命题，你答对了吗？","slug":"面试官必问的8道volatile关键字命题，你答对了吗？","date":"2019-03-25T07:27:28.000Z","updated":"2019-04-26T03:21:04.425Z","comments":true,"path":"2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/","link":"","permalink":"http://chenguoji.com/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/","excerpt":"","text":"在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底， 把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。 下面我们以一次面试过程，来深入了解下volitile关键字吧！ 一、面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序。 二、面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？这个聊起来可就多了，我还是从Java内存模型说起吧。 Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。 简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。 在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存， 方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。 这么说得我自己都有些不清楚了，拿张纸画一下： 在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子： i = i + 1; 假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况： 线程1： load i from 主存 // i = 0 i + 1 // i = 1 线程2： load i from主存 // 因为线程1还没将i的值写回主存，所以i还是0 i + 1 //i = 1 线程1: save i to 主存 线程2： save i to 主存 如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。 下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的， 通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。 三、面试官：那你具体说说这三个特性呢？1 . 原子性(Atomicity)：Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如： i = 2; j = i; i++; i = i + 1； 上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 2 . 可见性(Visibility)：说到可见性，Java就是利用volatile来提供可见性的。 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。 其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。 3 . 有序性（Ordering）JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段： double pi = 3.14; //A double r = 1; //B double s= pi * r * r;//C 上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码: int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。 这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下happens-before规则： 1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作 2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁 3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读 4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C 5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作 6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生 8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始 第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。 第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。 第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。 第4条规则，就是happens-before的传递性。 后面几条就不再一一赘述了。 四、面试官：volatile关键字如何满足并发编程的三大特性的？那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。 这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。 继续拿上面的一段代码举例： int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。 如果改成下面这样： int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则： 1.程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行) 2.volatile规则：2 happens-before 3 3.传递性规则：1 happens-before 4 从内存语义上来看 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子： public class Test { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); } 按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。 假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。 线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。 此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。 有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。 又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。 综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。 六、面试官：说的还可以，那你知道volatile底层的实现机制？如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能： 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 2 . 使得本CPU的Cache写入内存 3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 七、面试官： 你在哪里会使用到volatile，举两个例子呢？1. 状态量标记，就如上面对flag的标记，我重新提一下：int a = 0; volatile bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 2. 单例模式的实现，典型的双重检查锁定（DCL）class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。 八、面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没~ 来源：juejin.im/post/5a2b53b7f265da432a7b821c","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://chenguoji.com/tags/并发/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]},{"title":"Redis的各项功能解决了哪些问题？","slug":"Redis的各项功能解决了哪些问题？","date":"2019-03-25T07:21:51.000Z","updated":"2019-04-10T01:35:04.244Z","comments":true,"path":"2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/","link":"","permalink":"http://chenguoji.com/2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/","excerpt":"","text":"Redis介绍官方简介解释到：Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。 同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。 它还内建了复制，lua脚本，LRU，事务等功能，通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。 综上所述，Redis提供了丰富的功能，初次见到可能会感觉眼花缭乱，这些功能都是干嘛用的？都解决了什么问题？什么情况下才会用到相应的功能？那么下面从零开始，一步一步的演进来粗略的解释下。 1、从零开始最初的需求非常简单，我们有一个提供热点新闻列表的api：http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。 随后我们就着手于如何提升一下api消费者感知的性能，很快最简单粗暴的第一个方案就出来了：为API的响应加上基于HTTP的缓存控制 cache-control:max-age=600 ，即让消费者可以缓存这个响应十分钟。 如果api消费者如果有效的利用了响应中的缓存控制信息，则可以有效的改善其感知的性能（10分钟以内）。但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。 2、基于本机内存的缓存为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。 后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。 其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆满了。。。 3、服务端的Redis在API服务器的内存都被缓存塞满的时候，我们发现不得不另想解决方案了。最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，把它的内存配置的大大的。然后我们就盯上了redis。。。 至于如何配置部署redis这里不解释了，redis官方有详细的介绍。随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。 3.1 持久化（Persistence）单台的Redis服务器一个月总有那么几天心情不好，心情不好就罢工了，导致所有的缓存都丢失了（redis的数据是存储在内存的嘛）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。 所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。 3.2 哨兵（Sentinel）和复制（Replication）Redis服务器毫无征兆的罢工是个麻烦事。那么怎办办？答曰：备份一台，你挂了它上。那么如何得知某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。 Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。 3.3 集群（Cluster）单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。 所以我们就需要一种解决方案，可以让我们横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：基于网络应用的架构）。 在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，也就是说redis本身并不关心分布式的事情，而是交由twemproxy和codis来负责。 而redis官方给出的cluster方案则是把分布式的这部分事情做到了每一个redis服务器中，使其不再需要其他的组件就可以独立的完成分布式的要求。我们这里不关心这些方案的优略，我们关注一下这里的分布式到底是要处理那些事情?也就是twemproxy和codis独立处理的处理分布式的这部分逻辑和cluster集成到redis服务的这部分逻辑到底在解决什么问题？ 如我们前面所说的，一个分布式的服务在外界看来就像是一个集中式的服务一样。那么要做到这一点就面临着有一个问题需要解决：既是增加或减少分布式服务中的服务器的数量，对消费这个服务的客户端而言应该是无感的；那么也就意味着客户端不能穿透分布式服务，把自己绑死到某一个台的服务器上去，因为一旦如此，你就再也无法新增服务器，也无法进行故障替换。 解决这个问题有两个路子： 第一个路子最直接，那就是我加一个中间层来隔离这种具体的依赖，即twemproxy采用的方式，让所有的客户端只能通过它来消费redsi服务，通过它来隔离这种依赖（但是你会发现twermproxy会成为一个单点），这种情况下每台redis服务器都是独立的，它们之间彼此不知对方的存在； 第二个路子是让redis服务器知道彼此的存在，通过重定向的机制来引导客户端来完成自己所需要的操作，比如客户端链接到了某一个redis服务器，说我要执行这个操作，redis服务器发现自己无法完成这个操作，那么就把能完成这个操作的服务器的信息给到客户端，让客户端去请求另外的一个服务器，这时候你就会发现每一个redis服务器都需要保持一份完整的分布式服务器信息的一份资料，不然它怎么知道让客户端去找其他的哪个服务器来执行客户端想要的操作呢。 上面这一大段解释了这么多，不知有没有发现不管是第一个路子还是第二个路子，都有一个共同的东西存在，那就是分布式服务中所有服务器以及其能提供的服务的信息。这些信息无论如何也是要存在的，区别在于第一个路子是把这部分信息单独来管理，用这些信息来协调后端的多个独立的redis服务器；第二个路子则是让每一个redis服务器都持有这份信息，彼此知道对方的存在，来达成和第一个路子一样的目的，优点是不再需要一个额外的组件来处理这部分事情。 Redis Cluster的具体实现细节则是采用了Hash槽的概念，即预先分配出来16384个槽：在客户端通过对Key进行CRC16（key）% 16384运算得到对应的槽是哪一个；在redis服务端则是每个服务器负责一部分槽，当有新的服务器加入或者移除的时候，再来迁移这些槽以及其对应的数据，同时每个服务器都持有完整的槽和其对应的服务器的信息，这就使得服务器端可以进行对客户端的请求进行重定向处理。 4、客户端的Redis上面的第三小节主要介绍的是Redis服务端的演进步骤，解释了Redis如何从一个单机的服务，进化为一个高可用的、去中心化的、分布式的存储系统。这一小节则是关注下客户端可以消费的redis服务。 4.1 数据类型redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持： string：最基本的数据类型，二进制安全的字符串，最大512M。 list：按照添加顺序保持顺序的字符串列表。 set：无序的字符串集合，不存在重复的元素。 sorted set：已排序的字符串集合。 hash：key-value对的一种集合。 bitmap：更细化的一种操作，以bit为单位。 hyperloglog：基于概率的数据结构。 这些众多的数据类型，主要是为了支持各种场景的需要，当然每种类型都有不同的时间复杂度。其实这些复杂的数据结构相当于之前我在《解读REST》这个系列博客基于网络应用的架构风格中介绍到的远程数据访问（Remote Data Access = RDA）的具体实现，即通过在服务器上执行一组标准的操作命令，在服务端之间得到想要的缩小后的结果集，从而简化客户端的使用，也可以提高网络性能。比如如果没有list这种数据结构，你就只能把list存成一个string，客户端拿到完整的list，操作后再完整的提交给redis，会产生很大的浪费。 4.2 事务上述数据类型中，每一个数据类型都有独立的命令来进行操作，很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。 4.3 Lua脚本在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于基于网络应用的架构风格中介绍到的远程求值（Remote Evluation = REV）的具体实现。 4.4 管道因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。管道和事务的差异在于管道是为了节省通信的开销，但是并不会保证原子性。 4.5 分布式锁官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下： SET resource_name my_random_value NX PX 30000 if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1]) else return 0 end 总结本篇着重从抽象层面来解释下redis的各项功能以及其存在的目的，而没有关心其具体的细节是什么。从而可以聚焦于其解决的问题，依据抽象层面的概念可以使得我们在特定的场景下选择更合适的方案，而非局限于其技术细节。 来源：作者：blackheartwww.cnblogs.com/linianhui","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://chenguoji.com/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"谈谈final、finally、finalize有什么不同？","slug":"谈谈final、finally、finalize有什么不同？","date":"2019-03-23T02:56:10.000Z","updated":"2019-03-25T07:23:05.941Z","comments":true,"path":"2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/","link":"","permalink":"http://chenguoji.com/2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/","excerpt":"","text":"初级程序猿面试一般会问的问题。 可以按照以下回答： 1. final 可以用来修饰类、方法、变量。分别有不同的意义： final 修饰的 class 代表不可以继承扩展 final 的变量是不可以修改的 final 的方法也是不可以重写的（override） 2. finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 3.finalize 是基础类 java.lang.Object 的一个方法。它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 注意事项：1，不要在 finally 中使用 return 语句。2，finally 总是执行，除非程序或者线程被中断。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"请对比Exception和Error有什么区别？","slug":"请对比Exception和Error有什么区别？","date":"2019-03-23T02:43:42.000Z","updated":"2019-04-17T08:20:45.398Z","comments":true,"path":"2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/","link":"","permalink":"http://chenguoji.com/2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/","excerpt":"","text":"面试一般是这样问：运行时异常与一般异常有什么区别？ 简单点来讲就是：运行时异常可以不处理，一般异常必须处理。 运行时异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 一般异常，JAVA编译器强制要求用户必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。 不同点： 1.从继承来讲，Exception 和 Error都继承自Throwable类。 2.Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。 Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"Java转型大数据开发技能","slug":"Java转型大数据开发技能","date":"2019-03-21T02:39:50.000Z","updated":"2019-04-17T08:11:39.976Z","comments":true,"path":"2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/","link":"","permalink":"http://chenguoji.com/2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/","excerpt":"","text":"很多做程序猿都知道，对于技术方面，擅长大家一直提倡的是精一门，再横向发展，多学一点总不是坏事。 什么意思呢？ 就是我们当前工作用到的那一门技术一定要学好、学精、学深，然后可以拓展其他相关的技术栈。 如此多的技术，怎么学得过来呢？ 我觉得以你自己的岗位为主，其他为辅，关于自己工作相关的技术，花更多的时间和精力，研究得更深入，其他领域的可以了解和关注，等到需要用到或者感兴趣的时候，在深入学习即可。 那作为 Java 开发，除了 Java 还可以学什么？ 大数据可能是一个不错的方向。 一、转型大数据需要哪些技能？ 技术层面来说，如果你初步掌握Java编程，转型大数据都是非常轻松的具有天然的优势。 Java编程是大数据开发的基础，Java编程是必备技能； 大数据使用的Hadoop(在分布式服务器集群上存储海量数据并运行分布式分析应用的一种方法)需要Java基础， 所以有很多搞Java的都在往这hadoop大数据方向转。","categories":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://chenguoji.com/tags/大数据/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://chenguoji.com/categories/技术/"}]},{"title":"关于","slug":"about","date":"2019-03-21T02:39:50.000Z","updated":"2019-03-22T02:18:37.994Z","comments":true,"path":"2019/03/21/about/","link":"","permalink":"http://chenguoji.com/2019/03/21/about/","excerpt":"","text":"关于博主博主是一名Java码农。 虽然还未走上人生巅峰，但是一直保持着一个码农的自我修养。 用一句话概括博主：每天瞎逼忙，还没赚到钱。 但是博主有一颗分享技术的心，我会尽量用通俗易懂的方式，分享个人的知识。 博客的宗旨就是分享知识，分享技术，不一定高深，但一定是博主用心写作而成的。 所有人都是从0开始起步，在学习过程中，会遇到各种困难，这个时候如果可以借鉴别人的经验，会让我们省力不少，希望我的博客也能帮助到你。","categories":[{"name":"关于","slug":"关于","permalink":"http://chenguoji.com/categories/关于/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://chenguoji.com/tags/博客说明/"}],"keywords":[{"name":"关于","slug":"关于","permalink":"http://chenguoji.com/categories/关于/"}]},{"title":"Java面试中最高频的那20%知识点！","slug":"Java面试","date":"2019-03-21T02:39:50.000Z","updated":"2019-04-17T08:21:11.942Z","comments":true,"path":"2019/03/21/java-mian-shi/","link":"","permalink":"http://chenguoji.com/2019/03/21/java-mian-shi/","excerpt":"","text":"Java目前已经不仅仅是一门开发语言，而是一整套生态体系。 作为一个Java程序员，既是幸运的，也是不幸的。幸运的是我们有很多轮子可以拿过来用，不幸的是我们有太多的轮子需要学习。 但是，无论是日常工作还是面试问题，也都符合二八原则。即掌握20%的知识，就能解决80%的问题。 那么，Java程序员必须掌握的20%知识点都有哪些呢？ 个人认为包括以下内容： Java基础知识，如集合类、IO、泛型等。 JVM底层知识，如类加载机制、GC、JVM内存结构等。 Java并发编程知识，如Java内存模型、并发包、线程池、netty等。 开发框架知识，如Spring、mybatis、springboot、springMVC等。 分布式相关知识，如CAP理论、分布式锁、分布式事务、Zookeeper、spring Cloud等。 其他基础知识，编程语言、网络方面、数据库、数据结构和算法。 中间件相关知识，如Redis、rabbitMQ、Dubbo等。 服务器相关知识，如tomcat、jetty、jboss等。 以上这些知识，就是最高频的面试问题，以及工作中需要用到的知识。当然，一个程序员想要掌握以上所有知识，可能需要花费很长时间。这个过程注定是漫长且孤独的。 来源：https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw","categories":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}],"tags":[{"name":"java","slug":"java","permalink":"http://chenguoji.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"http://chenguoji.com/categories/面试/"}]}]}