<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Boot + MyBatis + Maven论坛内容管理系统源码</title>
      <link href="/2019/05/08/spring-boot-mybatis-maven-lun-tan-nei-rong-guan-li-xi-tong-yuan-ma/"/>
      <url>/2019/05/08/spring-boot-mybatis-maven-lun-tan-nei-rong-guan-li-xi-tong-yuan-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="毕设描述"><a href="#毕设描述" class="headerlink" title="毕设描述"></a>毕设描述</h1><p>xxxForum是一个基于Spring Boot + MyBatis + Maven开发的一个论坛内容管理系统，主要实现了的功能有：</p><pre><code>前台页面展示数据、广告展示内容模块：发帖、评论、帖子分类、分页、回帖统计、访问统计、表单验证用户模块：权限、资料、头像、邮箱验证管理：后台管理、统计图表、帖子/分类管理</code></pre><p>#开发环境（运行环境）</p><p>windows 7 , jdk 1.8</p><p>#项目采用技术</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>Spring Boot 1.5.5<br>Spring Security 4<br>Mybatis(mybatis-spring-boot-starter 1.3.1)<br>Maven 3.X</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>Thymeleaf<br>Bootstrap<br>jQuery<br>Chart.js<br>bootstrap-select<br>daterangepicker</p><h1 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h1><p>在项目文件里面</p><h1 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h1><p><img src="http://www.devcheng.net/images/shouye1.png"><br><img src="http://www.devcheng.net/images/tiezidetail2.png"><br><img src="http://www.devcheng.net/images/login3.png"><br><img src="http://www.devcheng.net/images/zhuce4.png"><br><img src="http://www.devcheng.net/images/table5.png"><br><img src="http://www.devcheng.net/images/user6.png"><br><img src="http://www.devcheng.net/images/fenlei9.png"><br><img src="http://www.devcheng.net/images/run1.png"></p><h1 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a>登录地址</h1><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>登录用户名和密码</p><p>admin / admin</p><h1 id="是否免费"><a href="#是否免费" class="headerlink" title="是否免费"></a>是否免费</h1><p>收费<br>写码不易，付费后给代码并且提供对应的技术服务支持。</p><h1 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h1><p>QQ 搜索我们的群号：814637551</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.头像如何配置？<br>在电脑选一个盘，新建一个文件夹 例如：在C盘新建一个avatar文件夹，里面存放你的头像图片。<br>找到 application.properties 配置文件</p><pre><code># ==============================# avator location# ==============================resource.staticResourceLocation=C:/avatar/</code></pre><p>写好配置，找到 StaticResourceConfig 类</p><pre><code>@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) {   //这里也要和之前的对应起来   registry.addResourceHandler(&quot;/avatar/**&quot;).addResourceLocations(&quot;file:C:/avatar/&quot;);}</code></pre><p>数据库里面和这对应就可以了！    </p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库怎么分库分表，垂直？水平？</title>
      <link href="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/"/>
      <url>/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据库瓶颈"><a href="#一、数据库瓶颈" class="headerlink" title="一、数据库瓶颈"></a>一、数据库瓶颈</h1><p>不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。<br>在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。</p><h2 id="1、IO瓶颈"><a href="#1、IO瓶颈" class="headerlink" title="1、IO瓶颈"></a>1、IO瓶颈</h2><p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。</p><p>第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</p><h2 id="2、CPU瓶颈"><a href="#2、CPU瓶颈" class="headerlink" title="2、CPU瓶颈"></a>2、CPU瓶颈</h2><p>第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。</p><p>第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，增加CPU运算的操作 -&gt; 水平分表。</p><h1 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h1><h2 id="1、水平分库"><a href="#1、水平分库" class="headerlink" title="1、水平分库"></a>1、水平分库</h2><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/水平分库.png"><p>1、概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p><p>2、结果：</p><pre><code>每个库的结构都一样；每个库的数据都不一样，没有交集；所有库的并集是全量数据；</code></pre><p>3、场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</p><p>4、分析：库多了，io和cpu的压力自然可以成倍缓解。</p><h2 id="2、水平分表"><a href="#2、水平分表" class="headerlink" title="2、水平分表"></a>2、水平分表</h2><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/水平分表.png"><p>1、概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</p><p>2、结果：</p><pre><code>每个表的结构都一样；每个表的数据都不一样，没有交集；所有表的并集是全量数据；</code></pre><p>3、场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</p><p>4、分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</p><h2 id="3、垂直分库"><a href="#3、垂直分库" class="headerlink" title="3、垂直分库"></a>3、垂直分库</h2><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/垂直分库.png"><p>1、概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</p><p>2、结果：</p><pre><code>每个库的结构都不一样；每个库的数据也不一样，没有交集；所有库的并集是全量数据；</code></pre><p>3、场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</p><p>4、分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。<br>再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</p><h2 id="4、垂直分表"><a href="#4、垂直分表" class="headerlink" title="4、垂直分表"></a>4、垂直分表</h2><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/垂直分表.png"><p>1、概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</p><p>2、结果：</p><pre><code>2.1、每个表的结构都不一样；2.2、每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；2.3、所有表的并集是全量数据；</code></pre><p>3、场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</p><p>4、分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。<br>这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。</p><p>但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</p><h1 id="三、分库分表工具"><a href="#三、分库分表工具" class="headerlink" title="三、分库分表工具"></a>三、分库分表工具</h1><p>1、sharding-sphere：jar，前身是sharding-jdbc；<br>2、TDDL：jar，Taobao Distribute Data Layer；<br>3、Mycat：中间件。</p><p>注：工具的利弊，请自行调研，官网和社区优先。</p><h1 id="四、分库分表步骤"><a href="#四、分库分表步骤" class="headerlink" title="四、分库分表步骤"></a>四、分库分表步骤</h1><p>根据容量（当前容量和增长量）评估分库或分表个数 -&gt; 选key（均匀）-&gt; 分表规则（hash或range等）-&gt; 执行（一般双写）-&gt; 扩容问题（尽量减少数据的移动）。</p><h1 id="五、分库分表问题"><a href="#五、分库分表问题" class="headerlink" title="五、分库分表问题"></a>五、分库分表问题</h1><h2 id="1、非partition-key的查询问题（水平分库分表，拆分策略为常用的hash法）"><a href="#1、非partition-key的查询问题（水平分库分表，拆分策略为常用的hash法）" class="headerlink" title="1、非partition key的查询问题（水平分库分表，拆分策略为常用的hash法）"></a>1、非partition key的查询问题（水平分库分表，拆分策略为常用的hash法）</h2><p>1、端上除了partition key只有一个非partition key作为条件查询</p><p>映射法  </p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/映射法1.png"><p>基因法 </p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/基因法1.png"><p>注：写入时，基因法生成userid，如图。关于xbit基因，例如要分8张表，23=8，故x取3，即3bit基因。根据userid查询时可直接取模路由到对应的分库或分表。<br>根据username查询时，先通过usernamecode生成函数生成username_code再对其取模路由到对应的分库或分表。id生成常用snowflake算法。</p><p>2、端上除了partition key不止一个非partition key作为条件查询</p><p>映射法 </p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/映射法2.png"><p>冗余法 </p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/冗余法2.png"><p>注：按照orderid或buyerid查询时路由到dbobuyer库中，按照sellerid查询时路由到dbo_seller库中。感觉有点本末倒置！有其他好的办法吗？改变技术栈呢？</p><p>3、后台除了partition key还有各种非partition key组合条件查询</p><p>NoSQL法<br><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/NoSQL法3.png"></p><p>冗余法<br><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/冗余法3.png"></p><h2 id="2、非partition-key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）"><a href="#2、非partition-key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）" class="headerlink" title="2、非partition key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）"></a>2、非partition key跨库跨表分页查询问题（水平分库分表，拆分策略为常用的hash法）</h2><p>注：用NoSQL法解决（ES等）。</p><h2 id="3、扩容问题（水平分库分表，拆分策略为常用的hash法）"><a href="#3、扩容问题（水平分库分表，拆分策略为常用的hash法）" class="headerlink" title="3、扩容问题（水平分库分表，拆分策略为常用的hash法）"></a>3、扩容问题（水平分库分表，拆分策略为常用的hash法）</h2><p>1、水平扩容库（升级从库法）</p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/水平扩容库.png"><p>注：扩容是成倍的。</p><p>2、水平扩容表（双写迁移法）</p><img src="/2019/05/08/shu-ju-ku-zen-me-fen-ku-fen-biao-chui-zhi-shui-ping/水平扩容表.png"><p>第一步：（同步双写）应用配置双写，部署；</p><p>第二步：（同步双写）将老库中的老数据复制到新库中；</p><p>第三步：（同步双写）以老库为准校对新库中的老数据；第四步：（同步双写）应用去掉双写，部署；</p><p>注：双写是通用方案。</p><h1 id="六、分库分表总结"><a href="#六、分库分表总结" class="headerlink" title="六、分库分表总结"></a>六、分库分表总结</h1><p>1、分库分表，首先得知道瓶颈在哪里，然后才能合理地拆分（分库还是分表？水平还是垂直？分几个？）。且不可为了分库分表而拆分。</p><p>2、选key很重要，既要考虑到拆分均匀，也要考虑到非partition key的查询。</p><p>3、只要能满足需求，拆分规则越简单越好。</p><p>作者：尜尜人物<br><a href="https://www.cnblogs.com/littlecharacter/" target="_blank" rel="noopener">https://www.cnblogs.com/littlecharacter/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC方法四种类型返回值总结，你用过几种？</title>
      <link href="/2019/05/07/springmvc-fang-fa-si-chong-lei-xing-fan-hui-zhi-zong-jie-ni-yong-guo-ji-chong/"/>
      <url>/2019/05/07/springmvc-fang-fa-si-chong-lei-xing-fan-hui-zhi-zong-jie-ni-yong-guo-ji-chong/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC 现在算是 Java 领域的一个基础性框架了，很多人天天用，可是对于 SpringMVC 方法的返回值，你又是否完全清楚呢？<br>今天我就来和大家聊一聊 SpringMVC 中四种不同类型的返回值，看看有没有 get 到你的知识盲点？</p><h1 id="1-ModelAndView"><a href="#1-ModelAndView" class="headerlink" title="1. ModelAndView"></a>1. ModelAndView</h1><p>以前前后端不分的情况下，ModelAndView 应该是最最常见的返回值类型了，现在前后端分离后，后端都是以返回 JSON 数据为主了。后端返回 ModelAndView 这个比较容易理解，<br>开发者可以在 ModelAndView 对象中指定视图名称，然后也可以绑定数据，像下面这样：</p><pre><code>@RequestMapping(&quot;/test1&quot;)public ModelAndView getAllTest1(){    ModelAndView mv = new ModelAndView();    List&lt;Book&gt; books = new ArrayList&lt;&gt;();    Book b1 = new Book();    b1.setId(1);    b1.setName(&quot;三国演义&quot;);    b1.setAuthor(&quot;罗贯中&quot;);    books.add(b1);    Book b2 = new Book();    b2.setId(2);    b2.setName(&quot;红楼梦&quot;);    b2.setAuthor(&quot;曹雪芹&quot;);    books.add(b2);    // 指定数据模型    mv.addObject(&quot;bs&quot;, books);    mv.setViewName(&quot;book&quot;);    // 指定视图名    return mv;}</code></pre><p>返回 ModelAndView ，最常见的两个操作就是指定数据模型+指定视图名 。</p><h1 id="2-Void"><a href="#2-Void" class="headerlink" title="2. Void"></a>2. Void</h1><p>返回值为 void 时，可能是你真的没有值要返回，也可能是你有其他办法，我将之归为如下四类，大伙来看下。</p><h2 id="2-1-没有值"><a href="#2-1-没有值" class="headerlink" title="2.1 没有值"></a>2.1 没有值</h2><p>如果确实没有返回值，那就返回 void ，但是一定要注意，此时，方法上需要添加 @ResponseBody 注解，像下面这样：</p><pre><code>@RequestMapping(&quot;/test2&quot;)@ResponseBodypublic void test2() {    // 你的代码}</code></pre><h2 id="2-2-重定向"><a href="#2-2-重定向" class="headerlink" title="2.2 重定向"></a>2.2 重定向</h2><p>由于 SpringMVC 中的方法默认都具备 HttpServletResponse 参数，因此可以重拾 Servlet/Jsp 中的技能，可以实现重定向，像下面这样手动设置响应头：</p><pre><code>@RequestMapping(&quot;/test3&quot;)@ResponseBodypublic void test3(HttpServletResponse resp) {    resp.setStatus(302);    resp.addHeader(&quot;Location&quot;, &quot;/html/index&quot;);}</code></pre><p>也可以像下面这样直接调用重定向的方法：</p><pre><code>@RequestMapping(&quot;/test3&quot;)@ResponseBodypublic void test3(HttpServletResponse resp) {    resp.sendRedirect(&quot;/html/index&quot;);}</code></pre><p>当然，重定向无论你怎么写，都是 Servlet/Jsp 中的知识点，上面两种写法都相当于是重回远古时代。</p><h2 id="2-3-服务端跳转"><a href="#2-3-服务端跳转" class="headerlink" title="2.3 服务端跳转"></a>2.3 服务端跳转</h2><p>既然可以重定向，当然也可以服务端跳转，像下面这样：</p><pre><code>@GetMapping(&quot;/test4&quot;)public void test4(HttpServletRequest req, HttpServletResponse resp){    req.getRequestDispatcher(&quot;/WEB-INF/jsp/index.jsp&quot;).forward(req, resp);}</code></pre><h2 id="2-4-返回字符串"><a href="#2-4-返回字符串" class="headerlink" title="2.4 返回字符串"></a>2.4 返回字符串</h2><p>当然也可以利用 HttpServletResponse 返回其他字符串数据，包括但不局限于 JSON，像下面这样：</p><pre><code>@RequestMapping(&quot;/test5&quot;)@ResponseBodypublic void test5(HttpServletResponse resp) throws IOException{    resp.setContentType(&quot;application/json;charset=utf-8&quot;);    PrintWriter out = resp.getWriter();    List&lt;Book&gt; books = new ArrayList&lt;&gt;();    Book b1 = new Book();    b1.setId(1);    b1.setName(&quot;三国演义&quot;);    b1.setAuthor(&quot;罗贯中&quot;);    books.add(b1);    Book b2 = new Book();    b2.setId(2);    b2.setName(&quot;红楼梦&quot;);    b2.setAuthor(&quot;曹雪芹&quot;);    books.add(b2);    String s = new Gson().toJson(books);    out.write(s);    out.flush();    out.close();}</code></pre><p>这是返回值为 void 时候的情况，方法返回值为 void ，不一定就真的不返回了，可能还有其他的方式给前端数据。</p><h1 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h1><p>当 SpringMVC 方法的返回值为 String 类型时，也有几种不同情况。</p><h2 id="3-1-逻辑视图名"><a href="#3-1-逻辑视图名" class="headerlink" title="3.1 逻辑视图名"></a>3.1 逻辑视图名</h2><p>返回String 最常见的是逻辑视图名， 这种时候一般利用默认的参数 Model 来传递数据，像下面这样：</p><pre><code>@RequestMapping(&quot;/hello&quot;)public String aaa(Model model){    model.addAttribute(&quot;username&quot;, &quot;张三&quot;);    return &quot;hello&quot;;}</code></pre><p>此时返回的 hello 就是逻辑视图名， 需要携带的数据放在 model 中。    </p><h2 id="3-2-重定向"><a href="#3-2-重定向" class="headerlink" title="3.2 重定向"></a>3.2 重定向</h2><p>也可以重定向，事实上， 如果在 SpringMVC 中有重定向的需求，一般采用这种方式：</p><pre><code>@RequestMapping(&quot;/test6&quot;)public String test6(){    return &quot;redirect:/html/index&quot;;}</code></pre><h2 id="3-3-forward-转发"><a href="#3-3-forward-转发" class="headerlink" title="3.3 forward 转发"></a>3.3 forward 转发</h2><p>也可以 forward 转发，事实上，如果在 SpringMVC 中有 forward 转发的需求，一般采用这种方式：</p><pre><code>@RequestMapping(&quot;/test7&quot;)public String test7(){    return &quot;forward:/WEB-INF/jsp/order.jsp&quot;;}</code></pre><h2 id="3-4-真的是-String"><a href="#3-4-真的是-String" class="headerlink" title="3.4 真的是 String"></a>3.4 真的是 String</h2><p>当然，也有一种情况，就是你真的想返回一个 String ，此时，只要在方法上加上 @ResponseBody 注解即可，或者 Controller 上本身添加的是组合注解 @RestController，像下面这样：</p><pre><code>@RestControllerpublic class HelloController {    @GetMapping(&quot;/hello&quot;)    public String hello() {        return &quot;hello provider!&quot;;    }}</code></pre><p>也可以像下面这样：</p><pre><code>@Controllerpublic class HelloController{    @GetMapping(&quot;/hello&quot;)    @ResponseBody    public String hello()    {        return &quot;hello provider!&quot;;    }}</code></pre><p>这是返回值为 String 的几种情况。</p><h1 id="4-JSON"><a href="#4-JSON" class="headerlink" title="4.JSON"></a>4.JSON</h1><p>返回 JSON 算是最最常见的了，现在前后端分离的趋势下，大部分后端只需要返回 JSON 即可，那么常见的 List 集合、Map，实体类等都可以返回，这些数据由 HttpMessageConverter 自动转为 JSON ，<br>如果大家用了 Jackson 或者  Gson ，不需要额外配置就可以自动返回 JSON 了，因为框架帮我们提供了对应的 HttpMessageConverter ，如果大家使用了 Alibaba 的 Fastjson 的话，<br>则需要自己手动提供一个相应的 HttpMessageConverter 的实例，方法的返回值像下面这样：</p><pre><code>@GetMapping(&quot;/user&quot;)@ResponseBodypublic User getUser() {    User user = new User();    List&lt;String&gt; favorites = new ArrayList&lt;&gt;();    favorites.add(&quot;足球&quot;);    favorites.add(&quot;篮球&quot;);    user.setFavorites(favorites);    user.setUsername(&quot;chenguoji&quot;);    user.setPassword(&quot;123&quot;);    return user;}@GetMapping(&quot;/users&quot;)@ResponseBodypublic List&lt;User&gt; getALlUser() {    List&lt;User&gt; users = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 100; i++) {        User e = new User();        e.setUsername(&quot;username:&quot; + i);        e.setPassword(&quot;pwd:&quot; + i);        users.add(e);    }    return users;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，这是我为大伙总结的 SpringMVC 方法四种不同类型的返回值，难倒是不难！有问题欢迎大伙留言讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宁南山：说下996</title>
      <link href="/2019/05/07/ning-nan-shan-shuo-xia-996/"/>
      <url>/2019/05/07/ning-nan-shan-shuo-xia-996/</url>
      
        <content type="html"><![CDATA[<p>作者：宁南山</p><p>一个国家，少数优秀人士和少数头部企业拼命干活就可以了，</p><p>一个是因为这个世界的经济竞争还是很残酷，中国要在不同行业赶超欧美，如果连精英人物和龙头企业都下午五点就下班，赶超不知道什么时候才能完成，甚至说永远不能完成。</p><p>你技术不如人，管理不如人，资本不如人，也不比其他国家的精英聪明，你还不愿比别人多干活，怎么赶超呢？</p><p>欧美的精英是非常拼的，不止一个国外公司的高管告诉我，他一天只睡四小时，五小时，有的是早上五点就起床。</p><p>另外一个是优秀分子一般都高度自律，同时具备很高的个人野心，对工作很有热情，也很热爱自己从事的事业，你眼中996是负担，其实他们中很多人可能会觉得比较快乐，996对他们并不一定是负担。</p><p>说句不好听的话，如果一个国家，连精英分子和精英企业，追求的都是懒散闲适的生活，不能适应高强度的工作，没有奋发向上的野心，这个国家肯定没希望。</p><p>事实上这样的国家在地球上一大把，非洲，中东，拉美，东南亚，你可以找出很多。</p><p>但是对于大部分人和大部分企业，996没有必要，40小时工作制，顶多偶尔有适量加班就可以了。</p><p>原因不复杂，</p><p>一个是和精英分子和顶尖企业相比，</p><p>普通人和普通企业的996是极为低效的，会极大的降低全社会的投入产出比。</p><p>精英企业的效率远远高于普通企业，</p><p>华为18万人一拼命工作，就可以在多个领域（通信网络，智能手机，企业IT）收割全世界的利润；</p><p>腾讯四万多人拼命工作，就可以成为全球最大的游戏公司，收割全球最多的游戏收入。</p><p>阿里八万多人拼命工作，就可以成为全球最大的电商公司，全球最大的云计算公司之一。</p><p>大疆几千人拼命工作，就可以成为全球最大的消费无人机公司，获取全球同行业70%以上的收入。</p><p>我在之前的文章里面写过，一个行业存在马太效应，最终三四家甚至两三家大公司获取行业大部分的收入和利润，但是这几家大公司雇佣的员工人数可以说远远低于其收入利润在同行业的占比，这也是阿里，腾讯，华为，VIVO, OPPO,大疆等同行业的大公司的员工收入非常高的原因。而对于广大的非头部企业来说，不管是收入份额还是利润份额，还是员工收入都远远不如了，搞996效率非常低，产生的边际效益很少，也没有必要。</p><p>对精英人物也是一样，他们本身能力出众，工作认真，同时对工作抱有热情，因此工作效率远远高于普通人。</p><p>我自己感受很多，同样一份报表，优秀的员工交上来的基本上不会有任何错误，我都不用检查就可以直接用；能力平庸的员工，交上来的永远有各种错误，我必须要耗费时间一个字一个字的检查，发现错误还要打回去重新搞，然后交上来你还会继续发现错误，效率非常低。你让普通员工搞996，总体边际效益并不高，但是他却会付出很多时间，投入产出效率进一步降低。</p><p>一个是不要忘记了发展经济的最终意义，就是为了让广大中国老百姓活的更轻松。</p><p>我自己在不同的企业工作过，我就想说，下午五点半就下班，和晚上九点十点才下班，整个世界都是不一样的。</p><p>下午五点半下班，可以去看电影，可以去探索城市里面有趣的餐厅，可以去深圳湾跑步骑自行车，可以去夜游莲花山，可以跨越半个城市去找朋友聚会，可以陪孩子出去散步，人可以得到生活，也刺激了消费。</p><p>晚上九点多十点才下班，人就成了一部机器，吃饭就是吃外卖，没有时间陪伴家人，拖着疲惫的身体回到家，洗完澡就是十一二点，一天就这样过去了，偶尔如此还好，天天如此的意义在哪里呢？</p><p>就算中国十年后迈入发达国家收入的门槛，一个国家90%都是社畜，每天工作十几个小时，晚上十点之后下班，没有个人生活，社会无法发展出更多的个性，变成一个纯粹的“工作社会”，整个社会低效率的运转，就算成为了发达国家，这样又有什么意义？</p><p>这样的例子在世界上不是没有，韩国日本就是典型。</p><p>让精英分子和精英企业去996，去拼命奋斗，然后国家和政府帮助这些企业去收割全世界的超额利润，然后政府通过制度安排，做好头部企业创造的收入和利润合理分配到全社会，让大多数人过上轻松愉快的生活，这才是理想中的生活。中国的体量足够大，10%的优秀分子和优秀企业去拼命搞，一样可以干翻发达国家同行，收割全世界。</p><p>马云那个讲话，在阿里内部讲就可以了，不要流到社会上，让大批的普通企业也集体仿效就不好了，因为阿里是头部企业，相对于普通企业，投入和产出都是高效的，人家996，论产出可以收割世界的利润，论收入阿里员工动不动就年薪一两百万，就算累，也就影响八万人。</p><p>另外就是，头部企业承担了代表中国在全球残酷经济竞争的任务，必须要保持高度的战斗性。某种意义上就跟一个国家的军队一样，必须严格纪律和训练保持战斗力。</p><p>而头部企业之外，大批的普通企业搞996的边际效益很低，但是却拉高了全社会的痛苦值，生育率一路走低，没时间陪孩子，孩子缺少家庭教育，全社会可持续发展能力降低，毫无必要。</p><p>当然，要实现头部企业赚钱收割全球，同时做好利润分配，让大多数人实现愉快生活这个目标，还是需要努力的。</p><p>比如说需要国家独立，对外国资本有控制力，韩国第一大企业三星电子，日本第一大半导体企业东芝半导体，台湾第一大集成电路企业台积电，外资股权比例都奇高无比，超过本土资本股权，这就很难搞好头部企业的收入分配了。</p><p>中国互联网企业早期也存在这个问题，不过最近几年新崛起的互联网公司股权结构内外资比例相对好多了。</p><p>另外就是政府对本土大资本也要有控制力，</p><p>美国在收割全球方面做的很好，头部企业在全球大赚特赚，</p><p>2000年到2018年，经济总量从10万亿美元到20万亿美元几乎翻了一倍，但是家庭收入中位数却基本没有变化，只增长了10%不到，新增长的财富都到少数精英富人那里去了。</p><p>说白了也是美国政府收入分配没搞好，占领华尔街和特朗普上台，都是普通人也开始不满意的结果。</p><p>来源：<a href="https://weibo.com/6120483044/HpsIShcl5?type=comment" target="_blank" rel="noopener">https://weibo.com/6120483044/HpsIShcl5?type=comment</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>965 是一种生活态度，996 也是</title>
      <link href="/2019/05/07/965-shi-yi-chong-sheng-huo-tai-du-996-ye-shi/"/>
      <url>/2019/05/07/965-shi-yi-chong-sheng-huo-tai-du-996-ye-shi/</url>
      
        <content type="html"><![CDATA[<p>996 的苦，我大抵是不懂得的。我工作快 5 年了，在这 5 年的时光里，都是以 965 的形式度过的。说是幸运，那倒也是，没有遇到过加班的项目。说是不幸，那也只能说是，也没有遇到有挑战的项目。<br>在今天的大多数看来，在一家公司里待满 5 年，可能不是件有意思的事——生活总会有各种的无奈。</p><p>5 年的时间，不长也不短。朋友变成了同事，网友变成了同事，同事变成了前同事，前同事变成了同事（笑~）。人呢，都是有自己的想法：</p><p>1.965 的工作太『安逸』——赚不了多少钱。</p><p>2.996 的生活太『辛苦』——没时间去花钱。</p><p>矛盾之下，有人选择将 965 的生活，变成了 996；有些则是选择将 996 的生活，变成了 965。</p><p>生活总是这么有趣。有光的一画，自然而然地，也就有阴影的一面；被某些人喜欢着，也必然意味着被某些人讨厌着；有很多的粉丝， 也同时意味着有很多的黑粉。</p><p>没有对与错，只有自己的选择与利益。</p><h1 id="965"><a href="#965" class="headerlink" title="965"></a>965</h1><p>作为一个农村里出来的穷孩子，我在今年里存款才突破 100,000——2018 年存下的，相当于现在大部分程序员一年的存款。以前的钱呢，都在帮家里还钱。你要是说呢，钱对于我也很重要，但是还有很多事情也很重要——生活、爱情、自我。所以，选择 965，对于我来说是一种平衡。</p><p>编程是一种兴趣。编程说是我的兴趣吧，倒也不是，我只是喜欢创造，就好比是个手工艺人一样。</p><p>生活是一种平衡。人是有生活的，机器人才没有。</p><p>家庭是一个归属。你有男朋友/老婆/儿子/女儿，你需要花时间在他/她们身上。</p><p>从这等角度来看，我到底是那种喜欢马拉松式生活的人，缓慢而又持久（笑）。所以我喜欢制定一个长期的计划，然后慢慢去执行，每天总能收获一点点。从长期来看，养成了一个好的习惯，就能构建长久的职业生涯。哪怕是有一天出去创业了，好的习惯也会带来一定的助力。</p><p>说是 965，但是这并不意味着不加班，只是很多工作可以回家里完成。如果从这等角度上来看，我到底也是加班过的：</p><p>1、深入研究项目上的技术栈</p><p>2、调研项目要使用的新技术栈</p><p>只是呢，这算是加班吗？哈哈~，我回家也是研究技术。若是自己能力不足，这种加班倒是也</p><h1 id="996"><a href="#996" class="headerlink" title="996"></a>996</h1><p>所以呢，为了钱去选择 996 也是一种生活态度。赚够钱了呢，就可以过退休般的生活，每天花很多时间去写想写的代码。前期呢，累是累了点，但是总是值得的。</p><p>赚钱是一种需求。总有那么一些人，就喜欢赚钱，赚钱是一种快感，比如唐老鸭的叔叔——最有钱的虚拟人物。</p><p>证明自己是一种需求。有的人，选择 996 的大公司，出自于自我实现的需要。在大的平台上，去创造一系列的精彩，而自己便是优秀的那个人。</p><p>在不了解自己想要什么，迷茫的时候，选择 996 是一种更有效的方式。对于你而言，965 带给你反而是一种时间上的浪费。6 点多回到了家里，却也不知道做些什么。那还不如，在公司混混沌沌地把钱赚了。</p><p>也因此呢，还有一种情况是：</p><p>在公司加班是一种享受。令人津津乐道的是，对于如我一样来大城市 “务工” 的程序员来说，回到住的地方反而更无聊。在公司里，还有同事可以聊天 ，还有零食可以吃，还有帅哥和靓妹可以看，何乐而不为。加班时，有免费的晚饭吃，到了 9 点回家还可以打车报销。</p><p>我们在说 996 的时候，指的是强制性的加班，而不是这种自主性的加班。</p><h1 id="965-与-996-徘徊者"><a href="#965-与-996-徘徊者" class="headerlink" title="965 与 996 徘徊者"></a>965 与 996 徘徊者</h1><p>在 TWU 的时候，我的人生有过一次的转变。那时是在 2014 年 10 月，我第一次了解到除了男性、女性，还有其 x 的性别。然后，性别在我的眼里，就变成了五种选项。从现象上来看，他/她们可能是 996 的人，又或者是 965 的人，但是实际上可能是：</p><pre><code>965 的人996 的人995 但是认为自己是 996 的人996 但是认为自己是 995 的人即不是 995 也不是 996 的人</code></pre><p>可是呢，生活是一种选择。选择了 965，可能就没有 996 的工资；选择了 996，可能就没有 965 的工资。</p><p>让我们来做个简单的自述，把你的 996 的工作变成了 965，算算你的时薪，看看你还能在现在拿多少钱？以一个月四周来看：</p><pre><code>965 意味着，一天 8 小时，一周 40 小时，一个月 160 小时。996 意味着，一天 10 小时，一周 60 小时，一个月 240 小时。</code></pre><p>所以，如果把你的 965 的工作时间换成了 996，那么你的工资应该至少要涨 50%（不包含加班费）。把你的 996 的工作时间换成了 965，那么你的工资应该减少 1/3。</p><p>最后，问题也就来了，你现在的工资少 1/3，你干吗？——你可能马上骂娘了。</p><p>你，可能会立马变成那个吐槽为什么不 996 的人呢？所以，生活并不会有太多的选择。你既要 996，又想要保持现在的工资和绩效，有点难——站着，还把钱赚了，不是一件容易的事。</p><p>生活就是这么需要一些同理心，人呢，有时要站在别人的角度来考虑问题。</p><h1 id="那么，你呢？"><a href="#那么，你呢？" class="headerlink" title="那么，你呢？"></a>那么，你呢？</h1><p>当然了，这些道理，我们都是知道的。</p><p>你呢，若是你，你会选择 965，又或者是 996，为什么呢？</p><p>来源：mp.weixin.qq.com/s/x8d4yRY6o_HISn4fqwx-Ig</p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花了 2 亿多，等了近 2 年，结果连个可用的网站都没有</title>
      <link href="/2019/05/06/hua-liao-2-yi-duo-deng-liao-jin-2-nian-jie-guo-lian-ge-ke-yong-de-wang-zhan-du-mei-you/"/>
      <url>/2019/05/06/hua-liao-2-yi-duo-deng-liao-jin-2-nian-jie-guo-lian-ge-ke-yong-de-wang-zhan-du-mei-you/</url>
      
        <content type="html"><![CDATA[<p>有个国外匿名吐槽网站，名字叫 Clients From Hell，意思就是来自地狱的客户。程序员和设计师们纷纷晒出自己经历过的奇葩客户。我们以前翻过上面的一些案例，比如：</p><img src="/2019/05/06/hua-liao-2-yi-duo-deng-liao-jin-2-nian-jie-guo-lian-ge-ke-yong-de-wang-zhan-du-mei-you/1.jpg"><p>今天推文，还是和地狱设计有关。不过这回是角色互换了，是来自地狱的开发商。</p><p>4 月 23 日，外媒 The Register 发了一篇报道，愤怒的汽车租赁巨头 Hertz 已经向纽约法庭起诉埃森哲了。</p><p>Hertz 在起诉书称，尽管支付了 3200 万美元（折合人民币 2.1 亿多）费用，但埃森哲从未交付过一个可用的网站或移动应用。</p><p>这到底是怎么一回事呢？</p><p>在 2016 年，美国汽车租赁巨头 Hertz 有一个雄心勃勃的计划，想转变其数字身份。该计划的目标是想重新设计 Hertz 数字平台，重新开发做一个市场领先的网站 Hertz.com 和一套互补的移动应用程序。新网站不仅可用于 Hertz 品牌，也要适用于旗下其他租赁品牌 Dollar 和 Thrifty。</p><p>为此，Hertz 花费数月，为这个计划评估电商现状，确定数字业务的目标和战略，规划实现愿景的路线图等等。</p><p>但是，Hertz 自家内部没有专业知识或资源来执行如此大规模的任务。所以需要和一家世界级的技术服务公司来合作。筛选潜在合作方后，Hertz 把选择缩小到埃森哲和另外一家。</p><p>在埃森哲为 Hertz 做了一次令人印象深刻的为期一天演示后，Hertz 选择埃森哲来设计、构建、测试和部署 Hertz 的新网站和移动应用程序。( 敲黑板：PPT 真是一门学问 )</p><p>于是在 2016 年 8 月，Hertz 和埃森哲愉快地签合同了。按最初计划，新网站上线时间定在 2017 年 12 月。</p><p>但由于多种原因，上线时间推迟到了 2018 年 1 月，然后又推迟到了 2018 年 4 月。</p><p>接二连三的延迟，Hertz 都忍了，但后来发现了一个让人吐血的事情：新网站进展居然没有达到最初整体要求的一半！</p><p>这下忍不了了！对埃森哲是否能顺利完成项目，Hertz 没有任何信心。于是在 2018 年 5 月终止合作。</p><p>随后，Hert 起诉埃森哲，要求赔偿 3200 万美元以及相应损失。</p><pre><code>起诉书：https://regmedia.co.uk/2019/04/23/hertz-accenture-website.pdf</code></pre><p>Hertz 在起诉书中，列出了埃森哲在很多方面的「罪状」：</p><h3 id="1、不完全支持响应式布局"><a href="#1、不完全支持响应式布局" class="headerlink" title="1、不完全支持响应式布局"></a>1、不完全支持响应式布局</h3><p>在签署的合同中，Hertz 明确要求埃森哲做 3 种网站布局：小型（支持手机访问）、中型（支持平板电脑）、大型（支持桌面电脑）。</p><p>埃森哲只做了小型和大型布局。想支持平板电脑访问？Hertz 需再另外交钱！</p><h3 id="2、无视可扩展性"><a href="#2、无视可扩展性" class="headerlink" title="2、无视可扩展性"></a>2、无视可扩展性</h3><p>在架构规范中，Hertz 明确要求埃森哲设计开发的网站要有可扩展性。即：设计一个公共的核心库，可以扩展到整个网站和移动应用程序，从而支持 Hertz 旗下所有品牌。</p><p>但是，埃森哲完全忽视这个要求，只针对 Hertz 北美站，无法用于 Hertz 全球站、Heartz 旗下 Dollar 和 Thrift 网站。</p><p> Hertz 向埃森哲提出这个问题后，项目负责人曾回应称，「我们认为创建一个通用代码库，Hertz 从其扩展，这样可用性更低，效率也更低。」</p><h3 id="3、前端代码烂透顶了！后端-Java-代码也不遵循规范"><a href="#3、前端代码烂透顶了！后端-Java-代码也不遵循规范" class="headerlink" title="3、前端代码烂透顶了！后端 Java 代码也不遵循规范"></a>3、前端代码烂透顶了！后端 Java 代码也不遵循规范</h3><p>Hertz 方面表示，埃森哲写的前端代码很糟糕，有着严重的安全问题和性能问题。</p><p>后来 Hertz 做了评测，发现埃森哲的前端代码问题太多了，无法补救，不得不放弃。系统的其他部分，部分代码也是不可用的。</p><p>2018 年 1 月，埃森哲曾在项目进展会议中的演示中承认了失败，并表示「前端技术（Angular2）对我们交付项目是一大挑战。」</p><p>埃森哲的 Java 代码，并没有遵循 Java 规范，逻辑差，并且难以维护。</p><h3 id="4、没有合理的测试"><a href="#4、没有合理的测试" class="headerlink" title="4、没有合理的测试"></a>4、没有合理的测试</h3><p>埃森哲未能对其开发的软件进行适当的测试，对系统许多组件压根没有测试。</p><p>而他们做测试时，又大都采用「Happy Path 测试法」。换句话说，在假设客户按照预期使用的场景下，测试查看网站或移动应用程序是否执行。</p><p>很显然，「Happy Path 测试法」是不够的，因为它没有评估真实场景下的性能，也无法测试错误处理。</p><h3 id="5、其他控诉"><a href="#5、其他控诉" class="headerlink" title="5、其他控诉"></a>5、其他控诉</h3><p>还有好多瓜，比如：</p><p>推荐买不会用的技术</p><p>埃森哲推荐 Hertz 购买 RAPID 许可。Hertz 买了后，但埃森哲又不会用，花了很多时间用于整合 RAPID 。</p><p>失败的项目管理，加剧了技术难题</p><p>埃森哲失败的项目管理，加剧了技术难题。比如：项目进行到第二阶段中期时，埃森哲调走（remove)一批重要的团队成员，包括产品负责人和微服务架构师。而新来者没有前任同等水平，人员替换过程中无形丢失了很多项目知识。埃森哲也向 Hertz 承认过项目延期部分原因是「重要资源」的流失。</p><p>内容管理系统存在严重问题</p><p>埃森哲开发的 AEM 模块（内容管理系统）存在严重缺陷。其代码和文件结构，没有基于 Adobe AEM 原型，导致程序不可靠，并且难以维护。</p><p>违背承诺，另收费用</p><p>埃森哲曾答应 Hertz 不会因项目延期而另外再收取费用，后来出尔发尔，要求 Hertz 支付额外费用。</p><h3 id="【说明】：以上都是基于-Hertz-起诉书摘译，仅代表-Hertz-的观点，不代表我们的看法。"><a href="#【说明】：以上都是基于-Hertz-起诉书摘译，仅代表-Hertz-的观点，不代表我们的看法。" class="headerlink" title="【说明】：以上都是基于 Hertz 起诉书摘译，仅代表 Hertz 的观点，不代表我们的看法。"></a>【说明】：以上都是基于 Hertz 起诉书摘译，仅代表 Hertz 的观点，不代表我们的看法。</h3><p>对于 Hertz 的指控，埃森哲方面回应 Register 称「起诉毫无根据」，并没有过多置评。</p><p>这个案子后续会如何发展，我们会持续关注。</p><p>网友评论</p><p>@老码农的自留地 : 咨询公司江河日下，除了高大上的规划PPT，连做网站这种搬砖钱也挣[允悲]</p><p>@ayumi_0213：accenture除了咨询，还有另外两个bu，其中一个是it 外包，这个业务十几年前就已经有了。而现在除了accenture，普华永道和安永等四大会计师事务所也有it外包的业务喔～</p><p>@Sansiro_Santon：可能是转外包给印度学生做的[doge]</p><p>@冰箱里的小怪兽：美国还是竞争小啊，2016年8月立项，上线时间居然定到1年零4个月以后，而且还能容忍再推迟4个月。这玩意儿要是搁国内，竞品早把你打得啥都不认识了</p><p>@巴扎嗨嘿嘿嘿嘿：学好PPT，鬼都能忽悠来给你推磨[笑而不语]</p><p>@爱吃萝卜叶叶的毛毛虫：给中国公司两个亿，你想要啥样子的网站都可以</p><p>原创：程序员的那些事（id：iProgrammer）<br>来源：<a href="https://mp.weixin.qq.com/s/KR8yk64426civfA0fyHBTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KR8yk64426civfA0fyHBTQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣图：外包的真相</title>
      <link href="/2019/05/06/qu-tu-wai-bao-de-zhen-xiang/"/>
      <url>/2019/05/06/qu-tu-wai-bao-de-zhen-xiang/</url>
      
        <content type="html"><![CDATA[<img src="/2019/05/06/qu-tu-wai-bao-de-zhen-xiang/1.jpg">]]></content>
      
      
      <categories>
          
          <category> 趣图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 趣图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们搞开发的为什么会感觉到累</title>
      <link href="/2019/05/05/wo-men-gao-kai-fa-de-wei-shi-me-hui-gan-jue-dao-lei/"/>
      <url>/2019/05/05/wo-men-gao-kai-fa-de-wei-shi-me-hui-gan-jue-dao-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="引题"><a href="#引题" class="headerlink" title="引题"></a>引题</h1><p>昨天下班坐公车，听到一个和我年纪相仿的哥们儿打电话，隐约听到电话那边好像是他女朋友问他现在饿不饿，他说“我已经饿的不饿啦”。</p><p>饿的不饿了，听起来很幽默，对我很有触动，我在思考，我此时站在公车中部，手扶着杆有点酸，你问我手有多酸，借用打电话的那个哥们的话，随着日复一日这样的酸痛感受的反复刺激，已经酸的不酸了，你问我饿不饿，我也说不上来，飘飘渺渺，因为做编程这行几年下来，我自己的感受是，虽到了吃饭时间，但是感觉似饿非饿，吃饭感觉只是个形式。</p><p>以上都是是大多数在一线城市奋斗的人们所经历的可以忽略不计的一些事，我这里想聊聊为什么我们做IT的大多数都很累？</p><p>什么叫累，古代私塾先生教书的时候解释说，累字拆分意义是田系在头上，白话文讲就是“头上有田方知累也”。这是上古时代“累”的含义，当然现在还有大多数人为了我们国家的发展在辛勤劳累的种田，他们很辛苦。</p><h2 id="我们的累"><a href="#我们的累" class="headerlink" title="我们的累"></a>我们的累</h2><pre><code>回到标题，我觉得我门做编程的大多数人都很累，为什么累呢？</code></pre><p>到一个新公司上班，公司预先说要做一个项目或产品，你不知道到底有多复杂或简单，心里些许担心或不安，因为这些东西有可能在你预想的基础上会变的。</p><p>准备启动项目或产品，开始做需求，由于老板把时间压得紧，需求可能有些粗糙，开发时间也被压很短，因为这样，担心和紧张感铺面而来，需求会不会变，会不会遇到技术障碍，都是可变的。</p><p>开发过程中，由于需求做的不够精细（这太正常了，客户或老板都不知道他要什么），接二连三的变动和更改，紧张万分，不知道哪一会儿会又变动。</p><p>累死累活做完了，开始测试了，啊，XXX这里点击没反应，邮件怎么没发送成功，怎么发送成功了没收到，又报黄页，js错误……时刻有可能出bug。</p><p>终于上线了，客户出了个error，你帮忙看看吧（测试阶段都没有这问题哦）；日志记录了不少错误哦，你给定位下；客户投单没成功，肯定他妈的第三方接口问题；客户IE6下按钮点不了，下拉框出不来；oh shit ……</p><p>又开始新的项目了，新的一轮紧张挑战拉开帷幕……之前上线的项目或产品还会时不时给你来些心跳，下一秒未可知，明天未可知。</p><p>循环ing……</p><p>大伙可能要说担心或不安是多余的，那是你技术水平太垃圾吧，我之前的技术leader技术很好，很牛逼，平常他说的最多的是未雨绸缪，居安思危，人无远虑必有近忧这些句话。他时常会研究新东西，新技术，给我们安排好书去读让我们保持进步，说实话过程中有点反感但从中受益。</p><p>有时候我们自己需要被迫去变，因为现在大的背景变化非常大，PC向移动的迁移，时刻在变，我们也时刻因为这些变而被动变，或被这些变影响我们的生活，苹果开发初级10k左右起，直接秒了我们大部分搞了3年左右.net或java的人，听过好多身边做pc开发的都呐喊过说想变，但是真正主动承受痛苦去变成功的没多少人。</p><p>有的人可能会说了，赶紧努力吧，做管理，当领导，呵呵，我发现那些大部分位置越高的人头发越稀落，医学上说头发稀落和肾功能衰弱有关，常言道，恐伤肾，可想是担受了多少惊恐与变数，过几年你很有可能就成了他们。中层领导有来自高层的压力，高层来自boss的压力，boss来自生存的压力和股东投资者的压力等……有时候麻雀没有变成凤凰未尝不是一种解脱啊，我说这话你可以说我是个loser思维，我也诚然。我想告诉大家的是珍惜当下吧！我现在特别怀念刚参加工作那会儿，激情，敢说敢做，敢表现神经质……</p><p>所以说，我们累是因为我们所从事的事情变数很多，人最恐惧未来，因为未来不可知，上至诸侯王下至编户百姓无一幸免，我们就活在这样变化无常的区域里面，紧张嘻嘻，正是这样，久而久之变得抑郁，神经衰弱，麻木不仁，懒得动，懒得说话……恶性循环。</p><p>我们现在就是忙于应付这些变，所以搞的自己紧张忙碌，最终却没多大所获。这是我们大多数人的现状。</p><h1 id="新生"><a href="#新生" class="headerlink" title="新生"></a>新生</h1><p>  希望2019大伙都少些加班，把有限的业余时间拿来好好放松自己，勤跑步，多看书，充实自己，做到可持续发展，主动改变自己，无论您今年多大了都应该充满理想，因为中国历史上历来不缺少枯木逢春、老来发迹的例子。大器晚成的人他没有年少轻狂，没有少不更事；年轮的重叠使他们更加珍视机遇，岁月的磨砺让他们事事洞明、人情练达。我希望大伙都能达到自己的理想，并且在很嫩的时候。</p><p>  最后，关于加班我讲个小故事，希望能影响到一点点正在加班的同胞们，故事名字叫奴性是怎样练成的：第1天抽他100鞭子，他很愤怒但没敢说；第2天抽他80鞭子，他看到了生活的希望；第3天抽他50鞭子，他夸抽他的人进步了；第4天抽了他30鞭子，他跪下感动流涕；第5天抽他了20鞭子，他感恩戴德；第6天7天他已习惯了在感动中挨鞭子。并开始用鞭子抽那些同情他的人。</p><p>来源：施瓦小辛格<br><a href="http://www.cnblogs.com/wenyang-rio/p/4261987.html" target="_blank" rel="noopener">www.cnblogs.com/wenyang-rio/p/4261987.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的眼界真的不要，也不能只局限于技术</title>
      <link href="/2019/05/05/cheng-xu-yuan-de-yan-jie-zhen-de-bu-yao-ye-bu-neng-zhi-ju-xian-yu-ji-zhu/"/>
      <url>/2019/05/05/cheng-xu-yuan-de-yan-jie-zhen-de-bu-yao-ye-bu-neng-zhi-ju-xian-yu-ji-zhu/</url>
      
        <content type="html"><![CDATA[<p>前几天在读《极客时间》专栏的时候，看到这么一段话：</p><pre><code>对客户来讲，真正有价值的是业务，技术是为业务服务的；对于团队生产力来说，管理起关键作用，否则技术实力发挥不出来。对于资深的业务和管理人员，也有很“技术”的部分，更有很“艺术”的部分。懂得业务和管理的技术人员，才能把技术能力最大化地发挥出来。</code></pre><p>作为一个创业者，正在经历着”创业”这个冰与火的淬炼与锻炼，深知作为一个技术人员来讲，什么才是最重要的，所以看到上面那段话，感同身受，感觉说的非常对，而且真的是非常重要：懂得业务和管理的技术人员，才能把技术能力最大化地发挥出来。</p><p>关注我的读者可能都知道，其实我都一直在跟大家强调一个问题：程序员的眼界真的不要，也不能只局限于技术。</p><p>程序员既然是技术出身，不只局限于技术，那又该如何提升自己在企业中的价值，该关注除了技术之外的哪些方面呢？</p><h1 id="一、懂产品和业务"><a href="#一、懂产品和业务" class="headerlink" title="一、懂产品和业务"></a>一、懂产品和业务</h1><p>就像上面那段话说的，技术是工具，它只有服务于具体的业务才能产生价值。只有懂产品和业务才能把客户服务好，才能把产品做到最好。</p><p>很多人可能会说：这不应该是产品经理的活么？我们工程师为什么要关注呢？</p><p>这是误区，而且是巨大的误区。眼界局限于自己的活，你的前途和前景，发展空间就是局限的，微小的。跳出来看看这个世界，你可能会发现，身边的技术管理者(技术 leader)，越往上走，是不是对产品和业务的逻辑要求越高？</p><p>如果你只会技术，每次在团队之间沟通，都用技术语言，那么团队之间非技术人员就会很那听懂，而你如果能够把复杂的业务逻辑非常简单的描述清楚，那么你就会使团队之间沟通的更有效率。<br>可能在不知不觉间，就在推动着团队前进，等你对产品和业务逻辑也来越熟悉的时候，你会发现，团队之间的沟通正在以我为核心，我在团队中正变得越来越重要。</p><p>从而，你可能会更上升一步，成为团队负责人，如果团队负责的好，决策权就来了，再上升一步，就是管理层！</p><p>你想想，如果你只关注你的一亩三分地好不好？你再努力，再牛逼，地就那么大，你的发展空间就受限，你种地技术再牛，产量也不会太高。</p><p>而且，我告诉你，每个行业，每个产品可能都有着自己独特的业务逻辑，如果你深谙或者熟悉某一个行业的业务逻辑，你可能就会成为这个行业的专家，从而说话和做事就会越来越有分量！如果你经常做 ERP 系统，你就知道了。</p><h1 id="二、懂管理和创新"><a href="#二、懂管理和创新" class="headerlink" title="二、懂管理和创新"></a>二、懂管理和创新</h1><p>技术人要想懂管理，可能需要一个缓慢的过程，比如我：在创业，深知管理真的是一门很大的学问，每个人都有着自己不同的心理。你可能会想：我应该如何提高员工的效率？如何凝聚团队的战斗力？如何能够让大家都非常的努力？如何保证团队的稳定性，不会有人员流失？如何……等等。</p><p>但是，这些问题对于一个技术人员刚转管理可能会很难，我们可以从技术领导力方面入手，先从自己最擅长的地方切入，慢慢学会管理。强迫，军事化管理，绝对服从等是很难都根上解决管理问题，而技术领导力就会给我们一个方向，就是靠自己的能力来征服他们。你解决不了的问题，我帮你解决了？他能不服你？</p><p>所以，管理就是这样，管理靠的是正确的引导！</p><p>技术人要懂创新，具有批判性思维。很多人都感觉程序员是逻辑严密，但是一根筋，在业务逻辑的处理上是一条路走到黑。其实，我们更应该跳出来，要敏锐的去发现问题，去寻求业务逻辑不好的地方，去改进这些问题，更要大胆的拥抱新技术，新工具，以及新流程，去带动整个团队进行产品升级，技术升级，提升企业的 ROI 。</p><p>所以，我们程序员应该经常跳出来，看看外面的世界，看看身边其他的牛人，都在干什么？不要只想着技术，即使你的目标是技术专家，技术专家也是需要懂产品，懂业务的，如果你是架构师？如果你不懂业务逻辑，不深谙一个行业的操作流程和业务流程，你能设计出一个非常好的架构来么，更别提一个好的产品来了！</p><p>来源:mp.weixin.qq.com/s/qg8AzGQQbTU86PlkJihsow</p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序猿，你该为自己加薪--用钱生钱</title>
      <link href="/2019/05/04/cheng-xu-yuan-ni-gai-wei-zi-ji-jia-xin-yong-qian-sheng-qian/"/>
      <url>/2019/05/04/cheng-xu-yuan-ni-gai-wei-zi-ji-jia-xin-yong-qian-sheng-qian/</url>
      
        <content type="html"><![CDATA[<pre><code>“如果你没找到一个当你睡觉时还能挣钱的方法，你将工作到死。” ——巴菲特</code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code>唯金钱与技术不可辜负。</code></pre><p>作为智商比较高的程序员，这么难的程序都能学会，投资理财就更不用说啦。</p><p>金钱是有规律的，只要掌握了一定的规律，虽说不能一夜暴富，但是把掌握的规律用于生活中，至少是可以让挣钱变得轻松一些。</p><p>不知道他们有没有想过：生活中，单靠增加工时获得的收入永远无法让你摆脱贫穷。用青春来换钱的交易也绝对不可取。</p><p>绝大多数的人，都是非常勤奋的，不然也不能坚持每天定时去上班，但又是懒惰的，从来没有想过学习掌握金钱的规律。</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>最近笔者在看作者博多·令费尔写的一篇小作《小狗钱钱》，这本《小狗钱钱》是根据作者根据他写的《财务自由之路》，把其中的方法与策略编成这么一个小故事的。<br>《小狗钱钱》讲的是一个 11 岁的小女孩捡到一条会说人话的狗（名为 钱钱），然后钱钱教会了这个小女孩与钱打交道的方法，怎样理解钱与一步步轻松地挣钱，<br>最后小姑娘不仅自己掌提了钱的使用方法，而且还帮助自己的父母走出了财务危机的故事。    </p><p>看完这篇小作，做点笔记与写自己下看完后的一些感悟。</p><p>里面讲到一个故事：</p><pre><code>“从前有一个农家小伙儿，他每天的愿望就是从鹅笼里拣一个鹅蛋当早饭。有一天，他竟然在鹅笼里发现了一只金蛋。一开始他当然不敢相信自己的眼睛。他想，也许是有人在捉弄他。为了谨慎起见，他把金蛋拿去让金匠辨别，可是金匠向他保证说，这只蛋完完全全是金子铸成的。于是，这个农家小伙儿就卖了这只金蛋，举行了一个盛大的庆祝会。”“第二天清晨，他起了一个大早，赶到鹅笼里一看，那里果真又放着一个金蛋，这样的情况延续了好几天。可是这个农家小伙儿是一个贪婪的人，他抱怨自己的鹅，因为鹅没法向他解释是怎么下出这个蛋的，否则他也许自己就可以制造金蛋了。他还气乎乎地想，这只懒惰的鹅每天至少应该下两只金蛋。他觉得现在这样的速度太慢了。他的怒火越来越大，最后，他终于怒不可遏地把鹅揪出笼子劈成了两半。自那以后，他再也得不到金蛋了。”假如我没有了我的“鹅”，我就总是得为了赚钱而工作，但是一旦我有了属于自己的“鹅”，我的钱就会自动为我工作了。金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望。</code></pre><p>必须真的有这个愿望的意义在于，如果足够的动力，没有足够的决心去做某些事情，终究很难成事。</p><pre><code>如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好退路了。不能试验。你只有两个选择: 做，或者不做。你是否能挣到钱，最关键的因素并不在于你是不是有一个好点子。你有多聪明也不是主要原因，决定因素是你的自信程度。 一个人把精力集中在自己所能做的，知道的和拥有的东西上的那一天起，他的成功就已经拉开了序幕。你最好想清楚，你喜欢做什么，然后再考虑你怎么用它来挣钱。你要每天不间断地去做对称的未来意义重大的事情。你为此花费的时间不会超过 10 分钟，但是就是这 10 分钟会让一切变得不同。当你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力。</code></pre><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>72 定理: 用 72 除以你们投资的年收益率的百分比， 得出的数字就是这笔钱翻一倍所要的年数。</p><p>72 小时规定: 当你决定做一件事情的时候，你必须在 72 小时之内去做这件事情，否则你很可能 就永远不会再做了。</p><p>72 公式 也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。我上网查了一下，我国目前的通货膨胀率大概是 3% ，用 72 除以 3% ，得到 24，就是说 24 年以后，你的钱只值现在的一半。”</p><h1 id="买基金为自己加薪"><a href="#买基金为自己加薪" class="headerlink" title="买基金为自己加薪"></a>买基金为自己加薪</h1><p>学习一门技能时，尽量选择积累性很强的技能，随着时间的推移，这个技能越来越厉害，那这个技能就很值得去学习。毫无疑问，投资理财，这个技能积累性就很强，最重要的是，这个技能适用于任何人、任何行业，因为投资理财 的本质，是用钱来帮你赚钱，这是最高级别的赚钱方式，除非你不想赚钱，否则每个想赚钱的人，都该重视投资理财。越是有钱人，越是懂得投资理财。</p><p>银行一年期定存利率大概是 1.5% 左右，而这利率是跑不赢通货膨胀的。一般的年轻人都是把钱放到一些收益稍高一点的理财产品里面，比如：余额宝、微信理财通里。但这也只是比银行还是要好一点而已。</p><p>定投十年挣十倍。我建议年轻人应该把部分钱（除去这部分钱，不会对你的生活产生任何影响的，比如你每月工资的 5% - 10% ）用来买基金比较好，通过 买基金为自己加薪，每月定投。</p><p>当然买基金也是有风险的，建议是了解基金之后再买。往后的时间里面，笔者会读更多关于挣钱的书箱，对买基金的策略有了更深的了解后，会再分享。</p><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>在笔者看来，故事里面的小姑娘，在后期可以轻松获取金钱的本质：改变了自己。</p><p>这和《大学》里面说的：“修身、齐家、治国、平天下” 的道理是一样的， 一切从改变自身做起。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果想获取更多的财富，就从读如何实现财富自由类的书籍开始吧，从书中获取金钱的规律，从而使自己获取财富变得更轻松一些。</p><p>来源:<a href="https://segmentfault.com/a/1190000018808895" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018808895</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 闭包指南</title>
      <link href="/2019/05/04/javascript-bi-bao-zhi-nan/"/>
      <url>/2019/05/04/javascript-bi-bao-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p>闭包是函数创建时作用域内所有变量的集合。要使用闭包，需要在另一个函数中创建一个函数，这种函数被称为嵌套函数。内部函数可以访问外部函数作用域中的变量（依靠闭包可以访问外部函数作用域），即使在返回外部函数之后也是如此。每次创建嵌套函数时都会创建闭包。</p><p>在继续了解闭包之前，首先了解一下JavaScript中的作用域链。</p><p>通常，有两种类型的作用域：<br>    全局作用域<br>    局部作用域</p><p>在JavaScript中，函数内部的变量在外部是不可见的。但是在块内的变量（if 或 while 之类）是可见的。</p><p>因此，JavaScript有函数作用域。没有块作用域。</p><pre><code>var a = 10;function app(){   var b = 2;   console.log(a); // 10   console.log(b); // 2}console.log(b); //   ReferenceError: b is not definedapp();</code></pre><p>正像我们已知的那样，a 是一个全局变量并且 b 是一个局部变量，它是app函数独有的。</p><p>我们无法从局部作用域之外获取局部变量的值。</p><p>使用嵌套函数 —— 函数内部的函数</p><pre><code>var a = 10;function app(){     var b = 2;     var d = 3;  function add(){     var c = a + b;   } return add;}var x = app();console.dir(x);</code></pre><p>在这里app是父函数，add函数是子函数。</p><pre><code>1.代码中没有用 console.log 而是用了console.dir 来输出指定JavaScript对象的所有属性，这有助于开发人员获取对象的属性2.变量 x 被分配给app函数，app函数返回add函数。因此我们可以看到add函数的所有对象属性。</code></pre><p>如果在浏览器中查看控制台，可以在Scopes数组中看到Closure对象。</p><p><img src="https://image-static.segmentfault.com/311/424/3114243464-5ccecabd8a11e_articlex"></p><p>由于内部函数add访问外部函数变量b 和 d，因此这2个变量将被添加到Closure对象中以供引用。</p><p>让我们看看下一个例子：</p><pre><code>var a = 10;var startFunc;function app(){      var b = 2;   function add(){      var c = a + b;      console.log(c);   }   startFunc = add();}app(); // 调用app函数startFunc; // 上面调用的app函数会将add函数赋值给startFunc并输出c的值</code></pre><p>1.一个名为 startFunc 的全局函数被分配给add函数，该函数是 app 函数的子函数。<br>2.这只有在调用 app 函数后才有可能，否则 startFunc 将作为全局变量而不被分配任何值</p><p>在JavaScript中使用闭包</p><p>很多人在编码时会用到闭包，但是不明白用它的原因。 JavaScript没有像其他面向对象语言一样的访问修饰符，例如 private，public，protected。不过我们可以利用函数来保护命名空间免受外部代码使用的影响。</p><p>特别是在函数中，立即执行函数表达式（IIFE）是在声明之后会立即执行的函数表达式。在声明函数之后，你不需要去调用该函数。</p><p>IIFE的语法定义是：</p><pre><code>(function(){             //函数内部的变量和作用域})();</code></pre><p>举个例子：</p><pre><code>var studnetEnrollment = (function () {    //私有变量，任何人都无法改变    //除了下面声明的函数     var count = 0;     var prefix = &quot;S&quot;;    // 返回一个命名函数表达式     function innerFunc() {         count = count + 1;         return prefix + count;     }; return innerFunc;})();var x = studnetEnrollment(); // S1console.log(x);var y = studnetEnrollment(); // S2 console.log(y);</code></pre><p>count和prefix是两个私有变量，任何人都无法进行更改，只能访问内部函数（即代码中的innerFunc）。只有名为闭包的功能才能对此进行访问。</p><p>1.第一次调用studentEnrollment函数时，函数内的count变量由innerFunc函数递增加1。<br>2.第二次，增加上一个计数值，即 1 增加到 2<br>3.Closure功能可以实现这些功能。</p><p>结论<br>    闭包是外部函数中的变量集合，它提供对内部函数作用域的访问以保护全局命名空间。<br>    闭包使开发人员能够编写像面向对象语言那样的干净代码，这些代码不会混淆全局和局部变量的名称。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真正理解Mysql的四种隔离级别</title>
      <link href="/2019/05/03/zhen-zheng-li-jie-mysql-de-si-chong-ge-chi-ji-bie/"/>
      <url>/2019/05/03/zhen-zheng-li-jie-mysql-de-si-chong-ge-chi-ji-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><pre><code>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。</code></pre><h1 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h1><pre><code>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</code></pre><h1 id="Mysql的四种隔离级别"><a href="#Mysql的四种隔离级别" class="headerlink" title="Mysql的四种隔离级别"></a>Mysql的四种隔离级别</h1><pre><code>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。Read Uncommitted（读取未提交内容）    在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。Read Committed（读取提交内容）    这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。Repeatable Read（可重读）    这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。Serializable（可串行化）    这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：    脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。    不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。    幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</code></pre><p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1627454-eceded962ef591d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686/format/webp"></p><p>作者：游泳的石头<br>链接：<a href="https://www.jianshu.com/p/8d735db9c2c0" target="_blank" rel="noopener">https://www.jianshu.com/p/8d735db9c2c0</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北冥乘海生：996其实没什么卵用</title>
      <link href="/2019/05/02/bei-ming-cheng-hai-sheng-996-qi-shi-mei-shi-me-luan-yong/"/>
      <url>/2019/05/02/bei-ming-cheng-hai-sheng-996-qi-shi-mei-shi-me-luan-yong/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/v2-5dfb4762cbb4c9938a20b017f7bfbc1a_1200x500.jpg"><br>996一词，是某巨头的一个中层提出来的，最初只是个忽悠老板的口号，哪知道如今应者云集，简直成了创业精神的代名词。<br>007一词，则是我提出来的(《江湖丛谈》与互联网三不要)，虽说是直钩钓鱼，居然也有人信以为真，还打算试试。</p><p>注意，不要把这些词恶毒地解读为“加班”：除了睡觉都在工作，哪还有时间加班？</p><p>把码畜(大数据码畜生存指南（一）)们像蝈蝈一样圈起来，三餐加零食饲养着，让他们在戒除健身、聚会和性生活三大恶习的状态下，以公司为家，以下班为耻，<br>这样就能够让打工的开好车，老板们发大财么？其实，在大公司里，先不说对不对，996这事真的没什么卵用。</p><p>先声明，凡是拿*.布斯们一天睡几个小时来理论的，我都直接拉黑：合伙人们博的是无限未来，007都是天经地义；而打工仔们是按劳取酬，推一辈子石头也不会拥有自己的金字塔。<br><img src="https://pic2.zhimg.com/80/v2-0f0da19c7a22f0588563dc5090a23515_hd.jpg"></p><p>工作分两类：一类主要看执行力，一类主要看创造力。如果是前沿研究、艺术创作之类的工作，显然要以激发创造力为主，要求工作时间不啻是南辕北辙。<br>设想下，假如比尔盖茨让麾下的科学家们都集中住宿，统一制服，每天早汇报晚总结，按代码行数和paper字数发奖金，这不是微软研究院，这是衡水研究院。</p><p>诚然，大多数公司不大需要创造力。他们得稳准狠地叼住几根骨头，先吃饱了才是王道，这需要的是野狗一样的执行力。</p><p>对于交付型项目，执行力还真就是靠睡得少：甲方爸爸啥时候临幸你，你就得啥时候舔上去，比鸡起得早，比鸡睡得晚，以迅雷不及掩耳盗铃之势把活干完。所以，2B项目紧的时候996是必要的，不过并不需要、也不能常态化。</p><p>为什么不能常态化？从生理规律上看，脑力劳动者如果不以进ICU为目标，那么每天能够认真投入的时间，八小时也就到极限了。人毕竟不是机器，<br>老板又不是女友，怎么瞧都瞧不烦。长期996耗下去，只是浪费方便面和卫生纸而已。当然，如果你的工作只是客服那样的机械劳动，拉长时间肯定有效，可是别忘了，人家客服是按件计酬的。</p><p>不信您看看大洋彼岸，Google一年收一千亿刀，苹果利润就几百亿刀，还甭说996，加班的都没几个，隔三岔五还能在家办公。显然，以厂为家和商业成功、个人成就之间，并没有必然联系。</p><p>唯有中国2C的互联网公司们，个个都说自己是躺着挣钱的科技企业，可明知常态化996没意义，为什么还乐此不疲呢？面对如此深邃的哲学问题，我就着同事吐出的烟圈，思考了好几个不眠的中午，才发现，原来我国流行的996，有几种成因各异然并卵的情形。</p><h2 id="神仙打架-凡人遭殃"><a href="#神仙打架-凡人遭殃" class="headerlink" title="神仙打架 凡人遭殃"></a>神仙打架 凡人遭殃</h2><p>说得明白点儿，你加的那些班，其实是公司政治斗争的牺牲品。读过《怎样在大公司混成中层干部？》的都知道，中层干部最爱做的，就是拼命扩大团队。<br>怎么扩大呢？简单说就是狗揽八泡屎，喝不喝老端着：兄弟部门做了个好产品，我改头换面也做一个；中台明明有基础服务，我就要嘴硬强调部门需求，自己重新造个轮子。<br><img src="https://pic1.zhimg.com/80/v2-fd13a079297e7af3747439e6c899ab78_hd.jpg"></p><p>这种内部竞争，才是赤裸裸的仇恨。既然你夸了海口，就得抢在别的团队前面把轮子造出来，所以只好加班加点，搞起了996。996的结果，<br>无非是成王败寇：要是你在一个明星团队，干掉内部对手，就可以拿到大把股票；可要在一个失败的团队，干了半天被PK掉了，只好黯然离场。</p><p>倘若你加入的是阿里巴巴，就算是项目失败，回报也不会太差，996可以算是你的福报；可是还有更多的其他码畜，加入了阿里二大爷、阿里小姨子，同样在暗无天日的996以后，<br>连公司都黄了，只好收拾起青春岁月，付了二分尘土一分流水。对他们来说，996还是福报么？</p><p>把成功和失败的996er们拢在一块，平均来看大家不过是吃了些行业红利。而996，只不过是囚徒困境带来的超额付出罢了。如果你不幸是个失败的奋斗者，那么除了升高的尿酸和血脂，并不会留下什么无悔的青春。</p><h2 id="表演作秀-骑虎难下"><a href="#表演作秀-骑虎难下" class="headerlink" title="表演作秀 骑虎难下"></a>表演作秀 骑虎难下</h2><p>大公司里，人员过剩是常态化的。人多就一定能出成绩么？显然不是！于是，一个合格的leader，一定要向老板撒娇：我们没功劳也有苦劳，没苦劳还有疲劳呢！怎么撒娇呢，干不干活老板不知道，晚上都在这儿耗着还能看不见么？<br><img src="https://pic4.zhimg.com/80/v2-589893d33022377e70cd70db6e795fab_hd.jpg"><br>于是，老板四点去打高尔夫，副总就五点去健身，总监就六点去喝茶，经理就七点去吃饭，组长就八点叫外卖，员工就九点往外冲。长此以往，干脆形成了996的潜规则，以及打车报销、晚上管饭之类的“福利”。乃至有的老板，也沉迷于这种男耕女织的火热场景，把平均工作时间作为一项重要的考核指标，谁耗得长才能多招人。</p><p>有人说了，这样做至少有甄别作用，不接受996的人一定也是不肯努力的。这话没错，可是您想过没有，不肯努力的人，就算是996也还是出工不出力不是？</p><p>实际上，生活在996中的码畜们，大多是用空洞的会议填满整个白天，午饭晚饭后都安排漫长的行军式遛食，然后在华灯初上之时，才慵懒地开始一天的编码。我问过不同公司的几个码畜，他们告诉我：听说公司准备实行996，长长地松了一口气——这下可以心安理得地磨洋工了！</p><p>有时，公司也要作秀。只有多掏点电费，晚上把大楼点得灯火通明，或者时不时分享几个加班改变人生的正能量案例，你的公司才被认为没有丢失创业精神，才能在中国互联网立足。</p><p>什么？你敢说自己就是不喜欢加班？你敢说自己的团队生活工作平衡？在当今中国互联网的政治正确里，光那几个自媒体鸡汤号儿，就能把你喷得生活不能自理了。</p><h2 id="一将无能-累死三军"><a href="#一将无能-累死三军" class="headerlink" title="一将无能 累死三军"></a>一将无能 累死三军</h2><p>忘了是曾子还是贝索斯说过：对一个项目来说，两个披萨还喂不饱的团队就太大了。这里有个血淋淋的事实：几乎没有一个明星产品，是靠堆人头做出来的。</p><p>而天天996的团队，往往有这样一个老板：他随大王起事多年，靠拍马屁和无底线成了封疆大吏。有一天，像印度军队为了给尼赫鲁庆生向中国军队开火一样，他深情地向团队发问：”大老板如此英明神武，我们为何不做个“牛逼”号飞船，登上牛郎星去吹牛逼呢？”</p><p>干部们当然是赞成之声一片。一地鸡毛之后，留下一群懵逼的产品经理，没日没夜地设计“牛逼”号。煞有介事地论证一番之后，大家给出了结论：”您的思路太完美，无奈团队能力不足，还是先把火箭做出来吧！”</p><p>老板轻蔑地瞧着火箭工程师：”这个火箭啊，我认为得烧煤，煤还得选蜂窝煤，水洗煤不好。”于是，在团队痛哭流涕地誓师之后，在“大干快上、早日升天”的标语下，五百人热火朝天地996了半年，终于造出了全球唯一的蜂窝煤动力火箭。上线那天，这玩意还真争气，嘭的一声就炸了！</p><p><img src="https://pic2.zhimg.com/80/v2-efc9a9087338853879eae94458894635_hd.jpg"></p><p>这下，老板可急眼了：“就是你们这些人不拼命！从明天开始，给我改007！……” 遇上这样的老板，怎么能不996呢？就算是996了，又有个屁用呢？</p><p>总结起来，如果摒弃了生产关系领域那些龌龊的杯葛，你的团队真能做到目标清晰、决心坚定、兵精将勇、赏罚分明，为了完成阶段性的产品业务目标，996是确实是有战术意义的。不过，在千人以上的大公司里，这样的状态是可遇不可求的。而且，自驱力这么强的团队，还用得着把996当口号喊出来么？</p><p>天真的码畜码农们，别以为你的高工资是996换来的，那更多是行业红利。当互联网风光不再之时，你就算997也不过像今天的的哥那样维持温饱。如果不能从做事转入治人，那么经年的螺丝钉岁月，会让你既无暇提高自己，也无法积累资源，在锈迹斑斑以后被新的螺丝钉换掉。</p><p>天真的中层干部们，也不要以为996彰显了你的执行力，其实那只是暴露了你的内斗为纲和业务无能。如果不改变生产关系第一性的协作态度，不以尊重科学规律的方法组织研发，996也没什么卵用。那么什么才有用呢，当然是007啦！</p><p>作者：北冥乘海生<br>来源：<a href="https://zhuanlan.zhihu.com/p/62765114" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62765114</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金三银四铜五铁六</title>
      <link href="/2019/05/02/jin-san-yin-si-tong-wu-tie-liu/"/>
      <url>/2019/05/02/jin-san-yin-si-tong-wu-tie-liu/</url>
      
        <content type="html"><![CDATA[<p>鲁班简称LB</p><p>　　据说，金三银四，截止今天为止面试黄金时间已经过去十之八九，而LB恰逢是这批面试大军其中的一名小兵，很不幸今年恰逢遇上了互联网寒冬（即各大公司都在裁员，对外提供岗位相对较少的，这意味着很多猿即将面临着更多的竞争对手和相对较少的岗位困境），LB求职过程种种被虐，尸体趟过召唤师峡谷每个角落，如今历历在目，终究，当初的一名无名小卒如今已是一名超级兵哈哈，但是从这个事情上却学到了不少的东西，LB不亏。</p><p>　　经验也总是用来交流用的，于是LB觉得有必要记录下来，也许对猿们会有一丝帮助。</p><p>　　首先，找工作得有一份体面的简历，这里就会衍生一个如何书写简历的问题，LB将从如下角度总结：</p><p>　　关于简历</p><p>　　　　如何书写简历</p><p>　　　　HR角度较为关注信息</p><p>　　　　1.个人信息（年龄，联系方式等）</p><p>　　　　2.求职意向（工作年限，工作地，岗位）</p><p>　　　　3.教育经历（专业，学校，毕业时间） </p><p>　　　　证书（如ACM，软证，外语水平）</p><p>　　　　面试官角度较为关注信息</p><p>　　　　1.专业技能</p><p>　　　　　　4-5项熟悉2-3项了解，建议层次分明，逻辑有序，建议别写精通，除非很NB，不然被问到不是很深的问题你答不出，面试官认为你不真实。</p><p>　　　　2.自我评价</p><p>　　　　　　是否有博客（文章数太少不写，减分），是否有GITHUB（提交数和STRA太少不写，减分），是否有积极学网课（如极客时间星球，虚假减分）。</p><p>　　　　3.项目难点</p><p>　　　　　　队列和缓存高可用，分布式应用衍生问题解决方案，JVM的排查技能，数据库层面优化和分库分表等，这些东西都需要你嵌入到你的项目中。</p><p>　　　　那么什么是‘’优秀‘’的简历（网图）</p><p>　　　　　　　　　  看图</p><p>　　　　　　　　　<img src="https://img2018.cnblogs.com/blog/1294463/201904/1294463-20190424152346247-1028176075.png"></p><p>　　　　哈哈哈，我大佬说，看到这种简历直接扔垃圾桶吧，原因很简单，你既然那么牛逼还特么需要自己投简历找工作么，早就被挖了，这种一看就是啥经验都没有培训生或者不懂行规的应届生简历写的东西，那么合格的简历刚刚上面已经说了，专业技能模块不能写太多，层次分明就可以，大概这样：</p><p>　　　　<img src="https://img2018.cnblogs.com/blog/1294463/201904/1294463-20190424155304983-1975933906.png">　　　　　</p><p>　　　　暂不评价技术如何，光从这个专业技能在简历的书写规则上是很符合层次分明的，而且一行代表一个领域，总体上来看就是一个标准的JAVA后台开发路线的技术栈，而且从内容上来看，也有一定的侧重点，这样给面试官的感觉就会比较友好，提问方便。与人方便自己方便。</p><p>　　　　如何投递简历</p><p>　　　　拉钩，公司官方网</p><p>　　　　这种看RP了，有时候投出去也大概率不会被看到，称之为海投，收到面试邀请不管怎么样，去了再说，毕竟是一种经历，总能学到东西的，但如果是你比较想去的公司，没有很大得取胜信心，建议别投先，毕竟如果被刷，那就得含泪在等一年了。</p><p>　　　　BOSS直聘，脉脉</p><p>　　　　搜索你想去的公司，然后加HR或者技术官后给他们发简历，本质和BOSS直聘差不多，他们看到你的简历，并且觉得OK，一般都非常愿意帮你内推的，因为内推录用了，是有推荐金的。</p><p>　　　　朋友内推，猎头内推</p><p>　　　　这种获得面试机会几率较高，因为是直推的。</p><p>　　　　　  </p><p>　　关于面试</p><p>　　　　面试需要准备3个部分的东西</p><p>　　　　　　算法智力题笔试</p><p>　　　　　　项目技术面试</p><p>　　　　　　HR跪舔与防坑宝典</p><p>　　　　</p><p>　　　   首先是算法编程题</p><p>　　　　这个没办法的，会就会不会的话，短时间之内也是做不出来的，有些公司硬性规定必须要你写出来，否则免谈，LB遇到个一个很奇葩的一次面试就是，笔试题出了编程题目，没想到一面后面完了，还让你去做一道编程题，二面也是，估计HR面也是。。无可厚非，因为他们认为动手能力才是最重要的，所以对于猿们唯一的办法就是提前刷题，如果不是面试对算法有较高要求的公司，一般的公司只要把LeetCode简单的题目刷了就能做出来大部分的题目，甚至会遇到一模一样的题目，连标点符号也一样哦。</p><p>　　　   然后就是智力题</p><p>　　　　其实也不是什么智力题，网上一搜程序员面试智力题一大推，看来看去也就是那几类问题，头脑比较聪明的猿基本不需要准备。</p><p>　　　　这里重点讲讲技术面　　　　</p><p>　　　　面试官：能写出一段能体现你水平的代码~</p><p>　　　　LB:好的~</p><p>　　　　几秒后~</p><p>1 while{<br>2 　　Scanner scan = new Scanner(System.in);<br>3 　　String question = scan.nextLine();<br>4 　　String answer =question.replace (‘你’, ‘我’). replace (‘吗’, ‘ ‘). replace (‘?’, ‘!’) )；<br>5 　　Sysem.out.println (answer );<br>6 }<br>　　　　面试官：呀，这难道就是…..</p><p>　　　　LB：没错，是失传已久的Artificial Intelligence</p><p>　　　　面试官：你究竟是什么人？</p><p>　　　　LB：阁下莫问出处，这个程序我示范给您看下</p><p>　　　　面试官：好的</p><p>　　　　LB：在吗？</p><p>　　　　电脑：在！</p><p>　　　　LB：你可以人机对话吗？</p><p>　　　　电脑：我可以人机对话！</p><p>　　　　LB：你会自己思考吗？</p><p>　　　　电脑：我会自己思考！</p><p>　　　　面试官也跃跃欲试：你可以滚出去吗？</p><p>　　　　电脑：我可以滚出去！</p><p>　　　　</p><p>  寒冷的冬天，外出的农夫，看见一条冻僵的蛇，于是把蛇带回了家，解冻之后，泡进酒里，蛇终于醒了，看到如此场景，蛇说:我也是醉了。</p><p>　　　　emmm~</p><p>　　　　言归正传，技术面就是看你的技术栈，然后结合项目去提问，并根据项目遇到的问题，要求回答出解决方案，并且根据遇到的问题会继续问深一层或者变形，考察你是否真的对问题进行了仔细的思考和深入的研究，以及问题对应的技术功底是否深厚，所以这里提到的重点是项目结合技术栈，如果你的项目没有用到你写的技术，那么就是扯蛋，那么面试官就会认为这个候选人只是停留在理论基础或者是初学，并没有实践，如果是应届生还说的过去，否则多半会被PASS。</p><p>　　　  那什么基础功底</p><p>　　　  比如问你某些关键字的作用如static</p><p>　　      如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，满意的原因是能看出你确实非常热衷研究技术。这比你在自我评价写一万句本人热爱研究技术，学习能力强之类的废话更有说服力。</p><p>　　 　 又如问你对锁部分的了解　 </p><p>　　 　 1.一般人回答出Synchronized具有多线程的同步作用，能防止多个线性同时访问同一临界资源。</p><p> 2.但是却很少人提到 Synchronized的局限性（无法解決业务层面并发）。</p><p> 3.可以说明锁的用法，如可以创建 Reentrantlock类的可重入锁，而且可以通过其中的lock和unlock方法行加锁和解锁的操作。</p><p>　　　  4.说出可重入锁、公平锁和读写锁，如词锁的含义、公平数的含义，以及在创建 Reentrantlock和 Semaphore时如何通过参数强它是否是公平锁，也可以说明在读写锁中加读锁和写锁的条件，由此介绍通过读写线程吞吐量的做法。</p><p> 5.在协调多个线程处理临界资源时，可以使用锁，但这不是唯一的解决方法，还可以用 Condition和 Semaphore管理多线程竟争的方法。首先，说明这两个类的基本用法如可以通过 Reentrantlock来创建 Condition，过 Condition的awat和 signal来实现类似加锁和解锁的功能，可以通过 Semaphore acquire和 release方法来申请和释放资源。另外，说明用 Condition和 Semaphore的特点（在哪些场景下用它们比较合适）通过 Condition类的相关方法，可以在不同的线程中创建多个阻塞队列，从而能精准的控制唤醒某个阻塞队列的线程，而不是只唤醒默认的阻塞队列的线程，而 Semaphore可以用在多个线程竞争少量资源的场合中。如10张票，20个线程的抢购场景。</p><p>　　　　再如问你对框架里的了解　　　   </p><p>  因为一般的候选人，大多仅仅是能“山寨”别人的代码，也就是说能在现有框架的基础上，照着别人写的流程，扩展出新的功能模块。比如要写个股票挂单的功能模块，是会模仿现有的下单流程，然后从前端到后端再到数据库，依样画葫芦写一遍，最多把功能相关的代码点改掉。其实我们每个人都这样过来的，但在面试时，如果你仅仅表现出这样的能力，就和大多数人的水平差不多了，在这点就没法体现出你的优势了。</p><p>  我们知道，如果单纯使用SSM框架，大多数项目都会有痛点。比如数据库性能差，或者业务模块比较复杂，并发量比较高，用Spring MVC里的Controller无法满足跳转的需求。所以一般还会被问：你除了依照现有框架写业务代码时，还做了哪些改动？</p><p>　　　  对于这个问题，不在乎听到什么回答，只关心回答符不符逻辑。一般只要答对，面试官就会给出“在框架层面有自己的体会，有一定的了解”，否则，就只会给出“只能在项目经理带领下编写框架代码，对框架本身了解不多”。</p><p> 回答例如有：增加了Redis缓存，以避免频繁调用一些不变的数据。或者，在MyBitas的xml里，select语句where条件有isnull，即这个值有就增加一个where条件，对此，会对任何一个where增加一个不带isnull的查询条件，以免该语句当传入参数都是null时，做全表扫描。或者对返回信息做了压缩处理，以增加网络传输性能。</p><p>  小结：</p><p>  技术面试非常重要，这里说的重要不是说对于整个求职过程重要，因为在求职过程哪怕是HR面都有权利决定不要你，所以说没有重不重要的，这里说的重要的是指这是检验你自身水平的能力的考察，通过面试其实可以反映出你的自身很多问题，比如，知识面有了，但是不够全面，或者知识面全了但是不够深入，或者把需求转化为实际产品的能力不足等等，这些东西才是对于你来说是重要的，如果你的能力有了，还会害怕找不到工作吗？这里最怕的就是明知自己能力不足，又不愿意专研学习，还想着高新，只能说你不适合当一名程序员。</p><p>　　　　那么问题来了，我知道自己的情况，但是又不知道努力的方向，或者不知道怎么提升自己，怎么办？如果你能提出这样的问题，LB只能说，你独立解决问题能力确实也是挺差的，因为在我们开发当中，经常会遇到一些需求，都不知道怎么去做，或者用一些完全没接触过用的框架，如果团队中有人熟悉那还好，但是也别指望别人教你太多，所以这个时候就只能靠自己了，无它，需要你通过网上找教学资料（视频，博客，官方网）的方式快速学习，这些资料花几块钱随手可得，然后一步一个脚印慢慢的把产品做出来。</p><p>　　　　</p><p>　　　　HR跪舔与防坑宝典（LB总结了一些）</p><p>　　　　自我介绍　　</p><p>　　　　您好，很荣幸有机会来参加公司的面试</p><p>　　　　1.个人经历（我是谁，我来自哪里，年龄，学历，从业经历）实习加上正职　</p><p>　　　　2.公司为什么要选你（应聘岗位中最重要的3个技能点，说清楚相关经验）我能做好我要做的事情，我相信自己</p><p>　　　　3.你为什么要选这家公司（就公司的产品，文化，影响力等）着重说出你选择的理由如贵公司的高技术开发环境很吸引我，贵公司在近年来市场上很有竞争力，贵公司能够提供一个与众不同的发展道理</p><p>　　　　</p><p>　　　　高频问题　</p><p>　　　　1.上一家公司，你为什么会离职？</p><p>　　　　1.公司很好，但是公司调整了业务，接下来的发展路线和自己的目标不一致，所以要换工作</p><p>　　　　2.工作太清闲，学不到知识，我不怕累，就是想多锻炼自己，想找具有挑战力工作</p><p>　　　　3.公司的管理制度不也是很完善，没有晋升机会，我比较想进步，找一个更好的平台</p><p>　　　　4.我想去优秀的公司，让自己变得更好</p><p>　　　　2.为什么来我们这里？</p><p>　　　　1.对原单位充满感恩，这是我人生中非常重要的经历，我认同原单位领导和文化</p><p>   2.两份工作的本质是一致的，行业和工作性质都有紧密联系</p><p>   3.选择一份新的工作不代表背叛过去，发扬原公司魅力，同时为了寻求更大的成长和突破</p><p>   4.不承诺一份工作干一辈子，保证在我的任期内尽职尽责　</p><p>  3.你怎么看待自己以后的职涯？（包括工作和家庭的分配，怎么平衡家庭和工作的关系、加班、选择一家公司时的考量、地点等）（离职稳定性）</p><p>　　　　我准备在技术领域有所作为，我希望在我3到5年内，具备什么样的素质，在行业内达到什么样的水平，产出什么样的工作成果，将规划量化，具体化 </p><p>　　　　4.对薪资期望（不要直接说数，绝不能表现出没到多少钱或者什么层级我就不去）</p><p>　　　　薪资应该基于你求职行业的市场价格和自身的价值，例如目前这个岗位的平均工资是8K，虽然我刚毕业，但是在我工作期间已经有过两份的相关经验而且都是作为核心成员参与项目，因此可以很快上手这份工作，所以我希望能够在转正后的工资能达到10K等等　</p><p>　　　　5.可以接受降薪吗？（先了解公司薪酬体系，根据行业和自身能力来定位）</p><p>　　　　如果候选人的调性符合（足够官方），可以这么回答：我也了解咋们公司现在的薪资架构，我相信公司会根据我的能力给出一个合理的薪水方案，我相信只要把事情做好，该有的一定会有的对于这样的部门，“ 毕竟贵公司在做一个从来没有人做的这么好的事情，所以肯定是有难度的，肯定是要付出大量努力的 ”</p><p>　　　　6自己觉得自己工作上的短板/优点是什么？</p><p>　　　　1.不能避而不谈，</p><p>　　　　2.不能变相夸自己，</p><p>　　　　3.不能暴露重大缺陷，</p><p>　　　　4.可以将一些能接受能改进的缺点</p><p>　　　　综上：缺点加说明加改进</p><p>　　　　7.说说自己性格上的优缺点（描述一下自己的性格）</p><p>　　　　我不懂得如何拒绝他人，我拉不下面子去指出别人的问题，我做事的时候希望马上就能看到成效，有时候会比较贪心，想同时做好几项工作，我比较慢热，不善于和陌生人打交道，我有意识的让自己在改正，让自己更加有亲和力，我非常在意别人对自己的工作评价，得不到好评就会焦虑，其实我也在开导自己别太功利心了。沉着冷静，条例清楚，立场坚定，顽强向上，乐于助人和关心他人，适应能力等等</p><p>　　　　8.怎么看待加班（你能接受996、997、007吗）？</p><p>　　　　可以接受版本</p><p>　　　　如果候选人的调性符合（足够官方），可以这么回答：我觉得我们要实现梦想，一定是要付出比较多努力的，所以我已经做好了准备，也愿意和小伙伴们一起战斗我是可以加班的，我现在加班强度就是比较大的。因为我喜欢这个事情，我想把这个事情做好。项目忙的时候可能一个月都没有休息日，我觉得要应对这么忙的工作，光有心理准备其实还不够，还要有特别好的身体素质，所以我准备把健身的习惯一直坚持下去</p><p>　　　　不接受版本</p><p>　　　　加班是应该的，不加班也是应该的，没有把事情做完是不应该的，因为能力低完成工作慢造成的加班，并不是一件好事，不加班是能力，加班是态度，能力不够的情况下，态度去补。　　</p><p>　　　　9.你谈恋爱了没？（状态是否稳定，会不会因为感情影响工作，很快结婚，休婚假产假）</p><p>　　　　我还没有谈恋爱，目前不考虑恋爱问题，我希望自己变得更优秀以后，在谈一场稳定的恋爱，所以现在想把主要的精力放在工作上。</p><p>　　　   我已经有男朋友或女朋友，我们都在这个城市工作，目前准备先工作几年，有精力能力了在考虑结婚。　　　</p><p>　　　　10.是否还面试其他公司（HR确认求职意向与诚信度）</p><p>　　　　实话实说，选择名声较大较好的公司来说，职位和现在的求职相思相近，表是自己求职意向专一，还在等候结果　　　</p><p>　　　　11.项目中遇到的最大挑战是什么？怎么解决的？</p><p>　　　　因人而已，需要描述问题产生的原因，查找解决问题的方式，对比那种更加好，遇到什么问题，最终怎么一步一步解决的</p><p>　　　　12.最有成就感的事情是?　　</p><p>　　　　做有挑战性的事情，并且能够做好，或者是坚持一个习惯很久，如坚持写博客，坚持看书</p><p>　　　　13.你有什么问题想问的？　　</p><p>　　　　1.你作为一个资深的CODER，我想知道，你平时是怎么学习技术，有什么好的学习途径，怎么才能做到像你一样强呢？</p><p>　　　　2.公司的业务和技术栈是什么呢？</p><p>　　　　3.技术难点怎么解决，有什么技术支持</p><p>　　　　4.每天有多少时间花在写代码上　</p><p>　　　　14.收到OFFER该问的5个问题</p><p>　　　　1.试用期工资和时间（正常来说合同是3年，试用期是3个月）</p><p>　　　　2.转正考核的方式，转正工资</p><p>　　　　3.工作时间以及加班计算（一周五天工作制，一天8小时）</p><p>　　　　4.培训晋升机制</p><p>　　　　5.福利情况（五险一金，餐补，其他补贴如电脑补贴）</p><p>作者：卓庆森<br>出处：<a href="https://www.cnblogs.com/zhuoqingsen/" target="_blank" rel="noopener">https://www.cnblogs.com/zhuoqingsen/</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品经理如何让程序员放下手中的刀？</title>
      <link href="/2019/05/02/chan-pin-jing-li-ru-he-rang-cheng-xu-yuan-fang-xia-shou-zhong-de-dao/"/>
      <url>/2019/05/02/chan-pin-jing-li-ru-he-rang-cheng-xu-yuan-fang-xia-shou-zhong-de-dao/</url>
      
        <content type="html"><![CDATA[<p>摘要： 友好合作是一门艺术。</p><p>原文：如何让程序员放下手中的刀？<br>作者：Vicky<br>Fundebug经授权转载，版权归原作者所有。</p><p>产品经理和程序员似乎是天生的一对死对头，在面对产品经理不断更改的需求时，脾气再好的程序员也会情绪暴走，如何巧妙地避免这种情况的发生呢？</p><p>众所周知，产品经理跟程序员属于死对头岗位，程序员跟产品经理因为需求打起来的新闻更是屡见不鲜，甚至还出现过程序员暴力砍人的事件，因此一干产品甚至开玩笑说产品这个行业属于高危行业，随时面临着被砍，被套麻袋，被群殴等各种问题。</p><p>虽说没有到描述的这么可怕，但是在面对不断更新需求即将爆发的程序，如何让他们放下手中的刀，确实尤为重要。</p><p>这里主要分析的场是面对需求频繁更改已经处于暴走边缘的程序员如何安抚的场景。</p><p>造成需求不断更改的原因有很多：</p><pre><code>客户突然更改的想法并且要求必须实现。领导突然又看到了一个app并要求按照此app做出更改。之前由于考虑不周后期需要填坑。技术之前就没理解需求，出现了问题需要大改。</code></pre><p>……<br>面对一改再改的需求，脾气再好的程序员也会变身暴躁龙，身为产品狗的我们为了需求能尽快落地，先稳住开发是非常重要的。</p><p>稳住开发是关键</p><h2 id="1-解释需求更改的原因，该认错认错，不是自己的错也先背着（毕竟产品背锅侠）。"><a href="#1-解释需求更改的原因，该认错认错，不是自己的错也先背着（毕竟产品背锅侠）。" class="headerlink" title="1. 解释需求更改的原因，该认错认错，不是自己的错也先背着（毕竟产品背锅侠）。"></a>1. 解释需求更改的原因，该认错认错，不是自己的错也先背着（毕竟产品背锅侠）。</h2><p>需要更改一个需求之前，先让技术知道更改的原因，所有的需求调整都是有理有据，不是灵光一闪。</p><p>产品经理作为贯穿整个产品研发周期的责任人，不管产品出现什么问题，首当其冲站出来，能提高团队的信赖感。</p><h2 id="2-怀柔政策，可以跟技术表现同仇敌忾，一致对外。"><a href="#2-怀柔政策，可以跟技术表现同仇敌忾，一致对外。" class="headerlink" title="2. 怀柔政策，可以跟技术表现同仇敌忾，一致对外。"></a>2. 怀柔政策，可以跟技术表现同仇敌忾，一致对外。</h2><p>这个让技术产生共情心理，告诉他们我们其实是一个战线的，让他们产生一种是自己人的感觉，在后续更好的去说服技术人员进行调整。</p><h2 id="3-肯定技术的能力。"><a href="#3-肯定技术的能力。" class="headerlink" title="3. 肯定技术的能力。"></a>3. 肯定技术的能力。</h2><p>技术是需要认同的，之前工作的心血因为一个调整可能就全部付诸流水了，心理难免要炸。所以一定要先肯定技术的能力，每个技术都是需要夸奖的，适当并且到位的夸奖能降低技术对需求更改的抵触心理。</p><h2 id="4-调整需求的时候，更多的让技术参与这个过程，让他们产生认同感。"><a href="#4-调整需求的时候，更多的让技术参与这个过程，让他们产生认同感。" class="headerlink" title="4. 调整需求的时候，更多的让技术参与这个过程，让他们产生认同感。"></a>4. 调整需求的时候，更多的让技术参与这个过程，让他们产生认同感。</h2><p>我们在确认某个功能需求调整之后，可以先试探的性的跟技术沟通，对于这个功能是否觉得有不合理的地方，是不是应该进行一下调整会更好，让技术发表自己的意见然后慢慢引导，最终导向我们希望的结果，这个过程技术参与进来，会让他们产生一种认同感，这个能更好的让技术接受需求调整这个结果。</p><p>一个产品开发的生命周期会收到来自各个相关方的意见反馈，作为产品经理，除了不可抗力的更改因素外，更多的是要考虑产品的完善性，减少因为前期准备不足导致的后期修补性的更改，这些更改会造成人力成本的提高，以及项目团队的不和谐。</p><p>除了不可抗力因素外，产品能把控的就是在产品规划前期对产品需求的描述，这里会决定开发最终交付的成果是否能达到产品的要求。</p><p>我们分析一下产品跟技术对立对需求想法不一致的源头，两者所占的角度不同，看问题的点也不一样，所以我们最常听到的两者争吵的语句就是以下：</p><p><img src="https://image.fundebug.com/2019-0428-000001.png"></p><p>双方都有自己的立足点，看问题的角度不一样，开始可能是讨论，后面就可能演变为争论。</p><p>产品的立点：</p><pre><code>产品定位；需求场景；用户体验；业务目标。</code></pre><p>技术的立点：</p><pre><code>功能实现；开发难易；后期维护；改动成本。</code></pre><p>前期做好准备<br>双方站在自己的领域范围下，都是有理有据，但是放到一起，产品的开发过程就会举步维艰，产品要这个功能明天实现，技术考虑这个功能起码一个星期甚至说这个需求根本不可能实现，要么砍需求要么改需求，产品也不会答应，你来我往，双方就此展开撕逼。</p><p>这里总结了几点产品经理在前期做好可以减少很多不必要的争吵经验。</p><h2 id="1-需求明确，逻辑清晰，思维缜密，不要让程序猜。"><a href="#1-需求明确，逻辑清晰，思维缜密，不要让程序猜。" class="headerlink" title="1. 需求明确，逻辑清晰，思维缜密，不要让程序猜。"></a>1. 需求明确，逻辑清晰，思维缜密，不要让程序猜。</h2><p>我们在制作产品原型以及编写PRD文档的时候，一定要清晰准确的描述需求目的，所有的需求都是从合理的角度出发，有理有据，减少带个人主观性的语言描述（比如我觉得，我认为），这样的描述会给开发留下一种产品没有从实际出发，所有功能都是拍脑袋想出来的，团队会存在不信任感，也会给开发留下一种能力不行的印象，会导致后面的需求更难落地。</p><p>在对功能做描述的时候，尽可能详细的考虑到多种场景，减少程序的想象空间，我们想的越多，考虑的越全，程序在开发的过程中才能更贴近我们的原本需求。</p><p>比如对一个输入框做说明，我们要考虑的首先是字符长度边界、可支持输入的字符类型（比如手机号码输入就是数字型，但是备注输入就是没有限制）、是否必填、是否有默认值、是否有提示语、错误输入的状态提示等常规性的描述。但是还有一些特殊场景，比如输入文本时，需要自动带出之前输入过的字符，支持直接快速选中快速录入，是否支持粘贴等这些也是要考虑进去的。总之产品前期考虑的越全，程序开发才会更容易，后期也不会因为产品漏了一些场景而产生不要的变更。</p><h2 id="2-尊重并理解技术人员。"><a href="#2-尊重并理解技术人员。" class="headerlink" title="2. 尊重并理解技术人员。"></a>2. 尊重并理解技术人员。</h2><p>调查了一下身边的程序员，最烦听到的来自产品的话语：“这个需求很简单……”荣登榜首，反思一下，主要是因为一部分产品不懂技术，仅通过主观臆断就决定开发周期的长短。</p><p>举个例子：需求是去超市买瓶水；技术要考虑的可能就是路程有多远，走路合适还是需要坐车；一共有几条路可以到超市；水是只有一种还是有多种；如果有很多人一起买水是需要排队还是可以多线程…….</p><p>所以我们再给出需求之后，可以多听听程序的意见，不要通过主观想法开口就是“这个需求很简单……”。同时我们也要多学习一点的技术，不懂就问，平时可以多去一些技术论坛逛逛，也是为了避免一个需求评审完，技术报了3天，结果两小时就做完了这种情况。</p><h2 id="3-小事线上沟通，大事当面沟通，所有的调整都要做好书面记录。"><a href="#3-小事线上沟通，大事当面沟通，所有的调整都要做好书面记录。" class="headerlink" title="3. 小事线上沟通，大事当面沟通，所有的调整都要做好书面记录。"></a>3. 小事线上沟通，大事当面沟通，所有的调整都要做好书面记录。</h2><p>程序在开发的过程中是需要大量进行思考，所以中途被打断，可能前面的准备就前功尽弃了，所有没有什么特别重要的通知的时候，可以通过线上交流，等技术忙完自然会去看。</p><p>对于很重要的事情，一定要当面沟通，不要因为害怕冲突就发邮件通知。书面内容每个人在理解的时候很可能产生误差，最后造成更大的问题。积极主动，加上真诚，和善的态度，是避免冲突的良好开始。</p><p>最重要的一点，所有的调整在通知并确定方案后一定要书面记录，程序每天要接收很多讯息，很多需求我们在沟通后他们不一定会及时去处理，甚至小一点的变动可能会漏掉，所以在沟通清楚后，一定要记录在便于程序查看的位置，也方便后面测试可以了解。</p><p>一般我们可以在原型前增加一页，专门用来记录调整的需求，并且对每个调整的页面后放置快速跳转链接，便于程序快速定位。如下图：</p><p><img src="https://image.fundebug.com/2019-0428-000002.png"></p><h2 id="4-私下交流，合理套路。"><a href="#4-私下交流，合理套路。" class="headerlink" title="4. 私下交流，合理套路。"></a>4. 私下交流，合理套路。</h2><p>人都是有感情的动物，关系亲近也会有利于冲突的减少。很多人喜欢把工作和生活区分对待，但实际上我们的生活大部分时间都在工作，工作中的程序和产品私底下也可能是很好的朋友，了解每个人的工作方式和沟通喜好，更有利于对症下药，当对每个程序进行性格的个体分析后，就可以合理套路了。</p><p>产品跟程序没有职属关系，但是在推动研发按时交付时，就只能靠人格魅力了，平时大家关系很好点点滴滴都看在眼里，程序自然也不想产品为难，能做的就做了，做不完的可能加班也给做了。</p><p>产品经理负责产品各项事物的协调和推进，需要有强大的心脏以及很高的情商，多站在对方的角度看待问题，做出正确的判断，专业素质越强，程序才能越信服，沟通才会更加顺畅。    </p><p>作者: Fundebug<br>来源：<a href="https://blog.fundebug.com/2019/04/28/how-does-product-manager-cooperate-with-programmer/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/04/28/how-does-product-manager-cooperate-with-programmer/</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 程序猿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018秋招面经</title>
      <link href="/2019/05/01/2018-qiu-zhao-mian-jing/"/>
      <url>/2019/05/01/2018-qiu-zhao-mian-jing/</url>
      
        <content type="html"><![CDATA[<p>秋招已经结束很久了，终于有时间给自己的秋招进行一个简单的总结。自己在找工作的每一天上午做的第一件事就是打开牛客，看看上面的最新动态（了解一些招聘信息、别人发的面经），<br>从中受益良多，有幸拿到了华为、贝壳、百度、阿里巴巴……等公司的offer，所以现在把自己的经历简单的总结一下，希望可以帮到有需要的朋友。</p><h1 id="一、阿里巴巴"><a href="#一、阿里巴巴" class="headerlink" title="一、阿里巴巴"></a>一、阿里巴巴</h1><p>阿里巴巴面试了两个部门，说多了都是眼泪……</p><h2 id="一面（8-9）"><a href="#一面（8-9）" class="headerlink" title="一面（8.9）"></a>一面（8.9）</h2><p>http协议2.0和1.1的区别<br>什么时候发生stackOverflow、一个线程的工作栈是多大？哪些区域会发生OOM<br>Jvm的线程和操作系统线程的关系<br>hashmap的实现，怎么解决冲突，其他解决冲突的方法，使用过哪些线程安全的集合，优先队列的实现（怎么实现排序）<br>TreeMap的实现，红黑树的优点，介绍一下其他的平衡树，数据库索引为什么采用B+树</p><h2 id="二面（8-16）"><a href="#二面（8-16）" class="headerlink" title="二面（8.16）"></a>二面（8.16）</h2><p>自我介绍，实验室的研究方向，自己的研究方向。<br>详细讲一下项目，自己的贡献，当前怎么改进项目，还有那些可以改进的地方。<br>github上的贡献。</p><h2 id="三面（8-23）"><a href="#三面（8-23）" class="headerlink" title="三面（8.23）"></a>三面（8.23）</h2><p>自我介绍<br>讲一件印象最深刻的事<br>项目是怎么改进的，别人如何访问你的后台代码<br>tomcat的一次访问过程，怎么实现文件断点续传<br>如何实现手机通讯录排行的功能，treemap的实现，插入节点的时间复杂度，hashmap的插入时间复杂度。</p><h2 id="四面（8-24）"><a href="#四面（8-24）" class="headerlink" title="四面（8.24）"></a>四面（8.24）</h2><p>自己的详细介绍（家庭情况），大学生活，最成功的一件事。<br>高考分数，大学、研究生学习情况等等。</p><h2 id="一面（9-4）"><a href="#一面（9-4）" class="headerlink" title="一面（9.4）"></a>一面（9.4）</h2><p>晚上九点多接到了阿里的面试电话，因为之前已经面试过，所以这次就聊了大概二十分钟。<br>介绍项目，消息队列的使用，多线程怎么使用消息队列，生产者消费者模型的实现。<br>Java中的并发，synchronize关键字的作用，修饰方法、变量和类的区别。<br>最后问了一下部门的主要业务，面试官很耐心的讲解了五分钟。</p><h2 id="二面（9-5）"><a href="#二面（9-5）" class="headerlink" title="二面（9.5）"></a>二面（9.5）</h2><p>第二天上午又接到了面试官的面试电话。这次是一个leader，上来让讲述一下项目中的流程，实现上的细节，改进方案。<br>最后问了一个场景题目：题目太复杂了不好描述，在这就不赘述了，总之需要看一下大数据量下高并发的场景题目，然后才可以游刃有余的回答这类问题。</p><h2 id="三面（9-6）HR"><a href="#三面（9-6）HR" class="headerlink" title="三面（9.6）HR"></a>三面（9.6）HR</h2><p>这次面试约定的时间是中午，但是由于上午的网易面试拖到了中午12点多才开始，所以一点的时候正在面试网易，无奈阿里的电话一点准时过来了，在向网易的面试官解释了情况后就暂停了网易的面试。<br>自我介绍，平时怎么学习，有发表过论文吗？<br>介绍一下项目中的难点（HR小姐姐说了不要使用太复杂的专业术语，她可能听不懂），然后针对项目问了几个问题，你们之前产品的用户量是多少？项目还可以改进吗，是你们的技术问题，还是其他问题导致项目存在bug，如何提升项目的效果。<br>最后让我提问一个问题。</p><h2 id="四面（9-8）"><a href="#四面（9-8）" class="headerlink" title="四面（9.8）"></a>四面（9.8）</h2><p>约定的面试时间是12点（居然是晚上12点），难怪中午12点一直没有等到面试电话。<br>讲述一下项目的难点，自己怎么改进的，面试官对改进方案感到困惑，说这方案效果上会存在问题吗？只好给面试官具体介绍了一下。你们的项目和其他的项目有什么区别，跟其他的公司的技术相比呢？<br>用到了哪些技术栈？（这在华为面试的时候问到了，所以自己就补了补该知识）<br>自己未来的发展规划，自然语言领域未来的发展和和可能遇到的问题。</p><h1 id="二、CVTE"><a href="#二、CVTE" class="headerlink" title="二、CVTE"></a>二、CVTE</h1><h2 id="一面（8-7）"><a href="#一面（8-7）" class="headerlink" title="一面（8.7）"></a>一面（8.7）</h2><p>介绍项目，怎么分词的<br>redis在哪儿使用，怎么更新缓存，redis的数据类型<br>用过哪些关系数据库？索引的好处，索引是否是越多越好<br>hasmap的原理<br>服务器访问量大的时候怎么处理，有没有了解负载均衡<br>Spring框架， 动态代理的实现方式及比较<br>自己的研究方向，为什么选择后台开发</p><h2 id="二面（8-13）"><a href="#二面（8-13）" class="headerlink" title="二面（8.13）"></a>二面（8.13）</h2><p>自我介绍<br>介绍一下项目，自己负责哪一部分，最难的地方在哪儿<br>用过那种数据库，写个sql语句，存储引擎的区别，为什么用Innodb<br>索引的用途，越多越好吗？为什么可以加快查询的速度，索引失效的场景，联合索引的使用<br>悲观锁、乐观锁的区别和应用场景，哪些框架使用了悲观锁和乐观锁<br>java的五个运行时异常，String为什么用final修饰</p><h1 id="三、猿辅导"><a href="#三、猿辅导" class="headerlink" title="三、猿辅导"></a>三、猿辅导</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>自我介绍，介绍自己的项目。简单问了之前的项目，然后问对游戏开发有没有了解。<br>知道并发吗，如何实现，如何检测死锁。<br>jvm了解吗，垃圾回收的四种引用介绍一下；如何通过jdk自带的工具判断程序发生死锁的位置。<br>haspmap为什么是线程不安全的<br>jdk 1.7 和1.8的区别</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>介绍项目，自己主要负责哪一块。<br>对游戏有没有了解<br>并发（线程池及实现原理）<br>jvm中的类的加载，什么时候触发fullGC<br>Java集合类，list、arrayList的实现，初始大小，空间不够的时候如何扩容；hashmap除了线程不安全造成数据不一致之外，有没有可能造成程序异常<br>判断单链表中有没有环。<br>为什么选择游戏开发这个行业。</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>职业规划，毕业之后愿意来这边工作吗？<br>为什么选择Java服务端开发这个岗位？<br>为什么选择我们公司？<br>有什么问题问我的吗？</p><p>作者：greenbird<br>链接：<a href="https://www.nowcoder.com/discuss/151562" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/151562</a><br>来源：牛客网</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试中常问的Linux命令</title>
      <link href="/2019/04/30/mian-shi-zhong-chang-wen-de-linux-ming-ling/"/>
      <url>/2019/04/30/mian-shi-zhong-chang-wen-de-linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="一、文件和目录"><a href="#一、文件和目录" class="headerlink" title="一、文件和目录"></a>一、文件和目录</h3><h4 id="1-cd命令（它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径）"><a href="#1-cd命令（它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径）" class="headerlink" title="1. cd命令（它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径）"></a>1. cd命令（它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径）</h4><pre><code>cd /home    进入 &apos;/ home&apos; 目录cd ..            返回上一级目录 cd ../..         返回上两级目录 cd               进入个人的主目录 cd ~user1   进入个人的主目录 cd -             返回上次所在的目录 </code></pre><h4 id="2-pwd命令"><a href="#2-pwd命令" class="headerlink" title="2. pwd命令"></a>2. pwd命令</h4><pre><code>pwd 显示工作路径</code></pre><h4 id="3-ls命令-（查看文件与目录的命令，list之意）"><a href="#3-ls命令-（查看文件与目录的命令，list之意）" class="headerlink" title="3. ls命令 （查看文件与目录的命令，list之意）"></a>3. ls命令 （查看文件与目录的命令，list之意）</h4><pre><code>ls 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 列出全部文件，包含隐藏文件ls -R 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来  ls *[0-9]* 显示包含数字的文件名和目录名 </code></pre><h4 id="4-cp-命令（用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下）"><a href="#4-cp-命令（用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下）" class="headerlink" title="4. cp 命令（用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下）"></a>4. cp 命令（用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下）</h4><pre><code>-a ：将文件的特性一起复制-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行-r ：递归持续复制，用于目录的复制行为-u ：目标文件与源文件有差异时才会复制5.  mv命令（用于移动文件、目录或更名，move之意）-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件已经存在，就会询问是否覆盖-u ：若目标文件已经存在，且比目标文件新，才会更新6.  rm 命令（用于删除文件或目录，remove之意）-f ：就是force的意思，忽略不存在的文件，不会出现警告消息-i ：互动模式，在删除前会询问用户是否操作-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</code></pre><h3 id="二、查看文件内容"><a href="#二、查看文件内容" class="headerlink" title="二、查看文件内容"></a>二、查看文件内容</h3><h4 id="7-cat命令（用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用）"><a href="#7-cat命令（用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用）" class="headerlink" title="7. cat命令（用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用）"></a>7. cat命令（用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用）</h4><pre><code>cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 cat -n file1 标示文件的行数 more file1 查看一个长文件的内容 head -n 2 file1 查看一个文件的前两行 tail -n 2 file1 查看一个文件的最后两行 tail -n +1000 file1  从1000行开始显示，显示1000行以后的cat filename | head -n 3000 | tail -n +1000  显示1000行到3000行cat filename | tail -n +3000 | head -n 1000  从第3000行开始，显示1000(即显示3000~3999行)</code></pre><h3 id="三、文件搜索"><a href="#三、文件搜索" class="headerlink" title="三、文件搜索"></a>三、文件搜索</h3><h4 id="8-find命令（）"><a href="#8-find命令（）" class="headerlink" title="8. find命令（）"></a>8. find命令（）</h4><pre><code>find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 删除大于50M的文件：find /var/mail/ -size +50M -exec rm {} ＼;</code></pre><h3 id="四、文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#四、文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="四、文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>四、文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><h4 id="9-chmod-命令"><a href="#9-chmod-命令" class="headerlink" title="9. chmod 命令"></a>9. chmod 命令</h4><pre><code>ls -lh 显示权限 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r，4 ）、写(w，2)和执行(x，1)的权限 chmod go-rwx directory1  删除群组(g)与其他人(o)对目录的读写执行权限 </code></pre><h4 id="10-chown-命令（改变文件的所有者）"><a href="#10-chown-命令（改变文件的所有者）" class="headerlink" title="10. chown 命令（改变文件的所有者）"></a>10. chown 命令（改变文件的所有者）</h4><pre><code>chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chown user1:group1 file1 改变一个文件的所有人和群组属性 </code></pre><h4 id="11-chgrp-命令（改变文件所属用户组）"><a href="#11-chgrp-命令（改变文件所属用户组）" class="headerlink" title="11. chgrp 命令（改变文件所属用户组）"></a>11. chgrp 命令（改变文件所属用户组）</h4><pre><code>chgrp group1 file1 改变文件的群组 </code></pre><h3 id="五、文本处理"><a href="#五、文本处理" class="headerlink" title="五、文本处理"></a>五、文本处理</h3><h4 id="12-grep-命令（分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等）"><a href="#12-grep-命令（分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等）" class="headerlink" title="12. grep 命令（分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等）"></a>12. grep 命令（分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等）</h4><pre><code>grep Aug /var/log/messages  在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9]  /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 </code></pre><h4 id="13-paste-命令"><a href="#13-paste-命令" class="headerlink" title="13. paste 命令"></a>13. paste 命令</h4><pre><code>paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 </code></pre><h4 id="14-sort-命令"><a href="#14-sort-命令" class="headerlink" title="14. sort 命令"></a>14. sort 命令</h4><pre><code>sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) </code></pre><h4 id="15-comm-命令"><a href="#15-comm-命令" class="headerlink" title="15. comm 命令"></a>15. comm 命令</h4><pre><code>comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </code></pre><h3 id="六、打包和压缩文件"><a href="#六、打包和压缩文件" class="headerlink" title="六、打包和压缩文件"></a>六、打包和压缩文件</h3><h4 id="16-tar-命令（对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压）"><a href="#16-tar-命令（对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压）" class="headerlink" title="16. tar 命令（对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压）"></a>16. tar 命令（对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压）</h4><pre><code>-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称查询：tar -jtv -f filename.tar.bz2解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 zip file1.zip file1 创建一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 </code></pre><h3 id="七、系统和关机-系统的关机、重启以及登出"><a href="#七、系统和关机-系统的关机、重启以及登出" class="headerlink" title="七、系统和关机 (系统的关机、重启以及登出 )"></a>七、系统和关机 (系统的关机、重启以及登出 )</h3><pre><code>shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 time 测算一个命令（即程序）的执行时间</code></pre><h3 id="八、进程相关的命令"><a href="#八、进程相关的命令" class="headerlink" title="八、进程相关的命令"></a>八、进程相关的命令</h3><p>jps命令 （显示当前系统的java进程情况，及其id号）<br>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p><p>ps命令 （用于将某个时间点的进程运行情况选取下来并输出，process之意）<br>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出</p><p>ps aux # 查看系统所有的进程数据<br>ps ax # 查看不与terminal有关的所有进程<br>ps -lA # 查看系统所有的进程数据<br>ps axjf # 查看连同一部分进程树状态</p><p>kill命令 （用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用）<br>killall命令  （向一个命令启动的进程发送一个信号）</p><p>top命令 是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><p>如何杀死进程：<br>（1）图形化界面的方式<br>（2）kill -9 pid  （-9表示强制关闭）<br>（3）killall -9 程序的名字<br>（4）pkill 程序的名字</p><p>查看进程端口号：<br>netstat -tunlp|grep 端口号</p><h3 id="九、普通文件和目录文件的区别"><a href="#九、普通文件和目录文件的区别" class="headerlink" title="九、普通文件和目录文件的区别"></a>九、普通文件和目录文件的区别</h3><h4 id="9-1-文件的类型"><a href="#9-1-文件的类型" class="headerlink" title="9.1 文件的类型"></a>9.1 文件的类型</h4><pre><code>Linux下面一切皆文件，配置是文件，设备是文件，目录也是特殊的文件，文件有如下几种：</code></pre><p>d：目录文件的标识是，<br>-：普通文件标识，<br>l：软连接文件，亦称符号链接文件；<br>b，块文件，是设备文件的一种（还有另一种），b是block的简写。<br>c，字符文件，也是设备文件的一种，c是character的文件。</p><h4 id="9-2-普通文件和目录文件"><a href="#9-2-普通文件和目录文件" class="headerlink" title="9.2 普通文件和目录文件"></a>9.2 普通文件和目录文件</h4><pre><code>普通文件：存储普通数据，一般就是字符串。目录文件：存储了一张表，该表就是该目录文件下，所有文件名和inode的映射关系。</code></pre><h4 id="9-3-权限的区别"><a href="#9-3-权限的区别" class="headerlink" title="9.3 权限的区别"></a>9.3 权限的区别</h4><pre><code>对于普通文件来说，rwx的意义是：r：可以获得这个普通文件的名字和内容。w：可以修改这个文件的内容和文件名。可以删除该文件。x：该文件是否具有被执行的权限。对于目录文件来说，rwx的意义是：r：表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名。 就可以利用 ls 这个命令将该目录的内容列表显示出来， 必须这个目录有x的权限，才可以进入这个目录。w：移动该目录结构列表的权限（建立新的文件与目录、删除已经存在的文件与目录、更名、移动位置）。x：目录不可以被执行，目录的x代表的是用户能否进入该目录成为工作目录。</code></pre><p>来源: <a href="http://t.cn/EqTIhES" target="_blank" rel="noopener">http://t.cn/EqTIhES</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 查询优化</title>
      <link href="/2019/04/29/mysql-cha-xun-you-hua/"/>
      <url>/2019/04/29/mysql-cha-xun-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么影响了数据库查询速度"><a href="#一、什么影响了数据库查询速度" class="headerlink" title="一、什么影响了数据库查询速度"></a>一、什么影响了数据库查询速度</h1><h2 id="1-1-影响数据库查询速度的四个因素"><a href="#1-1-影响数据库查询速度的四个因素" class="headerlink" title="1.1 影响数据库查询速度的四个因素"></a>1.1 影响数据库查询速度的四个因素</h2><h2 id="1-2-风险分析"><a href="#1-2-风险分析" class="headerlink" title="1.2 风险分析"></a>1.2 风险分析</h2><p>QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>Tips：最好不要在主库上数据库备份，大型活动前取消这样的计划。</p><pre><code>1、效率低下的sql：超高的QPS与TPS。2、大量的并发：数据连接数被占满（max_connection默认100，一般把连接数设置得大一些）。3、并发量:同一时刻数据库服务器处理的请求数量4、超高的CPU使用率：CPU资源耗尽出现宕机。5、磁盘IO：磁盘IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。    </code></pre><h2 id="1-3-网卡流量：如何避免无法连接数据库的情况"><a href="#1-3-网卡流量：如何避免无法连接数据库的情况" class="headerlink" title="1.3 网卡流量：如何避免无法连接数据库的情况"></a>1.3 网卡流量：如何避免无法连接数据库的情况</h2><pre><code>1、减少从服务器的数量（从服务器会从主服务器复制日志）2、进行分级缓存（避免前端大量缓存失效）3、避免使用select * 进行查询4、分离业务网络和服务器网络    </code></pre><h2 id="1-4-大表带来的问题（重要）"><a href="#1-4-大表带来的问题（重要）" class="headerlink" title="1.4 大表带来的问题（重要）"></a>1.4 大表带来的问题（重要）</h2><h3 id="1-4-1-大表的特点"><a href="#1-4-1-大表的特点" class="headerlink" title="1.4.1 大表的特点"></a>1.4.1 大表的特点</h3><pre><code>1、记录行数巨大，单表超千万2、表数据文件巨大，超过10个G</code></pre><h3 id="1-4-2-大表的危害"><a href="#1-4-2-大表的危害" class="headerlink" title="1.4.2 大表的危害"></a>1.4.2 大表的危害</h3><p>1.慢查询：很难在短时间内过滤出需要的数据<br>    查询字区分度低 -&gt; 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘io -&gt; 降低磁盘效率</p><p>2.对DDL影响：<br>    建立索引需要很长时间：<br>        MySQL -v&lt;5.5 建立索引会锁表<br>        MySQL -v&gt;=5.5 建立索引会造成主从延迟（mysql建立索引，先在组上执行，再在库上执行）<br>    修改表结构需要长时间的锁表：会造成长时间的主从延迟(‘480秒延迟’)</p><h3 id="1-4-3-如何处理数据库上的大表"><a href="#1-4-3-如何处理数据库上的大表" class="headerlink" title="1.4.3 如何处理数据库上的大表"></a>1.4.3 如何处理数据库上的大表</h3><p>分库分表把一张大表分成多个小表<br>    难点：<br>        1.分表主键的选择<br>        2.分表后跨分区数据的查询和统计</p><h2 id="1-5-大事务带来的问题（重要）"><a href="#1-5-大事务带来的问题（重要）" class="headerlink" title="1.5 大事务带来的问题（重要）"></a>1.5 大事务带来的问题（重要）</h2><h3 id="1-5-1-什么是事务"><a href="#1-5-1-什么是事务" class="headerlink" title="1.5.1 什么是事务"></a>1.5.1 什么是事务</h3><pre><code>1.事务是数据库系统区别于其他一切文件系统的重要特性之一2.事务是一组具有原子性的SQL语句，或是一个独立的工作单元</code></pre><h3 id="1-5-2事务的ACID属性"><a href="#1-5-2事务的ACID属性" class="headerlink" title="1.5.2事务的ACID属性"></a>1.5.2事务的ACID属性</h3><p>1、原子性（atomicity)：全部成功，全部回滚失败。银行存取款。<br>2、一致性（consistent)：银行转账的总金额不变。<br>3、隔离性（isolation)：</p><pre><code>隔离性等级：未提交读(READ UNCOMMITED) 脏读,两个事务之间互相可见；已提交读(READ COMMITED)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据。可重复读(REPEATABLE READ) InnoDB的默认隔离等级。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的！可串行化（SERIALIZABLE） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。</code></pre><p>查看系统的事务隔离级别：show variables like ‘%iso%’;<br>开启一个新事务：begin;<br>提交一个事务：commit;<br>修改事物的隔离级别：set session tx_isolation=’read-committed’;</p><p>4、持久性(DURABILITY)：从数据库的角度的持久性，磁盘损坏就不行了</p><p><img src="https://image-static.segmentfault.com/272/860/2728609336-5aa3a6c87bf08_articlex"></p><p>redo log机制保证事务更新的一致性和持久性</p><h3 id="1-5-3-大事务"><a href="#1-5-3-大事务" class="headerlink" title="1.5.3 大事务"></a>1.5.3 大事务</h3><p>运行时间长，操作数据比较多的事务；</p><p>风险：锁定数据太多，回滚时间长，执行时间长。</p><pre><code>1.锁定太多数据，造成大量阻塞和锁超时；2.回滚时所需时间比较长，且数据仍然会处于锁定；3.如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。</code></pre><p>解决思路：</p><pre><code>1.避免一次处理太多数据，可以分批次处理；2.移出不必要的SELECT操作，保证事务中只有必要的写操作。</code></pre><h1 id="二、什么影响了MySQL性能（非常重要）"><a href="#二、什么影响了MySQL性能（非常重要）" class="headerlink" title="二、什么影响了MySQL性能（非常重要）"></a>二、什么影响了MySQL性能（非常重要）</h1><h2 id="2-1-影响性能的几个方面"><a href="#2-1-影响性能的几个方面" class="headerlink" title="2.1 影响性能的几个方面"></a>2.1 影响性能的几个方面</h2><pre><code>1.服务器硬件。2.服务器系统（系统参数优化）。3.存储引擎。     MyISAM： 不支持事务，表级锁。    InnoDB: 支持事务，支持行级锁，事务ACID。4.数据库参数配置。5.数据库结构设计和SQL语句。（重点优化）</code></pre><h2 id="2-2-MySQL体系结构"><a href="#2-2-MySQL体系结构" class="headerlink" title="2.2 MySQL体系结构"></a>2.2 MySQL体系结构</h2><p>分三层：客户端-&gt;服务层-&gt;存储引擎</p><p><img src="https://image-static.segmentfault.com/550/276/550276287-5aa5dce29909b_articlex"></p><p>1.MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!<br>2.所有跨存储引擎的功能都是在服务层实现的。<br>3.MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。</p><h2 id="2-3-InnoDB存储引擎"><a href="#2-3-InnoDB存储引擎" class="headerlink" title="2.3 InnoDB存储引擎"></a>2.3 InnoDB存储引擎</h2><pre><code>MySQL5.5及之后版本默认的存储引擎：InnoDB。</code></pre><h3 id="2-3-1-InnoDB使用表空间进行数据存储。"><a href="#2-3-1-InnoDB使用表空间进行数据存储。" class="headerlink" title="2.3.1 InnoDB使用表空间进行数据存储。"></a>2.3.1 InnoDB使用表空间进行数据存储。</h3><p>show variables like ‘innodb_file_per_table</p><p>  如果innodb_file_per_table 为 ON 将建立独立的表空间，文件为tablename.ibd；</p><p>  如果innodb_file_per_table 为 OFF 将数据存储到系统的共享表空间，文件为ibdataX（X为从1开始的整数）；</p><p>  .frm ：是服务器层面产生的文件，类似服务器层的数据字典，记录表结构。</p><h3 id="2-3-2-MySQL5-5默认-系统表空间与-MySQL5-6及以后默认-独立表空间"><a href="#2-3-2-MySQL5-5默认-系统表空间与-MySQL5-6及以后默认-独立表空间" class="headerlink" title="2.3.2 (MySQL5.5默认)系统表空间与(MySQL5.6及以后默认)独立表空间"></a>2.3.2 (MySQL5.5默认)系统表空间与(MySQL5.6及以后默认)独立表空间</h3><pre><code>1.1 系统表空间无法简单的收缩文件大小，造成空间浪费，并会产生大量的磁盘碎片。1.2 独立表空间可以通过optimeze table 收缩系统文件，不需要重启服务器也不会影响对表的正常访问。2.1 如果对多个表进行刷新时，实际上是顺序进行的，会产生IO瓶颈。2.2 独立表空间可以同时向多个文件刷新数据。</code></pre><p>强烈建立对Innodb 使用独立表空间，优化什么的更方便，可控。</p><h3 id="2-3-3-系统表空间的表转移到独立表空间中的方法"><a href="#2-3-3-系统表空间的表转移到独立表空间中的方法" class="headerlink" title="2.3.3 系统表空间的表转移到独立表空间中的方法"></a>2.3.3 系统表空间的表转移到独立表空间中的方法</h3><pre><code>1、使用mysqldump 导出所有数据库数据（存储过程、触发器、计划任务一起都要导出 ）可以在从服务器上操作。2、停止MYsql 服务器，修改参数（my.cnf加入innodb_file_per_table），并删除Inoodb相关文件（可以重建Data目录）。3、重启MYSQL，并重建Innodb系统表空间。4、 重新导入数据。或者 Alter table 同样可以的转移，但是无法回收系统表空间中占用的空间。</code></pre><h2 id="2-4-InnoDB存储引擎的特性"><a href="#2-4-InnoDB存储引擎的特性" class="headerlink" title="2.4 InnoDB存储引擎的特性"></a>2.4 InnoDB存储引擎的特性</h2><h3 id="2-4-1-特性一：事务性存储引擎及两个特殊日志类型：Redo-Log-和-Undo-Log"><a href="#2-4-1-特性一：事务性存储引擎及两个特殊日志类型：Redo-Log-和-Undo-Log" class="headerlink" title="2.4.1 特性一：事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log"></a>2.4.1 特性一：事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log</h3><pre><code>1.Innodb 是一种事务性存储引擎。2.完全支持事务的ACID特性。3.支持事务所需要的两个特殊日志类型：Redo Log 和Undo LogRedo Log：实现事务的持久性(已提交的事务)。Undo Log：未提交的事务，独立于表空间，需要随机访问，可以存储在高性能io设备上。</code></pre><p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</p><h3 id="2-4-2-特性二：支持行级锁"><a href="#2-4-2-特性二：支持行级锁" class="headerlink" title="2.4.2 特性二：支持行级锁"></a>2.4.2 特性二：支持行级锁</h3><pre><code>1.InnoDB支持行级锁。2.行级锁可以最大程度地支持并发。3.行级锁是由存储引擎层实现的。</code></pre><h2 id="2-5-什么是锁"><a href="#2-5-什么是锁" class="headerlink" title="2.5 什么是锁"></a>2.5 什么是锁</h2><h3 id="2-5-1-锁"><a href="#2-5-1-锁" class="headerlink" title="2.5.1 锁"></a>2.5.1 锁</h3><pre><code>1.锁对主要作用是管理共享资源的并发访问2.锁用于实现事务的隔离性</code></pre><h3 id="2-5-2-锁类型"><a href="#2-5-2-锁类型" class="headerlink" title="2.5.2 锁类型"></a>2.5.2 锁类型</h3><p><img src="https://image-static.segmentfault.com/424/147/4241479998-5aa5e739c52af_articlex"></p><h3 id="2-5-3-锁的粒度"><a href="#2-5-3-锁的粒度" class="headerlink" title="2.5.3 锁的粒度"></a>2.5.3 锁的粒度</h3><p>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关</p><p><img src="https://image-static.segmentfault.com/229/671/2296718656-5aa5eea9d3fb0_articlex"></p><p>  将table_name加表级锁命令：lock table table_name write; 写锁会阻塞其它用户对该表的‘读写’操作，直到写锁被释放：unlock tables；</p><pre><code>1.锁的开销越大，粒度越小，并发度越高。2.表级锁通常是在服务器层实现的。3.行级锁是存储引擎层实现的。innodb的锁机制，服务器层是不知道的</code></pre><h3 id="2-5-4-阻塞和死锁"><a href="#2-5-4-阻塞和死锁" class="headerlink" title="2.5.4 阻塞和死锁"></a>2.5.4 阻塞和死锁</h3><pre><code>（1）阻塞是由于资源不足引起的排队等待现象。（2）死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两对象正持有的，导致两对象无法完成操作，且所持资源无法释放。</code></pre><h2 id="2-6-如何选择正确的存储引擎"><a href="#2-6-如何选择正确的存储引擎" class="headerlink" title="2.6 如何选择正确的存储引擎"></a>2.6 如何选择正确的存储引擎</h2><pre><code>参考条件：    1.事务    2.备份(Innobd免费在线备份)    3.崩溃恢复    4.存储引擎的特有特性总结:Innodb大法好。注意:尽量别使用混合存储引擎，比如回滚会出问题在线热备问题。</code></pre><h2 id="2-7-配置参数"><a href="#2-7-配置参数" class="headerlink" title="2.7 配置参数"></a>2.7 配置参数</h2><h3 id="2-7-1-内存配置相关参数"><a href="#2-7-1-内存配置相关参数" class="headerlink" title="2.7.1 内存配置相关参数"></a>2.7.1 内存配置相关参数</h3><p>确定可以使用的内存上限。</p><p>内存的使用上限不能超过物理内存，否则容易造成内存溢出；（对于32位操作系统，MySQL只能试用3G以下的内存。）</p><p>确定MySQL的每个连接单独使用的内存。</p><p>sort_buffer_size #定义了每个线程排序缓存区的大小，MySQL在有查询、需要做排序操作时才会为每个缓冲区分配内存（直接分配该参数的全部内存）；<br>join_buffer_size #定义了每个线程所使用的连接缓冲区的大小，如果一个查询关联了多张表，MySQL会为每张表分配一个连接缓冲，导致一个查询产生了多个连接缓冲；<br>read_buffer_size #定义了当对一张MyISAM进行全表扫描时所分配读缓冲池大小，MySQL有查询需要时会为其分配内存，其必须是4k的倍数；<br>read_rnd_buffer_size #索引缓冲区大小，MySQL有查询需要时会为其分配内存，只会分配需要的大小。</p><pre><code>注意：以上四个参数是为一个线程分配的，如果有100个连接，那么需要×100。</code></pre><p>MySQL数据库实例：</p><p>　①MySQL是单进程多线程（而oracle是多进程），也就是说MySQL实例在系统上表现就是一个服务进程，即进程；</p><p>　②MySQL实例是线程和内存组成，实例才是真正用于操作数据库文件的；</p><p>一般情况下一个实例操作一个或多个数据库；集群情况下多个实例操作一个或多个数据库。</p><pre><code>如何为缓存池分配内存：Innodb_buffer_pool_size，定义了Innodb所使用缓存池的大小，对其性能十分重要，必须足够大，但是过大时，使得Innodb 关闭时候需要更多时间把脏页从缓冲池中刷新到磁盘中；</code></pre><p>总内存-（每个线程所需要的内存*连接数）-系统保留内存</p><pre><code>key_buffer_size，定义了MyISAM所使用的缓存池的大小，由于数据是依赖存储操作系统缓存的，所以要为操作系统预留更大的内存空间；</code></pre><p>select sum(index_length) from information_schema.talbes where engine=’myisam’</p><pre><code>注意：即使开发使用的表全部是Innodb表，也要为MyISAM预留内存，因为MySQL系统使用的表仍然是MyISAM表。max_connections 控制允许的最大连接数， 一般2000更大。不要使用外键约束保证数据的完整性。</code></pre><h2 id="2-8-性能优化顺序"><a href="#2-8-性能优化顺序" class="headerlink" title="2.8 性能优化顺序"></a>2.8 性能优化顺序</h2><pre><code>从上到下：    数据库结构设计和SQL语句。    数据库存储引擎的选择和参数配置    系统选择及优化    硬件升级    </code></pre><p>来源：<a href="https://segmentfault.com/a/1190000013672421" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013672421</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漫画】996对程序员的伤害，一看你就懂</title>
      <link href="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/"/>
      <url>/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/</url>
      
        <content type="html"><![CDATA[<p>我在一家互联网大厂上班，我很骄傲，有一天，上司递给我一张协议<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/1.jpg"><br>我知道公司的难处，想到自己还背着房贷，只能接受<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/2.jpg"><br>上司很赏识我，委派了重要项目给我<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/3.jpg"><br>不过因为家住的远，9点下班，加上1个半小时车程，回到家都接近晚上11点了<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/4.jpg"><br>以前下班，我会跟女朋友吃饭，玩一会游戏，然后才是睡觉<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/5.jpg"><br>现在直接睡觉<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/6.jpg"><br>以前星期六，我会和朋友爬山，或陪女友逛街<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/7.jpg"><br>现在周六没了，周日只想补觉<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/8.jpg"><br>1年过去，我少陪了女朋友264次晚饭（22*12）。</p><p>因为一起做的事情越来越少，我们之间好像慢慢少了一些默契。</p><p>朋友再没邀过我爬山了，因为每次我都回“加班中”。</p><p>PS4也早就挂闲鱼卖掉了，当然是女朋友卖的，我哪有时间。</p><p>我感觉自己像从没出过公司<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/9.jpg"><br>有一次做梦，我梦到自己变成哥斯拉，喷火把公司和老板烧了<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/10.jpg"><br>半夜梦醒，去完夜尿却赶紧打开电脑，看看老板有无回复邮件<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/11.jpg"><br>渐渐地，我胖了，看着自己2年前的照片，咦？原来我也瘦过<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/12.jpg"><br>有一天，我发现隔壁同事在哭，急忙安慰，问起原因，才知道他错过了母亲的葬礼。<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/13.jpg"><br>还好还好，我只是错过几次好友的婚礼。</p><p>我还年轻，身体壮的很，但奇怪的是最近小小感冒都会发烧，吃根辣条也能得肠胃炎。<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/14.jpg"><br>应该是天气原因，我安慰自己</p><p>我是父母逢人便夸的骄傲<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/15.jpg"><br>但这个骄傲，已经好几年没陪父母一起看电视了<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/16.jpg" title="}"><br>是不是，应该请个假回家看看父母？<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/17.jpg" title="}"><br>还是…等过了这段时间吧</p><p>女朋友想要小孩，说好可爱！小孩？我会有时间..照顾他么？<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/18.jpg" title="}"><br>还是…</p><p>女朋友说好久没去旅游了，我说等过了这段时间，她半天不说话，我回头一看，她在擦眼泪<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/19.jpg" title="}"><br>我们都是那种很乖的人，很少对人说不，很能忍，什么事都咬碎牙齿往肚子里吞，很少情绪外露，但今天..</p><p>有人这样解释什么是生活，拿一台照相机，把每个开心的瞬间拍下来，贴到墙上，就组成了生活<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/20.jpg" title="}"><br>但最近这一年，好像没什么值得贴的<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/21.jpg" title="}"><br>应该是照相机也拿去闲鱼卖了</p><p>那么，我还在生活么，也许我只是活着<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/22.jpg" title="}"><br>这样的日子还要多久？可能用不了多久，也可能要一辈子<br><img src="/2019/04/26/man-hua-996-dui-cheng-xu-yuan-de-shang-hai-yi-kan-ni-jiu-dong/23.jpg" title="}"><br>我不想这样，我要找回我的生活照相机</p><p>…</p><p>996，想说爱你不容易！</p><p>来源：挖数<br>链接：<a href="https://mp.weixin.qq.com/s/50Z6wEs6lNUHCerLmV-vYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/50Z6wEs6lNUHCerLmV-vYQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大公司的面试官是如何挑人的？</title>
      <link href="/2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/"/>
      <url>/2019/04/24/da-gong-si-de-mian-shi-guan-shi-ru-he-tiao-ren-de/</url>
      
        <content type="html"><![CDATA[<p>又到一年一度的跳槽求职高峰季，很多人问我，你们公司还需要人么，你们用的技术栈是哪些，有哪些是你们比较关注技术重点？</p><p>没错，作为负责技术面试的我，面对数十甚至上百封简历，肯定要做一轮筛选。究竟哪些技术点或方向在我筛选或面试时，留下深刻印象呢？</p><p>我觉得优秀的，有潜质的程序员可以从下面几点体现。</p><h1 id="1、性能调优"><a href="#1、性能调优" class="headerlink" title="1、性能调优"></a>1、性能调优</h1><p>几乎每个JAVA后端开发程序员，都会在面试时碰到诸如如何性能调优的问题，如何回答好这个问题，不仅仅是对JVM，内存模型等的理解，更重要的是碰到性能问题时，排查问题的方法论和思路。</p><p>典型的一个场景是：在压力测试时，发现FullGC频率很高，如何解决？</p><p>此类问题一般从以下几点入手：</p><pre><code>1. 观察GC日志，判断是否有内存泄漏，或者存在的内部不合理点。此处要求能熟悉各种linux命令，可以快速查看和定位。2. 调整JVM 参数，如新生代，年老代大小，S0和S1大小比例，不同垃圾回收器的采用。并结合业务特点做进一步分析。这里不但要求扎实的JVM内存模型和理论，还要求对JVM的各种参数设置耳熟能详，并能实践操作。3. Dump内存，做进一步的对象分析。4. 压测脚本的编写，性能问题解决前可以发现问题，并能在问题解决后真实的验证。</code></pre><p>此类优化不仅仅是照本宣科式的回答，面试官一定会喜欢问实际中操作的场景，和解决问题的思路。因为性能问题的原因是多种多样的，但是解决问题的思路和方法论是可以明确的。</p><h1 id="2、网络框架的理解和使用"><a href="#2、网络框架的理解和使用" class="headerlink" title="2、网络框架的理解和使用"></a>2、网络框架的理解和使用</h1><p>大家一定都听过或使用过网络异步框架Netty，甚至使用netty框架开发过一些应用和功能。</p><p>但是大部分人仅限于对Netty的使用，甚至仅仅知道其他一些开源框架使用了Netty，但是在资深面试官眼里，Netty有很多值得学习和借鉴的地方，使用过Netty并且能对Netty的一些原理有一定的了解且能学以致用的Java程序员格外受欢迎。</p><p>一般来说，要求较高的面试官和技术经理喜欢从Netty的设计模式角度深入的考察技术人员对网络开发和相关理论的理解如：</p><pre><code>1. Netty的Reactor模型如何设计，反应在应用里的模型是如何。2. Netty的pipeline 责任链如何使用，业务场景中是否有类似的实践经验。3. 项目中有无使用Netty，并利用Netty进行私有化协议设计。</code></pre><p>同学们不仅要求能使用Netty，通过阅读其源码，理解其中的精髓，并能应用在自己的实践项目中，这个才是亮点和加分项。</p><h1 id="3、开源服务化RPC框架的理解和使用"><a href="#3、开源服务化RPC框架的理解和使用" class="headerlink" title="3、开源服务化RPC框架的理解和使用"></a>3、开源服务化RPC框架的理解和使用</h1><p>互联网经过十几年的发展，早已经从单体应用发展为服务化应用，大厂里系统和服务尤其如此。</p><p>拿经典的dubbo  服务化框架举例，当前市面上有很多dubbo相关的文章和介绍，这里撇开不谈，从技术负责人的角度来，我会更关心下面有关几个dubbo相关的问题。</p><h2 id="1-技术选型：为什么选择dubbo，而不选择其他如spring-cloud框架"><a href="#1-技术选型：为什么选择dubbo，而不选择其他如spring-cloud框架" class="headerlink" title="1. 技术选型：为什么选择dubbo，而不选择其他如spring cloud框架?"></a>1. 技术选型：为什么选择dubbo，而不选择其他如spring cloud框架?</h2><p>我认为可以从如下考虑：</p><pre><code>A）业务的特点以及可预见的后续的发展。作为高级技术人员，必须需要对业务的的发展做预计和规划。B）可用性要求，是否需要达到4个99（99.99%），需要支撑的峰值QPS，是否有业务的集中爆发点，如电商大促C）团队的成熟度，一个成熟的团队可以很好的hold住复杂的开源框架，甚至做定制化开发。D）技术选型这个话题虽然宽泛，但是最能体现更能体现技术人员的综合能力，尤其是结合业务特点后对技术深度和广度的驾驭能力。</code></pre><h2 id="2-Dubbo底层走的是什么协议，如何处理异步转同步？"><a href="#2-Dubbo底层走的是什么协议，如何处理异步转同步？" class="headerlink" title="2. Dubbo底层走的是什么协议，如何处理异步转同步？"></a>2. Dubbo底层走的是什么协议，如何处理异步转同步？</h2><p>大部分的Java开发都会直接使用dubbo，而不会去关心其底层一些技术细节，但是一些细节，如dubbo如何对对象进行序列化，用了哪些序列化方式，这些在分布式项目中对提高应用的处理速度，减少网络开销，都很大帮助。</p><p>同时RPC框架里如何将异步转同步，也是需要技术人员非常关注的一面，里面相关的设计模式，多线程程高并发场景都是很多业务系统里真实需要和借鉴的。</p><h2 id="3-Dubbo在高并发高可用等实践场景需要认真考虑的其他问题"><a href="#3-Dubbo在高并发高可用等实践场景需要认真考虑的其他问题" class="headerlink" title="3. Dubbo在高并发高可用等实践场景需要认真考虑的其他问题"></a>3. Dubbo在高并发高可用等实践场景需要认真考虑的其他问题</h2><p>使用了dubbo后，很多人觉得万事大吉，其实并不是这样，下面几点还需要关心，并且这些就是体现你价值的地方</p><pre><code>A) dubbo依赖了zooKeeper，但是万一ZooKeeper宕机了怎么办B) 如果ZooKeeper假死，客户端对服务端的调用是否会全部下线，如果是该如何避免C) 如何监控duubo的调用，并做到优雅的客户端无感发布</code></pre><h1 id="4、自身多年的面试体会"><a href="#4、自身多年的面试体会" class="headerlink" title="4、自身多年的面试体会"></a>4、自身多年的面试体会</h1><p>1.项目中尽量多思考，迎难而上，如碰到复杂的性能，内存泄露等问题的问题，往往是提升自己的机会，千万要仔细研究解决，可以参考其他解决类似问题的文章和实践经验，对技术深度的提升是很大的，关键时候可以让你的面试官突然觉得面耳目一新。</p><p>2.重视解决问题的思路和方法，很多时候技术人员可以快速设计一个系统或解决一个问题，但是在资深工程师或面试官眼里可能并不是最优方案。如何解决？</p><p>很多技术人员的项目和技术相对单一，长久以往，容易造成技术思路和视野的狭窄，接触不到行业最新思路和动态或者当前疑难问题的最佳解决方案。    </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程师生存指南：面试准备、工作经验和实用工具</title>
      <link href="/2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/"/>
      <url>/2019/04/23/ruan-jian-gong-cheng-shi-sheng-cun-zhi-nan-mian-shi-zhun-bei-gong-zuo-jing-yan-he-shi-yong-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>编者按：软件工程师是令人羡慕的职业。但是如何才能拿到这份工作？又如何才能做好这份工作呢？拥有相关经验的 Valeri Alexiev 提供了相关建议和工具。其中包括了如何准备面试、如何以软件工程师的身份工作以及如何持续改进方面的经验之谈。</p><p>我刚开始工作的头几年是紧张学习的时间。</p><p>我得面对现实，成为软件工程师需要有很多技能，这些我之前都不知道。回顾过去，显然学会那些东西是很好的。</p><p>所以我就根据自己及其他人的经验写了这篇指南来帮助入行的新人。</p><p>本文将覆盖以下内容：</p><pre><code>如何尽力做好面试如何在软件工程师的角色中生存（及发展）考虑持续改进时可以参考的资源</code></pre><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>当你开始软件工程职业生涯时，你得面对一个无可争议的事实。面试很恶心。</p><p>参与其中的每个人都觉得很恶心。既被人面试过又面试过别人的我可以证明，面试是一项极其耗时、极其有压力的工作，并且面试其实并不是将来工作表现一个的好的指示器。<br>但不管怎样，这都是一个必要之恶，你和你的简历最好还是做好准备为妥。</p><h2 id="做好战斗准备"><a href="#做好战斗准备" class="headerlink" title="做好战斗准备"></a>做好战斗准备</h2><p>如果你考虑做软件过程，确保了解一些最常见的编程面试问题，比如“FizzBuzz”：</p><p>写一个程序打印从 1 到 100 的数字。但是如果数字是 3 的倍数的话则打印“Fizz”，如果数字是 5 的倍数则打印“Buzz”。如果同时是 3 和 5 的倍数则打印“FizzBuzz”。</p><p>来自 Coding Horror</p><p>听起来很简单，是吧？</p><p>好吧，但其实绝大部分面试者都没能通过这一简单的测试，且不说更复杂的变种了。</p><p>我个人曾经见过很多角逐资深岗位的候选人在拥有完全互联网访问的情况下没能通过这一测试。所以如果你的简历上面列有编程语言的话，确保你知道如何用它来编写实现 FizzBuzz 程序。<br>否则的话，你只不过是在浪费所有人的时间，包括你自己的。</p><p>当然，为了在面试过后生存，你需要知道的不仅仅只有 FizzBuzz。你还需要确保你知道：</p><p>基础的数据结构和算法：比如链表、数组、树以及排序。<br>要知道所选择语言的常见解决办法，比如字符串是否恒定，内存是如何管理的。<br>类似类与对象，以及继承等面向对象编程的概念。<br>在职业生涯开始时，你需要就这些问题做好准备，因为你并没有经历去证明自己能做好这份工作。在准备面试的时候有两个资源我会经常推荐：</p><p>《Cracking the Coding Interview（破解面试代码）》，这是一本非常好的书，里面介绍了很多的编码问题和解决方案，同时还总结了解决这些问题需要了解的东西。</p><p>CodeWars ，这个网站收集了大量的编程问题，你可以运用各种语言在浏览器里面去解决这些问题。最有用的部分是看看别的用户是如何解决同样问题的。这样你就可以看到解决相同问题的不同办法，并且学到你所选语言的新工具。</p><h2 id="赋予自身额外优势"><a href="#赋予自身额外优势" class="headerlink" title="赋予自身额外优势"></a>赋予自身额外优势</h2><p>为了让自己取得那点额外优势，有几件事情你可以去做。</p><p>首先，学会如何沟通你的经验。你应该进行一次电梯演讲来将你的简历总结成连贯的、打动人的个人介绍。</p><p>此外，要了解自己的简历！听起来很蠢是吧，但我就见过很多面试者连解释清楚自己简历上的特定事项都很困难。你应该能够回答任何有关你列上简历的经历方面的问题，并且解释清楚这一经历如何让你成为本工作更好的候选人。</p><p>接着，要在 GitHub（或者其他的公共代码库）上面有一些编码的例子。</p><p>眼见为实，面试官能够看到你的代码将创造奇迹。此外，这还证明了你对版本控制系统有了解。</p><p>你的代码例子不需要太复杂，但是一定要整洁，能够显示出好的编码实践。这是你展示自己在没有编码面试所带来的时间压力情况下代码写得如何的机会。</p><p>一旦你做完了上面的事情后，就得考虑参与一个开源项目了。参加开源项目能表明你能够在已有代码库基础上工作并且可以与其他程序员一些协作。</p><p>这是你在无需实际进入一个行业环境的情况下最接近在行业环境下编程的方式了。这也是目前为止最难最耗时的一项任务，所以等到你把前面我提到的比较容易取得的果实都摘完之后再干这件事。</p><h2 id="面试你的面试官"><a href="#面试你的面试官" class="headerlink" title="面试你的面试官"></a>面试你的面试官</h2><p>在找工作的匆忙与压力之下，很多候选人都忘了面试是一个双向的过程。在公司努力寻找这份工作的合适人选时，你也应该设法弄清楚这家公司适不适合你。</p><p>确保你也要提出以下一些问题，哪怕对方是以电子邮件的形式回复你。要意识到公司经常把不遵循最佳实践说成是一项技能，所以要体会其言外之意。</p><p>以下是一些你可以去提问的例子：</p><h3 id="“对我来说典型的工作日会是什么样的？”"><a href="#“对我来说典型的工作日会是什么样的？”" class="headerlink" title="“对我来说典型的工作日会是什么样的？”"></a>“对我来说典型的工作日会是什么样的？”</h3><p>知道特定岗位预期的样子很重要，因为软件工程工作差别相当大。比方说你的工作既可能是维护服务器，也可能是直接跟客户沟通。</p><p>危险信号：“我不大肯定。” → 意味着面试你的那个人不在你的团队，或者他们对为什么要招你并没有明确的想法。</p><h3 id="“你们是如何测试软件的？”"><a href="#“你们是如何测试软件的？”" class="headerlink" title="“你们是如何测试软件的？”"></a>“你们是如何测试软件的？”</h3><p>理想情况下，验证代码质量应该是单元测试、人工测试以及自动化测试的结合。</p><p>危险信号：“我们都写不出 bug，哈哈。” → 那些人正是会写出 bug 的人。</p><h3 id="“你们使用什么样的版本控制系统？”"><a href="#“你们使用什么样的版本控制系统？”" class="headerlink" title="“你们使用什么样的版本控制系统？”"></a>“你们使用什么样的版本控制系统？”</h3><p>版本控制系统对于协作极其有用，在职业环境下没有理由不使用。</p><p>危险信号 #1：“额，版本控制系统？” → 快跑，跑得越远越好。</p><p>永远记得使用版本控制。</p><p>危险信号 #2：“&lt;插入不知名的或者定制的 VCS&gt;” → 这表明他们很有可能没有跟上时代并且很久没有升级自己的基础设施了。</p><h3 id="“你们进行同行评审吗？”"><a href="#“你们进行同行评审吗？”" class="headerlink" title="“你们进行同行评审吗？”"></a>“你们进行同行评审吗？”</h3><p>同行评审，或者让别人看看你的代码再把它放进代码库，这是识别愚蠢错误的极好办法，同时也是开始你的职业生涯时一个关键的培训机会。</p><p>危险信号：“我们相互信任！”→很有可能那些资深开发者对自己的代码非常警惕不想给人看也不擅长接受反馈。</p><h3 id="“你们的继续教育计划是什么样的？”"><a href="#“你们的继续教育计划是什么样的？”" class="headerlink" title="“你们的继续教育计划是什么样的？”"></a>“你们的继续教育计划是什么样的？”</h3><p>作为一名软件工程师意味着当新技术出现、成熟并以令人眼花缭乱的速度走向过时的时候要不断学习。因此，很多公司都有培训预算用来买大学和在线课程、会议或者内部交流。</p><p>危险信号：“你是说在闲暇时间读读网上的东西？” →这家公司要么资金紧张，要么把开发者视为可替代的，而不是长期投资。</p><h3 id="“你们采用的软件开发流程是什么？”"><a href="#“你们采用的软件开发流程是什么？”" class="headerlink" title="“你们采用的软件开发流程是什么？”"></a>“你们采用的软件开发流程是什么？”</h3><p>无论实际的细节是什么，流程对于软件工程都至关重要。至于哪些东西对于优化流程做出了贡献可能大家会有不同的看法，但仅就项目的工作方式达成一致就能将混乱最小化并且确保每个人都能达成共识。</p><p>危险信号：“我们的流程受到了自由风格的爵士的影响。” → 很有可能整个部门都处在救火模式，总是不断地从紧急跳到另一个紧急状态而缺乏任何明确的目标。</p><h3 id="“你们是如何处理技术债务的？”"><a href="#“你们是如何处理技术债务的？”" class="headerlink" title="“你们是如何处理技术债务的？”"></a>“你们是如何处理技术债务的？”</h3><p>技术债务是过时技术以及代码库中临时应急的解决方案的累积。处理好技术债务对于代码的长期健康很重要，这件事情应该持续地做。</p><p>危险信号：“我们只关注新功能。” → 他们的代码库一团糟或者很快就会一团糟。</p><h3 id="“你们的公司文化是什么样的？”"><a href="#“你们的公司文化是什么样的？”" class="headerlink" title="“你们的公司文化是什么样的？”"></a>“你们的公司文化是什么样的？”</h3><p>公司文化也许是个非常含糊的概念，但即便像开放办公室还是小隔间这样的小事情都会显著改变你与同事的日常互动。这方面没有普遍性的危险信号，但是要确保他们的答案是你可以按照每周 40+ 小时的节奏持续相处数年的东西。</p><h2 id="以软件工程师的身份工作"><a href="#以软件工程师的身份工作" class="headerlink" title="以软件工程师的身份工作"></a>以软件工程师的身份工作</h2><p>在这个阶段，如果你面试过程中表现不错并且喜欢面试官回答你问题的方式，你被录用的可能性就很高了。</p><p>祝贺，你正式成为一名工程师了！</p><p>那现在又该如何呢？好吧，现在是时候重新学习大量编码和工作方面的东西了。既然我们是程序员，我们就从讨论代码开始。</p><h2 id="好的行业代码"><a href="#好的行业代码" class="headerlink" title="好的行业代码"></a>好的行业代码</h2><p>好的行业代码有以下属性，依序是：</p><pre><code>1.可读性，因为代码用来读和维护的频次要高于写。代码的意图必须清晰，让其他开发者在多年后依然理解。2.防御性，就是要遵循防御性编码的最佳实践。防御性编码本身就是一个课题，不过其要义是：你必须确保自己所写的类和方法的不恰当使用不会导致你的代码搞得软件都崩溃。3.优化，位列清单的最后未知，因为大多数时候你并不需要真正去担心这个。这并不意味着你应该编写糟糕代码，在存在线性解决方案的情况下以O(n³)的效率去做某个东西。但开发者通常渴望尝试并且会在不需要的情况下过度优化，却牺牲了代码的可读性和防御性。你永远都应该能够证明牺牲了这些属性的特定优化是值得的。</code></pre><p>现在你了解了如何去编写良好的行业代码了。</p><h2 id="编码的工作你不会干太多的"><a href="#编码的工作你不会干太多的" class="headerlink" title="编码的工作你不会干太多的"></a>编码的工作你不会干太多的</h2><p>说出来也许有点令人吃惊，但是大多数时候你都不用写新代码，而是相反，要做：</p><pre><code>调试读已有代码开会或者写电子邮件研究该怎么做以便不用写代码</code></pre><p>因此编码以外的技能对你的职业一样关键。</p><h2 id="调试和阅读代码"><a href="#调试和阅读代码" class="headerlink" title="调试和阅读代码"></a>调试和阅读代码</h2><pre><code>调试远不仅仅是用打印语句。一切使用广泛的语言和技术栈都有各种强大的工具。学会使用它们，因为这些会让调试轻而易举，节省你无数的时间。理解代码库。大多数技术栈都有某种代码图谱生成工具来帮助你理解代码库的结构。企业级的 IDE 通常都内置了那种功能。你还可以利用 ReSharper、grep 或者 Sourcegraph 之类的工具来探索代码。理解产品。你会对居然有这么多开发者在试图“修复”软件前不知道软件应该是怎么工作的感到惊讶。先看看文档再说吧。</code></pre><p>　　</p><h2 id="组织你的思路"><a href="#组织你的思路" class="headerlink" title="组织你的思路"></a>组织你的思路</h2><p>既然你的大量时间都是用在沟通、研究和多任务上，你需要一些工具来帮助一切井然有序。</p><pre><code>TODO 清单/任务工具：你的公司应该已经有了某种任务管理软件了，但你自己也有类似的个人系统是有帮助的。使用便利贴或者像 Trello 或者 Todoist 之类的软件。笔记：开会一定要记笔记，要致力于改进现有文档并且建立个人的知识库。使用 Evernote、OneNote 或者笔记本。使用这些工具似乎有用力过度之嫌，但日后在回顾这一耗掉了你 3 天时间才想清楚的晦涩的开发过程时你会感谢自己的。不做丰富笔记的好的软件开发者我一个都没见过。图表/可视化：人是视觉动物，创建流程图和架构可帮助你和其他人理解复杂的话题。在跟非技术人员沟通时图解尤其有用。可使用 Lucidchart、 Visio 或者白板。</code></pre><p>　　</p><h2 id="知道何时使用库"><a href="#知道何时使用库" class="headerlink" title="知道何时使用库"></a>知道何时使用库</h2><p>简短回答：随时都要。</p><p>详细回答：99% 的时间内你都不应该重新发明轮子。在大多数的软件工程岗位，实现特定类型的东西都属于纯粹浪费时间。这并不意味着你不应该知道所使用的算法和数据结构是怎么工作的，因为这可以帮助你决定用什么以及什么时候用。</p><p>为了成为一名高效的软件工程师，你需要理解自己可以任意支配使用的那些库。大多数流行语言的标准库都是极其有用的，其规模比你想象的要大。此外，代码库也许也会利用了额外的特殊库。阅读其文档，知道什么使用去使用它们。</p><p>你还应该不要害怕去建议额外的库，如果它们将节省时间的话。然而，你需要确保自己选择了一个好的库供行业使用。好的库的标准是：</p><pre><code>开源，这样你就可以验证自身代码的质量，并有可能修补对应用非常关键的 bug。按照 MIT 和 BSD 等方式进行的授权，这样你的公司使用起来就不会遇到任何问题。要小心 GPL，因为它会让你不小心就将整个代码库都开源出去。成熟，比方说出来已经有一段时间了，并且功能集非常丰富。维护性强，新版本推出很密集。别的公司或者项目也使用，这个可以充当品质认证确保有行业支持，能持续维护下去。</code></pre><p>　　</p><h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><p>为了替自己创建新的职业机会，除了学习会让你更擅长日常工作的技能以外，你还需要持续改进自身技能并且学习新技能。</p><p>其实学习的机会有很多，而且其中很多都是你可以负担得起的：</p><pre><code>在线课程：向领域内最好的教授学习的机会，而且方式灵活，不容错过。现有技能的补充性教程可以去可以看看 Coursera、 Udacity 以及 edX 等。在线硕士学位：在线硕士学位是最近在顶级大学流行起来的一个趋势，这种方式可以灵活地继续你的正规教育。相比之下，这种继续教育方式费用没那么昂贵，修完整个学位大多数在 1 万美元左右。乔治亚理工大学、UT 以及加州大学圣地亚哥分校等大学均提供此类学位。我个人推荐乔治亚理工大学的在线硕士虚伪，我去年刚从这里毕业。博客：博客是开发者社区的重要组成部分。诸如 Coding Horror、Joel on Software 等博客或者甚至更加诙谐的网站如 The Daily WTF 等都可以为你提供信息，了解到作为软件工程师该干什么不该干什么。浏览 Medium、r/programming, HackerNews 等新闻流也能让你找到好博客和好文章。会议：最后但并非最不重要的一个，会议时令人赞叹的学习机会，你绝对应该利用公司的培训预算去参加会议。以下是不完全的好会议清单：GOTO（通用）， Strange Loop（通用）， PyCon （Pytho），CPPCon （C++），DEF CON （安全），Fluent （Web 开发）。上述所有的会议在 YouTube 上都有视频，所以你哪怕不出席也能学到东西！</code></pre><p>希望这篇文章能够用相关知识把你武装起来，让你了解到作为软件工程师的职业生涯伊始应该期待什么，并且提供合适的工具给你在开启这段令人兴奋的旅程中助你一臂之力！</p><p>英文：Valeri Alexiev   译文：36kr<br>36kr.com/p/5160742.html</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat相关面试题</title>
      <link href="/2019/04/22/tomcat-xiang-guan-mian-shi-ti/"/>
      <url>/2019/04/22/tomcat-xiang-guan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，这次整理了Tomcat相关的系统架构，<br>介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！<br>另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，<br>这些相关的题目你是可以再往Tomcat处理请求的这个过程去说的！掌握注Tomcat这些技能了，面试官一定会佩服你的！</p><p>学了本节之后你应该明白的是：</p><p>Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点；</p><p>Tomcat执行的整体架构，请求是如何被一步步处理的；</p><p>Engine、Host、Context、Wrapper相关的概念关系；</p><p>Container是如何处理请求的；</p><p>Tomcat用到的相关设计模式；</p><h1 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构"></a>一、Tomcat顶层架构</h1><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！</p><p>先上一张Tomcat的顶层结构图（图A），如下：</p><p><img src="https://img-blog.csdn.net/20180108192645999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><p>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; </p><p>2、Container用于封装和管理Servlet，以及具体处理Request请求；</p><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：</p><p><img src="https://img-blog.csdn.net/20180108204347710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的server.xml配置文件中看出，下图是删除了注释内容之后的一个完整的server.xml配置文件（Tomcat版本为8.0）</p><p><img src="https://img-blog.csdn.net/20180108194753633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>详细的配置文件文件内容可以到Tomcat官网查看：</p><p><a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="https://img-blog.csdn.net/20180108194817763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p><h1 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a>二、Tomcat顶层架构小结：</h1><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；<br>（2） Server掌管着整个Tomcat的生死大权；<br>（4）Service 是对外提供服务的；<br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；<br>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p><h1 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a>三、Connector和Container的微妙关系</h1><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h1 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a>四、Connector架构分析</h1><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><p>（1）Connector如何接受请求的？</p><p>（2）如何将请求封装成Request和Response的？</p><p>（3）封装完之后的Request和Response如何交给Container进行处理的？</p><p>（4）Container处理完之后如何交给Connector并返回给客户端的？</p><p>首先看一下Connector的结构图（图B），如下所示：</p><p><img src="https://img-blog.csdn.net/20180108205854139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><p>（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</p><p>（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p><p>（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h1 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a>五、Container架构分析</h1><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：</p><p><img src="https://img-blog.csdn.net/20180108201104048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>4个子容器的作用分别是：</p><p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p><p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p><p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</p><p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="https://img-blog.csdn.net/20180108201901382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a></p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h1 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a>六、Container如何处理请求的</h1><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p><p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p><p><img src><a href="https://img-blog.csdn.net/20180108212100441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener">https://img-blog.csdn.net/20180108212100441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast</a></p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><p>（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</p><p>（2）在上层容器的管道的BaseValve中会调用下层容器的管道。</p><p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p><p>Pipeline的处理流程图如下（图D）：</p><p><img src="https://img-blog.csdn.net/20180116093931129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p><p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p>（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p><p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p><p>原文：<a href="https://blog.csdn.net/u010870518/article/details/79006434" target="_blank" rel="noopener">https://blog.csdn.net/u010870518/article/details/79006434</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-操作符记录</title>
      <link href="/2019/04/19/sql-union-cao-zuo-fu/"/>
      <url>/2019/04/19/sql-union-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-UNION-操作符"><a href="#SQL-UNION-操作符" class="headerlink" title="SQL UNION 操作符"></a>SQL UNION 操作符</h1><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p><p>SQL UNION 语法<br>SELECT column_name(s) FROM table_name1<br>UNION<br>SELECT column_name(s) FROM table_name2</p><h3 id="注释：默认地，UNION-操作符选取不同的值。如果允许重复的值，请使用-UNION-ALL。"><a href="#注释：默认地，UNION-操作符选取不同的值。如果允许重复的值，请使用-UNION-ALL。" class="headerlink" title="注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。"></a>注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</h3><p>SQL UNION ALL 语法<br>SELECT column_name(s) FROM table_name1<br>UNION ALL<br>SELECT column_name(s) FROM table_name2</p><p>另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p><h1 id="SQL-JOIN-操作符"><a href="#SQL-JOIN-操作符" class="headerlink" title="SQL JOIN 操作符"></a>SQL JOIN 操作符</h1><p>下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。</p><p>JOIN: 如果表中有至少一个匹配，则返回行<br>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行<br>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行<br>FULL JOIN: 只要其中一个表中存在匹配，就返回行</p><p>注释：INNER JOIN 与 JOIN 是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何搞定面试官？</title>
      <link href="/2019/04/18/jiao-ni-ru-he-gao-ding-mian-shi-guan/"/>
      <url>/2019/04/18/jiao-ni-ru-he-gao-ding-mian-shi-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="“请做个自我介绍。”"><a href="#“请做个自我介绍。”" class="headerlink" title="“请做个自我介绍。”"></a>“请做个自我介绍。”</h2><pre><code>有的人，可以口若悬河、妙语连珠讲3分钟，有的人，可能磕磕巴巴，讲了30秒，前者一定能胜过后者，然则未必，今天就来聊一聊，面试的经典问题——自我介绍。</code></pre><h2 id="为什么要做自我介绍"><a href="#为什么要做自我介绍" class="headerlink" title="为什么要做自我介绍"></a>为什么要做自我介绍</h2><pre><code>通常说来，大大小小的面试，尤其是针对基础岗位，都会被问到这个问题，甚至有些面试技术还有些生硬的面试官，屁股还没坐稳，就把这个问题抛给应聘人员了，那么作为求职者，要首先明白，面试官为什么要让你做自我介绍？简单说来，包括以下几个原因：    1、面试官的技巧还不是很娴熟，使用面试的惯常流程；2、通过自我介绍，判断求职者的基本素质（比如口头语言表达能力、逻辑能力等）；3、通过自我介绍，找到简历上缺失的或者不一致的细节，后续追问；4、通过自我介绍，建立对应聘者的立体、整体的初步印象和概念。</code></pre><p>简言之，自我介绍的意义和价值就在于，通过简短的口头语言陈述，让面试官初步了解你是一个什么样的面试候选人。</p><h2 id="如何做好自我介绍"><a href="#如何做好自我介绍" class="headerlink" title="如何做好自我介绍"></a>如何做好自我介绍</h2><h3 id="1、先说核心内容："><a href="#1、先说核心内容：" class="headerlink" title="1、先说核心内容："></a>1、先说核心内容：</h3><p>前面已经介绍了这一问题的考察点，那么接下来就对症下药，做一个高质量的自我介绍，给整场面试开一个好头。自我介绍过程就是人岗匹配度的核查与确认，这样描述有点抽象，举个例子来说： </p><p>应聘职位：招聘助理</p><p>应聘人员：有一定HR初级经验</p><p>假设自我介绍-1：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，招聘任务重的时候，也协助做一些招聘工作，比如面试的约谈，面试过程的记录以及相关数据的汇总等等”；</p><p>假设自我介绍-2：“……我在原来公司从事过HR助理工作，主要以员工关系工作为主，没怎么做过招聘，招聘任务重的时候，会给招聘小组的同事们帮帮忙……”</p><p>对比上面的两个自我介绍，也就不难看出质量的优劣，在做介绍的过程中，首要原则，多介绍以往工作经验中跟当前应聘岗位有交集的地方，而且尽可能描述到细节，切勿顾左右而言他。</p><p>有的人可能会说了，我正在寻求转行，没有相关经验怎么办？</p><p>只要记住以下几点：<br>    如果这家公司在看过你简历的情况下依然通知你面试，那么也就代表以往的工作经验并非是该岗位的必要要素。</p><p>此处还要多说一句，如果你是打算转行，收到心仪的职位时，先不要过于激动，而是要在面试电话中先冷静地跟通知你的人确认一下你要面试的职位，<br>不排除当下有些公司会挂着羊头卖狗肉，打着文职的旗号招销售，专门诱骗小姑娘们，所以此类公司，要更加慎重，<br>可以用该公司的名称到网络上去搜索一下他们家的招聘信息，如果铺天盖地都是销售岗位的招聘，那么，可能就只是个幌子而已了。<br>其实非专业技术型的岗位，尤其是偏基础性质的职位，企业不会特别看重以往经验的对口与否，衡量工作的胜任能力，一方面是技能，一方面是态度，</p><p>技能培养如果可以在企业内部培训的基础上快速实现，往往更加看重你的个人态度层面，所以不必过分纠结经验问题。再举个例子来说：</p><p>应聘职位：销售支持</p><p>应聘人员：有一定的话务客服经验</p><p>自我介绍：“……在之前的工作中，我从事的是话务客服的工作，虽然跟贵公司招聘的销售支持职务有差别，但我详细阅读了贵公司的岗位介绍，销售支持的工作需要良好的服务意识，细心的工作态度以及对产品知识的了解，从事过客服工作，我的服务意识以及细心程度都没有问题，专业知识相信经过公司的培训之后，自己也能熟练掌握……”</p><p>也就是说，如果你是转行，应聘不需要专业的技能和知识的岗位，尽可能寻找以往工作中的软性能力与当前应聘职位之间的关系，多表现自己良好的职业素质层面的东西即可。</p><h3 id="2、再说说辅助内容："><a href="#2、再说说辅助内容：" class="headerlink" title="2、再说说辅助内容："></a>2、再说说辅助内容：</h3><p>上述内容针对的是自我介绍的核心内容，但自我介绍的内容不仅仅是这些，还需要有一些其他的内容作为辅助，才显得更加自然和饱满，简言之，一篇完成的自我介绍要涵盖以下内容：</p><p>自我基本情况；</p><pre><code>以往工作经验与应聘岗位链接；个人的职业发展设想；对应聘企业的个人认同感；至于个人的兴趣爱好之类的，可以简单带过即可。</code></pre><p>上述的五个简单部分，2、3、4为主，前后两部分为辅助，再加上一些简单的寒暄的话语即可。</p><h3 id="3、还有几个误区，需要大家绕开："><a href="#3、还有几个误区，需要大家绕开：" class="headerlink" title="3、还有几个误区，需要大家绕开："></a>3、还有几个误区，需要大家绕开：</h3><p>自我介绍不是检查背诵能力，切勿千篇一律。有的人准备一套说辞，背的滚瓜烂熟，见谁都是这一套，这样是不稳妥的，要把自己的情况跟企业的职位做链接，这样方才更加吸引面试官；</p><p>做自我介绍的时候卡壳了，怎么办？不要紧张的手足无措，可以坦然地笑笑，跟面试官说，不好意思，我有点紧张，然后继续就好了；</p><p>做自我介绍的时候，两眼直勾勾看桌子或者天花板，没有跟面试官的眼神接触。如果有好几个面试官，不要盯着一个人，都扫几眼；</p><p>做自我介绍的时候，不要做小动作，落落大方，不要抖腿，掰手指头等等；</p><h4 id="注意跟简历内容相一致，不要出现信息不对称。"><a href="#注意跟简历内容相一致，不要出现信息不对称。" class="headerlink" title="注意跟简历内容相一致，不要出现信息不对称。"></a>注意跟简历内容相一致，不要出现信息不对称。</h4><p>简单粗暴的给个模板</p><p>不给模板的干货都是伪干货，上面七七八八说了这么多，给个范本仅供参考：</p><p>“面试官您好，非常荣幸参与贵公司**职位的应聘，下面我简单介绍一下我的个人情况，基本信息之类的简历上都有，就不再重复。</p><p>首先介绍一下之前的工作经验……（挑一些跟应聘岗位有链接的内容说，如果有工作荣誉，前往不要漏掉）……</p><p>之所以离开上一家公司是出于……考虑（离职理由要争当，尽可能从职业发展的角度出发）……</p><p>通过<strong>渠道关注到贵公司</strong>岗位的招聘信息，该职位跟我未来的职业发展相对契合，而且贵公司的业务（或者企业实力、行业口碑、企业文化等）对我都非常有吸引力，非常渴望能够进入贵公司发展……</p><p>我个人的基本情况是（受教育情况、婚育、住所、家庭简单情况），闲暇之余，我一般会做些**事情（有意义的）……</p><p>或许在所有的求职者当中，我不是最优秀的，但如果贵公司能够给我这个工作机会，我有信心，也有决心做好这份工作，以上是我的个人基本情况，希望今天自己面试有好的表现，未来有幸与诸位面试官共事，也预祝各位度过美好的一天。”</p><h4 id="最后再做个总结："><a href="#最后再做个总结：" class="headerlink" title="最后再做个总结："></a>最后再做个总结：</h4><pre><code>自我介绍是整个面试的开始，首因效应之下，第一印象还是很重要滴，在做介绍的过程中，尽可能多去说有些跟岗位工作有关的过往经验，不要生搬硬套，注意灵活应对，可以事先有针对性做一个草稿，但针对框架内容要了熟于心，针对企业岗位有的放矢，落落大方，注意条理。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发者必须要具备的专业技能</title>
      <link href="/2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/"/>
      <url>/2019/04/17/java-kai-fa-zhe-bi-xu-yao-ju-bei-de-zhuan-ye-ji-neng/</url>
      
        <content type="html"><![CDATA[<p>想要成为合格的Java程序员或工程师到底需要具备哪些专业技能，面试者在面试之前到底需要准备哪些东西呢？</p><p>本文陈列的这些内容既可以作为个人简历中的内容，也可以作为面试的时候跟面试官聊的东西，你可以把这些内容写到你的简历中，当然更需要的是你在面试的时候向面试官展示这些专业技能。</p><p>相信此文对正在寻觅Java程序员（Java工程师）职位的freshman以及希望成为中高级Java开发者的junior都会有所帮助。</p><p>专业技能</p><p>1.熟练的使用Java语言进行面向对象程序设计，有良好的编程习惯，熟悉常用的Java API，包括集合框架、多线程（并发编程）、I/O（NIO）、Socket、JDBC、XML、反射等。</p><p>2.熟悉基于JSP和Servlet的Java Web开发，对Servlet和JSP的工作原理和生命周期有深入了解，熟练的使用JSTL和EL编写无脚本动态页面，<br>有使用监听器、过滤器等Web组件以及MVC架构模式进行Java Web项目开发的经验。</p><p>3.对Spring的IoC容器和AOP原理有深入了解，熟练的运用Spring框架管理各种Web组件及其依赖关系，熟练的使用Spring进行事务、日志、安全性等的管理，<br>有使用Spring MVC作为表示层技术以及使用Spring提供的持久化支持进行Web项目开发的经验，熟悉Spring对其他框架的整合。</p><p>4.熟练的使用Hibernate、MyBatis等ORM框架，熟悉Hibernate和MyBatis的核心API，对Hibernate的关联映射、继承映射、组件映射、缓存机制、事务管理以及性能调优等有深入的理解。</p><p>5.熟练的使用HTML、CSS和JavaScript进行Web前端开发，熟悉jQuery和Bootstrap，对Ajax技术在Web项目中的应用有深入理解，<br>有使用前端MVC框架（AngularJS）和JavaScript模板引擎（HandleBars）进行项目开发的经验。</p><p>6.熟悉常用的关系型数据库产品（MySQL、Oracle），熟练的使用SQL和PL/SQL进行数据库编程。</p><p>7.熟悉面向对象的设计原则，对GoF设计模式和企业应用架构模式有深入的了解和实际开发的相关经验，熟练的使用UML进行面向对象的分析和设计，有TDD（测试驱动开发）和DDD（领域驱动设计）的经验。</p><p>8.熟悉Apache、NginX、Tomcat、WildFly、Weblogic等Web服务器和应用服务器的使用，熟悉多种服务器整合、集群和负载均衡的配置。</p><p>9熟练的使用产品原型工具Axure，熟练的使用设计建模工具PowerDesigner和Enterprise Architect，熟练的使用Java开发环境Eclipse和IntelliJ，<br>熟练的使用前端开发环境WebStorm，熟练的使用软件版本控制工具SVN和Git，熟练的使用项目构建和管理工具Maven和Gradle。</p><p>说明：上面罗列的这些东西并不是每一项你都要烂熟于心，根据企业招聘的具体要求可以做相应的有针对性的准备。</p><p>我个人觉得前6项应该是最低要求，是作为一个Java开发者必须要具备的专业技能。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于springboot开发的java web网页版电子商城网站</title>
      <link href="/2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/"/>
      <url>/2019/04/16/ji-yu-springboot-kai-fa-de-java-web-wang-ye-ban-dian-zi-shang-cheng-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p>项目描述</p><p>基于spring boot与mybatis整合的java web网页版电子商城网站，采用maven构建，数据库用的是mysql</p><p>运行环境</p><p>jdk8+tomcat7+mysql+eclipse+maven</p><p>项目技术(必填)</p><p>后台使用：springboot+mybatis</p><p>前台使用：html+css+jquery+freemarker+layui+</p><p>运行安装包文件</p><p>百度网盘：<a href="https://pan.baidu.com/s/1ZHGSul-JysWJ0xh7zeDzIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZHGSul-JysWJ0xh7zeDzIg</a> 密码: a354</p><p>项目截图(必填)</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153946904_337x650.png"></p><p>运行截图(必填)</p><p>1、登录页面</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153723679_650x351.png"></p><p>2、项目首页</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153657537_650x352.png"></p><p>3、商品详情</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153711977_650x353.png"> </p><p>4、后台管理模块</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153852183_650x349.png"> </p><p>5、商品管理模块</p><p><img src="http://static.zuidaima.com/images/201529/201711/20171130153937947_650x353.png"> </p><p>注意事项</p><p>系统是由maven构建的，必须要把所有jar包下载才能成功运行</p><p>如需项目代码请联系博主或者加Q群</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁[原理、锁优化、CAS、AQS]</title>
      <link href="/2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/"/>
      <url>/2019/04/10/java-zhong-de-suo-yuan-li-suo-you-hua-cas-aqs/</url>
      
        <content type="html"><![CDATA[<h1 id="1、为什么要用锁？"><a href="#1、为什么要用锁？" class="headerlink" title="1、为什么要用锁？"></a>1、为什么要用锁？</h1><p>锁-是为了解决并发操作引起的脏读、数据不一致的问题。</p><h1 id="2、锁实现的基本原理"><a href="#2、锁实现的基本原理" class="headerlink" title="2、锁实现的基本原理"></a>2、锁实现的基本原理</h1><h2 id="2-1、volatile"><a href="#2-1、volatile" class="headerlink" title="2.1、volatile"></a>2.1、volatile</h2><pre><code>Java编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</code></pre><p><img src="//upload-images.jianshu.io/upload_images/5401760-9f7389128a85f7c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/765/format/webp"></p><p>结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><h2 id="2-2、synchronized"><a href="#2-2、synchronized" class="headerlink" title="2.2、synchronized"></a>2.2、synchronized</h2><pre><code>synchronized通过锁机制实现同步。</code></pre><p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br>具体表现为以下3种形式。</p><p>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步方法块，锁是Synchonized括号里配置的对象。</p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><h3 id="2-2-1-synchronized实现原理"><a href="#2-2-1-synchronized实现原理" class="headerlink" title="2.2.1 synchronized实现原理"></a>2.2.1 synchronized实现原理</h3><pre><code>synchronized是基于Monitor来实现同步的。</code></pre><p>Monitor从两个方面来支持线程之间的同步：</p><pre><code>互斥执行协作</code></pre><p>1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。<br>2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。<br>3、Class和Object都关联了一个Monitor。</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-de9a8db9928ca68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp"><br>Monitor 的工作机理</p><p>.线程进入同步方法中。<br>.为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）<br>.拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。<br>.其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。<br>.同步方法执行完毕了，线程退出临界区，并释放监视锁。</p><p>参考文档：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-synchronized" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-synchronized</a></p><h3 id="2-2-2-synchronized具体实现"><a href="#2-2-2-synchronized具体实现" class="headerlink" title="2.2.2 synchronized具体实现"></a>2.2.2 synchronized具体实现</h3><p>1、同步代码块采用monitorenter、monitorexit指令显式的实现。</p><p>2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。</p><p>通过实例来看看具体实现：</p><pre><code>public class SynchronizedTest {    public synchronized void method1(){        System.out.println(&quot;Hello World!&quot;);    }    public  void method2(){        synchronized (this){            System.out.println(&quot;Hello World!&quot;);        }    }}</code></pre><p>javap编译后的字节码如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-0d29b096e9c77f09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>monitorenter</p><p>每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：</p><pre><code>.如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。.如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。.如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。</code></pre><p>monitorexit</p><pre><code>只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。</code></pre><h3 id="2-2-3-锁存放的位置"><a href="#2-2-3-锁存放的位置" class="headerlink" title="2.2.3 锁存放的位置"></a>2.2.3 锁存放的位置</h3><p>锁标记存放在Java对象头的Mark Word中。<br><img src="https://upload-images.jianshu.io/upload_images/5401760-f794a9da707c8884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"><br>Java对象头长度<br><img src="https://upload-images.jianshu.io/upload_images/5401760-423237ba213114c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"><br>32位JVM Mark Word 结构<br><img src="https://upload-images.jianshu.io/upload_images/5401760-d88cbe17d78b4ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"><br>32位JVM Mark Word 状态变化<br><img src="https://upload-images.jianshu.io/upload_images/5401760-dd289041866d7cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"><br>64位JVM Mark Word 结构</p><h3 id="2-2-4-synchronized的锁优化"><a href="#2-2-4-synchronized的锁优化" class="headerlink" title="2.2.4 synchronized的锁优化"></a>2.2.4 synchronized的锁优化</h3><p>JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p><p>偏向锁：</p><pre><code>无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5401760-c1f25c4a5f0001af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>轻量级锁：</p><pre><code>轻量级锁所适应的场景是线程交替执行同步块的情况。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/5401760-4f4487faff288712.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>锁粗化（Lock Coarsening）：<br>    也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p>锁消除（Lock Elimination）：<br>    锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</p><p>适应性自旋（Adaptive Spinning）：<br>    自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，<br>进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，<br>那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><h3 id="2-2-5-锁的优缺点对比"><a href="#2-2-5-锁的优缺点对比" class="headerlink" title="2.2.5 锁的优缺点对比"></a>2.2.5 锁的优缺点对比</h3><p><img src="https://upload-images.jianshu.io/upload_images/5401760-dc1cb474286e917c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">    </p><h2 id="2-3、CAS"><a href="#2-3、CAS" class="headerlink" title="2.3、CAS"></a>2.3、CAS</h2><pre><code>CAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。</code></pre><p>1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，<br>如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。</p><p>2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。<br>优点：</p><pre><code>竞争不大的时候系统开销小。</code></pre><p>缺点：</p><pre><code>循环时间长开销大。ABA问题。只能保证一个共享变量的原子操作。</code></pre><h1 id="3、Java中的锁实现"><a href="#3、Java中的锁实现" class="headerlink" title="3、Java中的锁实现"></a>3、Java中的锁实现</h1><h2 id="3-1、队列同步器（AQS）"><a href="#3-1、队列同步器（AQS）" class="headerlink" title="3.1、队列同步器（AQS）"></a>3.1、队列同步器（AQS）</h2><pre><code>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。</code></pre><h3 id="3-1-1、它使用了一个int成员变量表示同步状态。"><a href="#3-1-1、它使用了一个int成员变量表示同步状态。" class="headerlink" title="3.1.1、它使用了一个int成员变量表示同步状态。"></a>3.1.1、它使用了一个int成员变量表示同步状态。</h3><p><img src="https://upload-images.jianshu.io/upload_images/5401760-58ec8eff9511a3e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><h3 id="3-1-2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。"><a href="#3-1-2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。" class="headerlink" title="3.1.2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。"></a>3.1.2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。</h3><p>同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。<br>同步队列遵循FIFO，首节点是获取同步状态成功的节点。</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-30e2658e38e1966c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-addd5edd9723c8db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-d118af99f2bacad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><h3 id="3-1-3、独占式-共享式锁获取"><a href="#3-1-3、独占式-共享式锁获取" class="headerlink" title="3.1.3、独占式/共享式锁获取"></a>3.1.3、独占式/共享式锁获取</h3><pre><code>独占式：有且只有一个线程能获取到锁，如：ReentrantLock。&lt;/pre&gt;共享式：可以多个线程同时获取到锁，如：CountDownLatch</code></pre><p>独占式</p><p>每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-943a473d1d87cc7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>独占式锁获取流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-50bc00c23df33d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>共享式：</p><p>共享式与独占式的区别：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-d0031b43b65487d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>共享锁获取流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-8f66fdebba19eff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/759/format/webp"></p><h1 id="4、锁的使用用例"><a href="#4、锁的使用用例" class="headerlink" title="4、锁的使用用例"></a>4、锁的使用用例</h1><h2 id="4-1、ConcurrentHashMap的实现原理及使用"><a href="#4-1、ConcurrentHashMap的实现原理及使用" class="headerlink" title="4.1、ConcurrentHashMap的实现原理及使用"></a>4.1、ConcurrentHashMap的实现原理及使用</h2><p><img src="https://upload-images.jianshu.io/upload_images/5401760-460898019c2b5b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>ConcurrentHashMap类图</p><p><img src="https://upload-images.jianshu.io/upload_images/5401760-f2f0bb8727e6d4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><p>ConcurrentHashMap数据结构</p><p>结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>来源：<br><a href="https://www.jianshu.com/p/e674ee68fd3f" target="_blank" rel="noopener">https://www.jianshu.com/p/e674ee68fd3f</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级程序员VS普通程序员，差距到底在哪？</title>
      <link href="/2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/"/>
      <url>/2019/04/03/gao-ji-cheng-xu-yuan-vs-pu-tong-cheng-xu-yuan-chai-ju-dao-di-zai-na/</url>
      
        <content type="html"><![CDATA[<p>踏上了编程之路，也就意味着你选择了一种终身学习的生活方式。每一个程序员都要练就十八般武艺，而掌握数据结构与算法就像修炼了九阳神功。<br>换句话说，掌握了数据结构与算法，你的内功修炼速度就会有质的飞跃。</p><p>“初级程序员才比招式，高级程序员只看内功”，数据结构与算法，对于一个程序员来说，至关重要。</p><p>无论你是从事业务开发，想要评估代码性能和资源消耗，还是从事架构设计，想要优化设计模式；或者想要快速玩转热门技术，<br>都要先搞定数据结构与算法。因为，任凭新技术如何变化，只要掌握了这些计算机科学的核心“招式”，你就可以见招拆招，始终立于“不败之地”。</p><p>那怎样才能真正掌握它呢？是把常用的数据结构与算法背的滚瓜烂熟吗？即便如此，面对现实世界的千变万化，你也不太可能照搬某个算法解决即将遇到的下一个问题。<br>因此，就像学习设计模式、架构模式一样，学习数据结构与算法的关键，在于掌握其中的思想和精髓，学会解决实际问题的方法。</p><p>来源：<br><a href="https://mp.weixin.qq.com/s/vL5gEfOfqE3airySe1FlBQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vL5gEfOfqE3airySe1FlBQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11个简单的Java性能调优技巧</title>
      <link href="/2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/"/>
      <url>/2019/03/28/11-ge-jian-dan-de-java-xing-neng-diao-you-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>大多数开发人员理所当然地以为性能优化很复杂，需要大量的经验和知识。好吧，不能说这是完全错误的。<br>优化应用程序以获得最佳性能不是一件容易的事情。但是，这并不意味着如果你不具备这些知识，就不能做任何事情。</p><p>这里有11个易于遵循的建议和最佳实践可以帮助你创建一个性能良好的应用程序。</p><p>大部分建议是针对Java的。但也有若干建议是与语言无关的，可以应用于所有应用程序和编程语言。<br>在讨论专门针对Java的性能调优技巧之前，让我们先来看看通用技巧。</p><h1 id="1-在你知道必要之前不要优化"><a href="#1-在你知道必要之前不要优化" class="headerlink" title="1.在你知道必要之前不要优化"></a>1.在你知道必要之前不要优化</h1><p>这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。<br>但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。</p><p>在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。<br>更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。</p><p>那么，你如何证明你需要优化一些东西呢？</p><p>首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。<br>在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。</p><h1 id="2-使用分析器查找真正的瓶颈"><a href="#2-使用分析器查找真正的瓶颈" class="headerlink" title="2.使用分析器查找真正的瓶颈"></a>2.使用分析器查找真正的瓶颈</h1><p>在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？</p><p>你可以用两种方法来解决问题：</p><pre><code>查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。</code></pre><p>希望不需要我解释为什么应该始终遵循第二种方法的原因。</p><p>很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。<br>如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。<br>老实说，我第一次的猜测不止一次地导致我走错了方向。    </p><h1 id="3-为整个应用程序创建性能测试套件"><a href="#3-为整个应用程序创建性能测试套件" class="headerlink" title="3.为整个应用程序创建性能测试套件"></a>3.为整个应用程序创建性能测试套件</h1><p>这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。<br>你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。</p><p>这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。<br>如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。</p><h1 id="4-首先处理最大的瓶颈"><a href="#4-首先处理最大的瓶颈" class="headerlink" title="4.首先处理最大的瓶颈"></a>4.首先处理最大的瓶颈</h1><p>在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。<br>这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。<br><a href="https://mp.weixin.qq.com/s/yzSR_vkI7-WR71l2A0cq2w" target="_blank" rel="noopener">Java 程序员必须清楚的 7 个性能指标</a>，这个你也必须会。</p><p>速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。<br>但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。</p><p>但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。<br>常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。</p><h1 id="5-使用StringBuilder以编程方式连接String"><a href="#5-使用StringBuilder以编程方式连接String" class="headerlink" title="5.使用StringBuilder以编程方式连接String"></a>5.使用StringBuilder以编程方式连接String</h1><p>有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。String 真的是不可变的吗？</p><p>那么，你应该选择哪种方法？</p><p>答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。<br>它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。<br>StringBuffer 和 StringBuilder 的 3 个区别，这个你必须清楚。</p><p>你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。<br>在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。</p><p>下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。<br>所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。</p><pre><code>StringBuilder sb = new StringBuilder(“This is a test”);for (int i=0; i&lt;10; i++) {sb.append(i);sb.append(” “);}log.info(sb.toString());</code></pre><p>正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。<br>这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。<br>当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。</p><p>如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。<br>这进一步提高了效率，因为它不需要动态扩展其容量。</p><h1 id="6-使用-连接一个语句中的String"><a href="#6-使用-连接一个语句中的String" class="headerlink" title="6.使用+连接一个语句中的String"></a>6.使用+连接一个语句中的String</h1><p>当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。<br>字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。</p><p>在这些情况下，你应该遵循技巧5并使用StringBuilder。</p><p>但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。</p><pre><code>Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ”+ “FROM Author a ”+ “WHERE a.id = :id”);</code></pre><p>在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。</p><h1 id="7-尽可能使用基元"><a href="#7-尽可能使用基元" class="headerlink" title="7.尽可能使用基元"></a>7.尽可能使用基元</h1><p>避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。<br>所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。</p><h1 id="8-试着避免BigInteger和BigDecimal"><a href="#8-试着避免BigInteger和BigDecimal" class="headerlink" title="8.试着避免BigInteger和BigDecimal"></a>8.试着避免BigInteger和BigDecimal</h1><p>既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。<br>尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。</p><p>BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。<br>所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。<br>这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。<br><a href="https://mp.weixin.qq.com/s/NFLfeZLjMuZELEh2Cx7cIA" target="_blank" rel="noopener">金融系统中正确的金额计算及存储方式</a>，这个你了解下。</p><p>9.首先检查当前日志级别</p><p>这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。<br>在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。</p><p>这里有两个反面例子。</p><pre><code>// don’t do thislog.debug(“User [” + userName + “] called method X with [” + i + “]”);// or thislog.debug(String.format(“User [%s] called method X with [%d]”, userName, i));</code></pre><p>在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。<br>因此在创建调试消息之前，最好先检查当前的日志级别。</p><pre><code>// do thisif (log.isDebugEnabled()) {   log.debug(“User [” + userName + “] called method X with [” + i + “]”);}</code></pre><h1 id="10-使用Apache-Commons-StringUtils-Replace而不是String-replace"><a href="#10-使用Apache-Commons-StringUtils-Replace而不是String-replace" class="headerlink" title="10.使用Apache Commons StringUtils.Replace而不是String.replace"></a>10.使用Apache Commons StringUtils.Replace而不是String.replace</h1><p>一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。<br>但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。</p><p>有一个备选答案是Apache Commons Lang的StringUtils.replace方法。<br>正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。</p><p>而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。</p><pre><code>// replace thistest.replace(“test”, “simple test”);// with thisStringUtils.replace(test, “test”, “simple test”);</code></pre><h1 id="11-缓存昂贵的资源，如数据库连接"><a href="#11-缓存昂贵的资源，如数据库连接" class="headerlink" title="11.缓存昂贵的资源，如数据库连接"></a>11.缓存昂贵的资源，如数据库连接</h1><p>缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。</p><p>一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。</p><p>你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。<br>你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。</p><p>但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。</p><p>所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正如你所看到的，有时不需要太多工作就可以提高应用程序的性能。本文中的大部分建议只需要你稍作努力就可以将它们应用于你的代码。</p><p>但是，最重要的还是那些与是什么编程语言无关的技巧：</p><pre><code>在你知道必要之前不要优化使用分析器查找真正的瓶颈首先处理最大的瓶颈</code></pre><p>来源：<br>原文：11 Simple Java Performance Tuning Tips<br>译文：<a href="http://www.codeceo.com/article/11-simple-java-performance-tips.html" target="_blank" rel="noopener">http://www.codeceo.com/article/11-simple-java-performance-tips.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试不懂「微服务架构」原理？不怕被pass了？</title>
      <link href="/2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/"/>
      <url>/2019/03/26/mian-shi-bu-dong-wei-fu-wu-jia-gou-yuan-li-bu-pa-bei-pass-liao/</url>
      
        <content type="html"><![CDATA[<p>近几年，微服务架构迅速在整个技术社区窜红，被认为是 IT 软件架构的未来方向。</p><p>一线互联网公司由于具有大量的业务体量和业务场景，比如阿里、百度、网易，很早就开始入坑微服务架构。</p><p>但说起微服务，不少人还是有这样的困惑：“作为一个开发，微服务架构是不是和我关系不大？那不都是架构师的事吗？”</p><p>关于这个问题，我来谈谈自己的看法。</p><pre><code>微服务是当下最火热的后端架构之一。不管你是一个什么级别的程序员，也不论你在一个什么体量的公司，</code></pre><p>服务化都是你迟早会遇到的难题。实践微服务的过程本身也是一个升级打怪的过程，这中间你会遇到基本上所有后端架构的问题。<br>解决了这些问题，你自然也就理解了那些高深的概念，也就成为了一名架构师，成长和能力提升都是这个过程的附属品。</p><p>并且，你了解微服务架构之后，能知道领导为什么让你这么做，也更容易站在系统角度思考公司技术的进程，这对于你的大局观构建来说非常有帮助。</p><p>再者，微服务这技术在面试的时候总有人提，尤其对于头部互联网企业，微服务架构更是面试考核必备，所以“进大厂必须掌握的50个微服务面试问题”等一些文章备受欢迎。</p><p>如何设计高可用高并发的微服务架构</p><pre><code>1.微服务架构如何拆分2.微服务架构应用场合3.微服务架构与Docker容器化4.微服务架构如何达到99.999%的高可用5.微服务架构性能怎么满足千亿次请求调用6.微服务架构开源框架对比（Spring boot,Spring Cloud,Dubbo等）</code></pre><p>来源：<br><a href="https://mp.weixin.qq.com/s/jqR6CxeJidvT9IrRplU98Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jqR6CxeJidvT9IrRplU98Q</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官必问的8道volatile关键字命题，你答对了吗？</title>
      <link href="/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/"/>
      <url>/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/</url>
      
        <content type="html"><![CDATA[<p>在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底，</p><p>把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。</p><p>下面我们以一次面试过程，来深入了解下volitile关键字吧！</p><h1 id="一、面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解"><a href="#一、面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解" class="headerlink" title="一、面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解"></a>一、面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解</h1><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的内存可见性;</p><p>2 . 禁止指令重排序。</p><h1 id="二、面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？"><a href="#二、面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？" class="headerlink" title="二、面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？"></a>二、面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？</h1><p>这个聊起来可就多了，我还是从Java内存模型说起吧。</p><p>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。</p><p>简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，</p><p>方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><p>这么说得我自己都有些不清楚了，拿张纸画一下：</p><img src="/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/20190325153020.jpg"><p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：</p><pre><code>i = i + 1;</code></pre><p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p><pre><code>线程1： load i from 主存 // i = 0i + 1 // i = 1线程2： load i from主存 // 因为线程1还没将i的值写回主存，所以i还是0i + 1 //i = 1线程1: save i to 主存线程2： save i to 主存</code></pre><p>如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</p><p>下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，</p><p>通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p><h1 id="三、面试官：那你具体说说这三个特性呢？"><a href="#三、面试官：那你具体说说这三个特性呢？" class="headerlink" title="三、面试官：那你具体说说这三个特性呢？"></a>三、面试官：那你具体说说这三个特性呢？</h1><h2 id="1-原子性-Atomicity-："><a href="#1-原子性-Atomicity-：" class="headerlink" title="1 . 原子性(Atomicity)："></a>1 . 原子性(Atomicity)：</h2><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。</p><p>比如：</p><pre><code>i = 2;j = i;i++;i = i + 1；</code></pre><p>上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。</p><p>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p><p>JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。</p><h2 id="2-可见性-Visibility-："><a href="#2-可见性-Visibility-：" class="headerlink" title="2 . 可见性(Visibility)："></a>2 . 可见性(Visibility)：</h2><p>说到可见性，Java就是利用volatile来提供可见性的。</p><p>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</p><p>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p><h2 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3 . 有序性（Ordering）"></a>3 . 有序性（Ordering）</h2><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p><pre><code>double pi = 3.14; //Adouble r = 1; //Bdouble s= pi * r * r;//C    </code></pre><p>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</p><p>比如这样的代码:</p><pre><code>int a = 0;bool flag = false;public void write() {a = 2; //1flag = true; //2}public void multiply() {if (flag) { //3int ret = a * a;//4}}    </code></pre><p>假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定：</p><img src="/2019/03/25/mian-shi-guan-bi-wen-de-8-dao-volatile-guan-jian-zi-ming-ti-ni-da-dui-liao-ma/20190325153601.jpg" title="这是一个新的博客的图片的说明"><p>如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</p><p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><p>另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下happens-before规则：</p><pre><code>1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</code></pre><p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p><p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p><p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p><p>第4条规则，就是happens-before的传递性。</p><p>后面几条就不再一一赘述了。</p><h1 id="四、面试官：volatile关键字如何满足并发编程的三大特性的？"><a href="#四、面试官：volatile关键字如何满足并发编程的三大特性的？" class="headerlink" title="四、面试官：volatile关键字如何满足并发编程的三大特性的？"></a>四、面试官：volatile关键字如何满足并发编程的三大特性的？</h1><p>那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。</p><p>这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p><p>继续拿上面的一段代码举例：</p><pre><code>int a = 0;bool flag = false;public void write() {a = 2; //1flag = true; //2}public void multiply() {if (flag) { //3int ret = a * a;//4}}</code></pre><p>这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。</p><p>如果改成下面这样：</p><pre><code>int a = 0;volatile bool flag = false;public void write() {a = 2; //1flag = true; //2}public void multiply() {if (flag) { //3int ret = a * a;//4}}</code></pre><p>那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则：</p><pre><code>1.程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行)2.volatile规则：2 happens-before 33.传递性规则：1 happens-before 4</code></pre><p>从内存语义上来看</p><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</p><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p><h1 id="五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"><a href="#五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？" class="headerlink" title="五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"></a>五、面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</h1><p>首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</p><pre><code>public class Test {public volatile int inc = 0;public void increase() {inc++;}public static void main(String[] args) {final Test test = new Test();for(int i=0;i&lt;10;i++){new Thread(){public void run() {for(int j=0;j&lt;1000;j++)test.increase();};}.start();}while(Thread.activeCount()&gt;1) //保证前面的线程都执行完Thread.yield();System.out.println(test.inc);}</code></pre><p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p><p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p><p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p><p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p><p>有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p><p>又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p><p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p><p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。    </p><h1 id="六、面试官：说的还可以，那你知道volatile底层的实现机制？"><a href="#六、面试官：说的还可以，那你知道volatile底层的实现机制？" class="headerlink" title="六、面试官：说的还可以，那你知道volatile底层的实现机制？"></a>六、面试官：说的还可以，那你知道volatile底层的实现机制？</h1><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置</p><p>2 . 使得本CPU的Cache写入内存</p><p>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p><h1 id="七、面试官：-你在哪里会使用到volatile，举两个例子呢？"><a href="#七、面试官：-你在哪里会使用到volatile，举两个例子呢？" class="headerlink" title="七、面试官： 你在哪里会使用到volatile，举两个例子呢？"></a>七、面试官： 你在哪里会使用到volatile，举两个例子呢？</h1><h2 id="1-状态量标记，就如上面对flag的标记，我重新提一下："><a href="#1-状态量标记，就如上面对flag的标记，我重新提一下：" class="headerlink" title="1. 状态量标记，就如上面对flag的标记，我重新提一下："></a>1. 状态量标记，就如上面对flag的标记，我重新提一下：</h2><pre><code>int a = 0;volatile bool flag = false;public void write() {a = 2; //1flag = true; //2}public void multiply() {if (flag) { //3int ret = a * a;//4}}</code></pre><p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p><h2 id="2-单例模式的实现，典型的双重检查锁定（DCL）"><a href="#2-单例模式的实现，典型的双重检查锁定（DCL）" class="headerlink" title="2. 单例模式的实现，典型的双重检查锁定（DCL）"></a>2. 单例模式的实现，典型的双重检查锁定（DCL）</h2><pre><code>class Singleton{private volatile static Singleton instance = null;private Singleton() {}public static Singleton getInstance() {if(instance==null) {synchronized (Singleton.class) {if(instance==null)instance = new Singleton();}}return instance;}}</code></pre><p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p><h1 id="八、面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"><a href="#八、面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？" class="headerlink" title="八、面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"></a>八、面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？</h1><p>好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没~</p><p>来源：<br>juejin.im/post/5a2b53b7f265da432a7b821c</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的各项功能解决了哪些问题？</title>
      <link href="/2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/"/>
      <url>/2019/03/25/redis-de-ge-xiang-gong-neng-jie-jue-liao-na-xie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><p>官方简介解释到：Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。</p><p>同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。</p><p>它还内建了复制，lua脚本，LRU，事务等功能，通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。</p><p>综上所述，Redis提供了丰富的功能，初次见到可能会感觉眼花缭乱，这些功能都是干嘛用的？都解决了什么问题？什么情况下才会用到相应的功能？那么下面从零开始，一步一步的演进来粗略的解释下。</p><h1 id="1、从零开始"><a href="#1、从零开始" class="headerlink" title="1、从零开始"></a>1、从零开始</h1><p>最初的需求非常简单，我们有一个提供热点新闻列表的api：<a href="http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。" target="_blank" rel="noopener">http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。</a></p><p>随后我们就着手于如何提升一下api消费者感知的性能，很快最简单粗暴的第一个方案就出来了：为API的响应加上基于HTTP的缓存控制 cache-control:max-age=600 ，即让消费者可以缓存这个响应十分钟。</p><p>如果api消费者如果有效的利用了响应中的缓存控制信息，则可以有效的改善其感知的性能（10分钟以内）。但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。</p><h1 id="2、基于本机内存的缓存"><a href="#2、基于本机内存的缓存" class="headerlink" title="2、基于本机内存的缓存"></a>2、基于本机内存的缓存</h1><p>为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。</p><p>后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。</p><p>其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆满了。。。</p><h1 id="3、服务端的Redis"><a href="#3、服务端的Redis" class="headerlink" title="3、服务端的Redis"></a>3、服务端的Redis</h1><p>在API服务器的内存都被缓存塞满的时候，我们发现不得不另想解决方案了。最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，把它的内存配置的大大的。然后我们就盯上了redis。。。</p><p>至于如何配置部署redis这里不解释了，redis官方有详细的介绍。随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。</p><h2 id="3-1-持久化（Persistence）"><a href="#3-1-持久化（Persistence）" class="headerlink" title="3.1 持久化（Persistence）"></a>3.1 持久化（Persistence）</h2><p>单台的Redis服务器一个月总有那么几天心情不好，心情不好就罢工了，导致所有的缓存都丢失了（redis的数据是存储在内存的嘛）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。</p><p>所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。</p><h2 id="3-2-哨兵（Sentinel）和复制（Replication）"><a href="#3-2-哨兵（Sentinel）和复制（Replication）" class="headerlink" title="3.2 哨兵（Sentinel）和复制（Replication）"></a>3.2 哨兵（Sentinel）和复制（Replication）</h2><p>Redis服务器毫无征兆的罢工是个麻烦事。那么怎办办？答曰：备份一台，你挂了它上。那么如何得知某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。</p><p>Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。</p><h2 id="3-3-集群（Cluster）"><a href="#3-3-集群（Cluster）" class="headerlink" title="3.3 集群（Cluster）"></a>3.3 集群（Cluster）</h2><p>单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。</p><p>所以我们就需要一种解决方案，可以让我们横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：基于网络应用的架构）。</p><p>在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，也就是说redis本身并不关心分布式的事情，而是交由twemproxy和codis来负责。</p><p>而redis官方给出的cluster方案则是把分布式的这部分事情做到了每一个redis服务器中，使其不再需要其他的组件就可以独立的完成分布式的要求。我们这里不关心这些方案的优略，我们关注一下这里的分布式到底是要处理那些事情?也就是twemproxy和codis独立处理的处理分布式的这部分逻辑和cluster集成到redis服务的这部分逻辑到底在解决什么问题？</p><p>如我们前面所说的，一个分布式的服务在外界看来就像是一个集中式的服务一样。那么要做到这一点就面临着有一个问题需要解决：既是增加或减少分布式服务中的服务器的数量，对消费这个服务的客户端而言应该是无感的；那么也就意味着客户端不能穿透分布式服务，把自己绑死到某一个台的服务器上去，因为一旦如此，你就再也无法新增服务器，也无法进行故障替换。</p><p>解决这个问题有两个路子：</p><p>第一个路子最直接，那就是我加一个中间层来隔离这种具体的依赖，即twemproxy采用的方式，让所有的客户端只能通过它来消费redsi服务，通过它来隔离这种依赖（但是你会发现twermproxy会成为一个单点），这种情况下每台redis服务器都是独立的，它们之间彼此不知对方的存在；</p><p>第二个路子是让redis服务器知道彼此的存在，通过重定向的机制来引导客户端来完成自己所需要的操作，比如客户端链接到了某一个redis服务器，说我要执行这个操作，redis服务器发现自己无法完成这个操作，那么就把能完成这个操作的服务器的信息给到客户端，让客户端去请求另外的一个服务器，这时候你就会发现每一个redis服务器都需要保持一份完整的分布式服务器信息的一份资料，不然它怎么知道让客户端去找其他的哪个服务器来执行客户端想要的操作呢。</p><p>上面这一大段解释了这么多，不知有没有发现不管是第一个路子还是第二个路子，都有一个共同的东西存在，那就是分布式服务中所有服务器以及其能提供的服务的信息。这些信息无论如何也是要存在的，区别在于第一个路子是把这部分信息单独来管理，用这些信息来协调后端的多个独立的redis服务器；第二个路子则是让每一个redis服务器都持有这份信息，彼此知道对方的存在，来达成和第一个路子一样的目的，优点是不再需要一个额外的组件来处理这部分事情。</p><p>Redis Cluster的具体实现细节则是采用了Hash槽的概念，即预先分配出来16384个槽：在客户端通过对Key进行CRC16（key）% 16384运算得到对应的槽是哪一个；在redis服务端则是每个服务器负责一部分槽，当有新的服务器加入或者移除的时候，再来迁移这些槽以及其对应的数据，同时每个服务器都持有完整的槽和其对应的服务器的信息，这就使得服务器端可以进行对客户端的请求进行重定向处理。</p><h1 id="4、客户端的Redis"><a href="#4、客户端的Redis" class="headerlink" title="4、客户端的Redis"></a>4、客户端的Redis</h1><p>上面的第三小节主要介绍的是Redis服务端的演进步骤，解释了Redis如何从一个单机的服务，进化为一个高可用的、去中心化的、分布式的存储系统。这一小节则是关注下客户端可以消费的redis服务。</p><h2 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h2><p>redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持：</p><pre><code>string：最基本的数据类型，二进制安全的字符串，最大512M。list：按照添加顺序保持顺序的字符串列表。set：无序的字符串集合，不存在重复的元素。sorted set：已排序的字符串集合。hash：key-value对的一种集合。bitmap：更细化的一种操作，以bit为单位。hyperloglog：基于概率的数据结构。</code></pre><p>这些众多的数据类型，主要是为了支持各种场景的需要，当然每种类型都有不同的时间复杂度。其实这些复杂的数据结构相当于之前我在《解读REST》这个系列博客基于网络应用的架构风格中介绍到的远程数据访问（Remote Data Access = RDA）的具体实现，即通过在服务器上执行一组标准的操作命令，在服务端之间得到想要的缩小后的结果集，从而简化客户端的使用，也可以提高网络性能。比如如果没有list这种数据结构，你就只能把list存成一个string，客户端拿到完整的list，操作后再完整的提交给redis，会产生很大的浪费。</p><h2 id="4-2-事务"><a href="#4-2-事务" class="headerlink" title="4.2 事务"></a>4.2 事务</h2><p>上述数据类型中，每一个数据类型都有独立的命令来进行操作，很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。</p><h2 id="4-3-Lua脚本"><a href="#4-3-Lua脚本" class="headerlink" title="4.3 Lua脚本"></a>4.3 Lua脚本</h2><p>在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于基于网络应用的架构风格中介绍到的远程求值（Remote Evluation = REV）的具体实现。</p><h2 id="4-4-管道"><a href="#4-4-管道" class="headerlink" title="4.4 管道"></a>4.4 管道</h2><p>因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。管道和事务的差异在于管道是为了节省通信的开销，但是并不会保证原子性。</p><h2 id="4-5-分布式锁"><a href="#4-5-分布式锁" class="headerlink" title="4.5 分布式锁"></a>4.5 分布式锁</h2><p>官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下：</p><pre><code>SET resource_name my_random_value NX PX 30000if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;,KEYS[1])else    return 0end</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇着重从抽象层面来解释下redis的各项功能以及其存在的目的，而没有关心其具体的细节是什么。从而可以聚焦于其解决的问题，依据抽象层面的概念可以使得我们在特定的场景下选择更合适的方案，而非局限于其技术细节。</p><p>来源：<br>作者：blackheart<br><a href="http://www.cnblogs.com/linianhui" target="_blank" rel="noopener">www.cnblogs.com/linianhui</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈final、finally、finalize有什么不同？</title>
      <link href="/2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/"/>
      <url>/2019/03/23/tan-tan-final-finally-finalize-you-shi-me-bu-tong/</url>
      
        <content type="html"><![CDATA[<p>初级程序猿面试一般会问的问题。</p><p>可以按照以下回答：</p><h2 id="1-final-可以用来修饰类、方法、变量。"><a href="#1-final-可以用来修饰类、方法、变量。" class="headerlink" title="1. final 可以用来修饰类、方法、变量。"></a>1. final 可以用来修饰类、方法、变量。</h2><pre><code>分别有不同的意义：final 修饰的 class 代表不可以继承扩展final 的变量是不可以修改的final 的方法也是不可以重写的（override）</code></pre><h2 id="2-finally-则是-Java-保证重点代码一定要被执行的一种机制。"><a href="#2-finally-则是-Java-保证重点代码一定要被执行的一种机制。" class="headerlink" title="2. finally 则是 Java 保证重点代码一定要被执行的一种机制。"></a>2. finally 则是 Java 保证重点代码一定要被执行的一种机制。</h2><pre><code>我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</code></pre><h2 id="3-finalize-是基础类-java-lang-Object-的一个方法。"><a href="#3-finalize-是基础类-java-lang-Object-的一个方法。" class="headerlink" title="3.finalize 是基础类 java.lang.Object 的一个方法。"></a>3.finalize 是基础类 java.lang.Object 的一个方法。</h2><pre><code>它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。</code></pre><p>注意事项：<br>1，不要在 finally 中使用 return 语句。<br>2，finally 总是执行，除非程序或者线程被中断。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请对比Exception和Error有什么区别？</title>
      <link href="/2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/"/>
      <url>/2019/03/23/qing-dui-bi-exception-he-error-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>面试一般是这样问：运行时异常与一般异常有什么区别？    </p><p>简单点来讲就是：运行时异常可以不处理，一般异常必须处理。</p><p>运行时异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p><p>一般异常，JAVA编译器强制要求用户必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。</p><p>不同点：</p><p>1.从继承来讲，Exception 和 Error都继承自Throwable类。</p><p>2.Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。</p><p>Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java转型大数据开发技能</title>
      <link href="/2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/"/>
      <url>/2019/03/21/java-zhuan-xing-da-shu-ju-kai-fa-ji-neng/</url>
      
        <content type="html"><![CDATA[<p>很多做程序猿都知道，对于技术方面，擅长大家一直提倡的是精一门，再横向发展，多学一点总不是坏事。</p><p>什么意思呢？</p><pre><code>就是我们当前工作用到的那一门技术一定要学好、学精、学深，然后可以拓展其他相关的技术栈。</code></pre><p>如此多的技术，怎么学得过来呢？</p><pre><code>我觉得以你自己的岗位为主，其他为辅，关于自己工作相关的技术，花更多的时间和精力，研究得更深入，其他领域的可以了解和关注，等到需要用到或者感兴趣的时候，在深入学习即可。</code></pre><p>那作为 Java 开发，除了 Java 还可以学什么？</p><pre><code>大数据可能是一个不错的方向。    一、转型大数据需要哪些技能？    技术层面来说，如果你初步掌握Java编程，转型大数据都是非常轻松的具有天然的优势。    Java编程是大数据开发的基础，Java编程是必备技能；    大数据使用的Hadoop(在分布式服务器集群上存储海量数据并运行分布式分析应用的一种方法)需要Java基础， 所以有很多搞Java的都在往这hadoop大数据方向转。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/2019/03/21/about/"/>
      <url>/2019/03/21/about/</url>
      
        <content type="html"><![CDATA[<h1 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h1><p>博主是一名Java码农。</p><p>虽然还未走上人生巅峰，但是一直保持着一个码农的自我修养。</p><p>用一句话概括博主：每天瞎逼忙，还没赚到钱。</p><p>但是博主有一颗分享技术的心，我会尽量用通俗易懂的方式，分享个人的知识。</p><p>博客的宗旨就是分享知识，分享技术，不一定高深，但一定是博主用心写作而成的。</p><p>所有人都是从0开始起步，在学习过程中，会遇到各种困难，这个时候如果可以借鉴别人的经验，会让我们省力不少，希望我的博客也能帮助到你。</p>]]></content>
      
      
      <categories>
          
          <category> 关于 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试中最高频的那20%知识点！</title>
      <link href="/2019/03/21/java-mian-shi/"/>
      <url>/2019/03/21/java-mian-shi/</url>
      
        <content type="html"><![CDATA[<p>Java目前已经不仅仅是一门开发语言，而是一整套生态体系。</p><p>作为一个Java程序员，既是幸运的，也是不幸的。幸运的是我们有很多轮子可以拿过来用，不幸的是我们有太多的轮子需要学习。</p><p>但是，无论是日常工作还是面试问题，也都符合二八原则。即掌握20%的知识，就能解决80%的问题。</p><p>那么，Java程序员必须掌握的20%知识点都有哪些呢？</p><p>个人认为包括以下内容：</p><pre><code>Java基础知识，如集合类、IO、泛型等。JVM底层知识，如类加载机制、GC、JVM内存结构等。Java并发编程知识，如Java内存模型、并发包、线程池、netty等。开发框架知识，如Spring、mybatis、springboot、springMVC等。分布式相关知识，如CAP理论、分布式锁、分布式事务、Zookeeper、spring Cloud等。其他基础知识，编程语言、网络方面、数据库、数据结构和算法。中间件相关知识，如Redis、rabbitMQ、Dubbo等。服务器相关知识，如tomcat、jetty、jboss等。</code></pre><p>以上这些知识，就是最高频的面试问题，以及工作中需要用到的知识。当然，一个程序员想要掌握以上所有知识，可能需要花费很长时间。这个过程注定是漫长且孤独的。</p><p>来源：<br><a href="https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ws79USt9mkkANGrVwdpkpw</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
